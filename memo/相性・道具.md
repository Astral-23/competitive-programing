
pcnt(a ^ b) = aとbで異なるbitの個数

# 解法ローテ
解法の表現力を上げる

##  評価値優先ローテ
0. 全ての解法の評価値を0で初期化する
1. 各解法を、その線で答えにたどり着けそうなほど高評価する
2. 一番評価値が高い解法について考える。この時、評価値は時間経過で減少する
3. 全部負になったら、新規開拓を考える

### 低評価
- 非常に複雑な手計算を必要としそうな線
- 結局求めるのが困難な値が終盤にありそうな線
- 具体例を何個も書いて成立を試す線
    - 構築にありがちで、時間がかかるので後回し
- 自明でないTLEケースの具体的な特定
    - ボトルになっていそうな箇所がわかるだけでも改善の余地はある

    
### 新規開拓(忘れがち)

- 固定の方向の逆化
    - 小さい方から見てうまくいかんなら大きい方から！
        - 高速化できない
        - 貪欲が成立しない
    - 値による固定 <-> 位置による固定

- 困った時、先ず試すのは簡単な解法・単純な事実の検証が良い

- 方向性が違うnaiveからの高速化
    - 便利そうな命題をもとにすると生えやすい
- 貪欲 <-> dp

- 数え上げにおける余事象

- 見たことがない問題設定は、細かい性質・解決に直結しそうなな性質より前に有名な・大きな性質の成立を調べるほうが優先度高い
    - 関数なら単調性とか

## 何も前提を置かない
何か固定して問題を睨んでダメな時、固定を外したほうが良い場合がある
- 「Sから1つ固定」の時点で、S全体について成立する事実しか(場合分けに気づかない限り)言えない
    - 最適化の時: 貪欲で考える対象を絞れるケース
- 「順番を決めて解く」の時点で、その要素を1つずつ見ていくような解法しか生えない


### 手で解く時
樹形図は便利
- 操作の種類が少ない時書き出す

<br><br>

# 場合分け
> 命題: 場合分けを細かくすることによって、それぞれの場合に良い構造が生まれる場合がある

> 系: それぞれの場合を解いて最後にマージすれば問題が解ける

> 経験則: 基本的に、場合分けできるならば場合分けした方が解法が生える

- 本質的っぽい場合分けを躊躇しない方が、めんどくさそう・時間がかかりそうでも楽に解ける場合がある
    - 場合分けを削減するテクも躊躇しない
1. 状況の場合分け
    - 大小とか
2. 自由度の決定の場合分け
    - 例えば3種類あるなら
        - 0 - 1
        - 0 - 2
        - 1 - 0
        - 1 - 2
        - 2 - 0
        - 2 - 1
        - 同じやつ

> 命題: 切り捨てが式に入る時、割る数をmとして、 mod m を場合分けすれば切り捨て記号を消せる

<br><br>

# 全探索

## 全探索の設計

- 1: 素直に、対象全てを（問題文に言われた通り）全探索する。あるいは、探索する対象の一部を全探索し、他の部分はまとめて計算することを狙う
    - -> まとめるdp

- 2: 対象する探索が必ず持つ特徴に注目し、その特徴の値で場合分けする。
    - 必要な事: 全ての探索対象がそれを持つ（そうで無いと全探索にならない）
    - いつ考える: 一部を全探索するという事。考察が進まないのでどうにかしてまともを全探索したいが、まともな対象がパッと思いつかない時にこれを考える
        - 特に、対象が持つ極端な部分に注目する


- 3: とりあえず初手の結果を全探索して、問題が小さくなってないか眺める
    - 小さくなっていたら -> 再帰的に解くdp


### 全探索できるものは全探索
固定してしまうということ。
- 最適化: 常に全探索を考える。O(1)で結果を出そうとしない。
- 特に、何も手がなくなったらとりあえず全探索を考える


## マッチさせるような全探索
- 全て固定しては間に合わない -> 一部だけ固定して、その結果を突き合わせるような全探索
- このとき、「付き合わせられる条件」について、それぞれについて独立な方が良い
    - 特に幾何。図形の点を指定しては間に合わない -> 傾き一致でまず絞って、その中でやる
    - このとき、条件式が（それぞれについて独立な値） = (それぞれについて独立な値）　となるような特徴量で分類する。

    
## 条件を満たすものだけ探索 -> より広い集団を探索
- 必要: 条件を絞ったものだけを見る探索では無理そうで、より広い範囲を探索しても、間に合う
    - 特に、条件を満たすかの判定を今度はする必要がある。よって、その判定法に則って探索するとか。
- いつ考える: 「条件を満たすもの」が掴みづらい時



## 状態数絞った探索が厳しいなら、状態数を増やす
**究極: 上手く解く方法が思いつかないなら、計算量間に合わなそうでも全探索を考る**
- dpで遷移が上手くできないなら、状態全て持つ全探索を考える
    - 例えばinplace dpのように、テーブルとループが大きくても高速に計算できるケースはある。
    - このような場合、遷移をいつも以上に積極的に数式で表現すると良い

- **問題を解く上で注目している要素の計算が難しいなら、他の要素に注目する**
    - **特に、判定問題を綺麗に解けたとしても、その計算に必要な要素の管理が難しいなら、別の(もっと多くても良い)要素で判定問題を解き直せないか考える**
        - **最初の解でうまく出来なかったからと言って、判定問題を元に解くという姿勢を捨てない**

## あり得る状態を全て(=集合を)持つ探索
- 状態が分岐する かつ 最適化という時、どちらの状態を選ぶべきか分からないので困る場合がある
    - ここで、集合(=全ての分岐)を持って探索すれば計算はできる
- 必要な事: 今取りうる状態が保持できる事 & 遷移ができる事(特に、操作列の総数とは無関係)
    - 典型: 状態が小さい事...どれだけ分岐しようが・操作列の集合が多かろうが、結局今の状態は小さい時、ほぼできる
        - これが2^30になると、少なくとも集合に良い構造がないと持てない。
        - 集合に他の良い構造があれば（区間とか）、いくらでも状態を持てるが
    - 遷移...分岐が高速に計算できないと集合の管理が難しくなる
    - 特に、 |状態| * |遷移|が十分小さければ、グラフに起こす事でグラフのアプローチが可能になる
- いつ考える: 状態の分岐のうちどちらを選ぶのが最適か分からない（やはり最適化や判定）状況で、上の必要なことを満たす時

- 複数要素ある時、それぞれ独立に状態を持てるなら、単にそれぞれ取れる集合を並列に持てばよく、|状態|に線形な計算量（つまり、集合を持つ上でも独立性は良い構造）
    - これが独立にとれないと、|状態|^nになる


- なお、これは決定を保留する単作とも近い気がする
    - 状態こそ多いが、操作列の保持ならできる（まとめられるとか）等
    - つまり、遷移（操作）の集合の方に、保持して探索するのに良い構造があってもこの探索はできる

## 全単射(1:1対応)を使う
- 全単射があるなら、個数が一致する。よって、対応の先を数えても良い
    - 様々な言い換えの正当性の基盤
    - 操作 : 結果が典型的
        - 結果の母集団こそわかれど実際に条件を満たすものがぼやけている時、操作ならそのまま集合のサイズを計算すれば良いなど
    - あるいは単に「逆から見る」の考察の正当化もこれ

## 探索範囲の絞り方
- 探索範囲の必要条件を考える
- 最適化:答えを固定したとき、それを改善する手法があるなら、改善できる限りするとすることで「改善ができない状態」だけを探索すれば良くなる
    - この時、改善の条件が緩いほど、改善できない状態が少なくなる
        - 例えば、1回の改善の幅が小さいと「その幅さえ残っていない」ものだけ調べれば良くなる
        - その条件がだせないと意味ないけどね

## 全探索をまとめるメモ化再帰
- 全探索するが、同一視できる状態が沢山あるという時、まとめたくなる
- メモ化再帰が一番楽だろう
    - 貰う感じにはなる

## 枝刈りすればオーダー単位で変化する事は多分ない
- 何か一意という時、探索したやつに後からそこを付加したくなるが、重複等の処理がついてくる
- ここで、一意な部分は探索で一意になるように枝刈りすれば、オーダーは悪化していないだろう -> 楽に


### ooしてはいけないという制約の言い換え
ooしてはいけない⇔xxあるいはqq
等と言い換えられると、後者を用いて全探索ができる。
- [例題](https://atcoder.jp/contests/arc049/tasks/arc049_c)
    - タイプ2 を全探索して単純にしたい
    - しかし、制約は常に守られるものなので、選択の余地などない
    - [1]塗る頂点全探索(2^20)
    - [2]制約2を「uを塗らない or uを先に塗る」と言い換え、どちらにするか(2^10)

### 全探索の軸の工夫

- 大きい方から埋めたい && 位置も考えたい
    - 挿入dp
    - 区間dp


## 探索的に無理そうなら、必要条件を考える

### 答えを全列挙する実験

- 特徴がある→なぜその特徴が生まれるのか考える
    - それによって、一般にその"特徴"を拡張できたりする
        - grundy数の実験
        - 
- 特徴がある→その特長を全て含む様な探索ができるか？
    - できるなら、探索範囲をそれに絞って仕舞えば良い


### 計算量削減につながる必要条件
- 0/1列であって、1が2つ連続しないものの個数
    - [フィボナッチ数列](https://x.com/e869120/status/1386138990361726978/photo/4)
    - 2 ^ len から 1.5 ^ len ぐらいまで落ちる


## 高速化
[here](https://hackmd.io/xcx7zFLXQdGE4tdth5_5nQ)


## 他
- 数学的な考察が難しそうなら、dpを考えるのが有効
    - 全探索するということ

<br><br>

# 独立性
独立とは: 複数の要素/操作について、
1. 一方が取れる状態・自由度が、他方の状態に全く関わらない・依存しない。
2. 一方の値の計算に、他方の状態が必要ない

- 具体例: 自由度 i, j を動かしながら f(i, j) を求める時、 f(i, j) = g(i) + h(j) のように表せれば、g ,h はそれぞれ j, iに対して独立

- >命題: 自由度を頂点とし、直接の制約や関わりがある頂点同士に辺を張った時、同じ連結成分に属さないものは独立
    - 自由度a, bについて、aの値がbに依存せず、その逆も成立するならa,bは独立
        - 例: $\sum_{i, j}A[i]B[j] = (\sum_i A[i]) (\sum_j B[j])$
            - $\sum_{s := 0,...,m-1の部分集合} A[s]B[s]C[s]$ のように添字が共通しているときは使えない
                - 添字の動かし方を独立なものごとに分けると良い
                - $\sum_{s := 0,...,m-1の部分集合} = \sum_{0がin / out} \sum_{1が in/out}...$ である
                    - かつ右辺がそれぞれの添字で表されるであれば良い
        - dpで言えば、aの決定にbは関係ないので、情報として持たなくて良い
        - 制約の貼られ方に特徴があると良い（自由度を頂点としたグラフを考える）

- >命題: 独立なものは別々に計算・考察した後最後にまとめることができる。つまり、同時に決定しなくて良い。
    - 例えば集合関数について考えるとき、F(S) = sum f(要素) で考えられたら簡単
    - 例: 木dp の様に、部分部分でまとめながら全体を決定

- この時、互いが互いに全く依存しないので、「独立な物同士で別々に前計算してそれを掛け合わせる」ことで場合の和を、「maxを取る」事で最適化を・条件判定を...とうとう、複数の（独立な）条件が絡む計算ができる
    - 嬉しい: 全体をまとめて計算するより計算量が落ちる
        - dpで言えば、個別に計算して最後に合算するように設計することで、独立なパートそれぞれについて状態数が S, Tである時、持つべき状態数が S * T から S + Tに落ちる
        - これに限らず、非自明な高速化がたくさんある

 

- 複数ある操作、特に2次元の操作について、縦の操作と横の操作を独立に考えて良いというのは頻出である。
    - 必要な事: ある操作/要素が、ある制約については全く影響を及ぼさない事
        - 一つの操作が、それぞれの制約にどのように影響するかを考える必要がある

## 独立への分解公式
1.  $$\sum_{s := 0,...,m-1の部分集合} = \sum_{0がin / out} \sum_{1が in/out}...$$
2.  $$f(l, r) = f(r, l) \Rightarrow \sum_{0 \le l < r < n} f(l, r) = \frac{\sum_{0 \le l, r < n} f(l, r) - \sum_{0 \le i < n}f(i, i)}{2}$$
- 注意: $f(l, r) \neq f(r, l)$ では成立しない。例: $f(l, r) = r - l$

## 関わりがある要素に辺を張っておく
- すると、辺が無い要素間は「関わりがない」或いは「関わりが薄い」と言うことになる
    - よって、新たに「辺が無い要素間」について成立することがある場合がある
    - 特に、「辺がある要素同士」だけではなく、「辺が無い要素間」で成立することの考察をするべき

> 命題: 関係がある頂点に辺を張ってできるグラフは一般のグラフとは限らず、何らかの構造を持つ場合がある
- 閉路がない => 木
    - 特に、状況が実は木であったという時、単に木DPによって問題が解決することがある
- パスグラフ
- よって、グラフに起こしたときはその構造を実験で見る

- > 命題: シミュレーション的な計算をする時で、シミュレーションの依存関係をグラフに起こしたら木になる場合、部分木ごとに決定できる
- シミュレーションをそのまま眺めるよりも計算量が良い
    - 部分的な値に注目するシミュレーションの時
### グラフの作り方
- > 命題: 未来では・最終的な結果では自明に関わるが最初は独立という時、途中段階を頂点として加えることによってそのまま考えるよりも辺の本数の少ないグラフが作れる
    - 木になると特に良い



## 直接の関係が近くにしかない時
![alt text](<images/kankei.png>)
- 直接の関係は近くにしかなく、その関係によって全体が関わり合っていると言う状況

- dp[i][State] := [0, i]だけを考慮した。Stateには
    - その時の全体の答え
    - その結果に対応する $i$ 項目の状態
- を持つ。 dp[i] -> dp[i + 1]は、 $i + 1$ 項目の状態を固定しつつ、 $i$ 番目の状態から全体の答えを補正する
- と言う枠組みのdpが一般に使えそう
    - 特に、新たに考慮する要素 i + 1 と関係があるのが i だけと言う状況が良い。i + 1 と i + 2の関係は保留し、Stateに残された「i + 1の状態」から計算する。

- 特にdpは全探索なので、この様なdpで間に合うなら解ける
- >系: 「連続3項」について制約がある・操作ができる時、自分を含めて3項持てば良い


- 制約を貼ったグラフで辺が少ないと理解できる
    - >系: pspの時、辺の本数がある程度抑えられる
 

## 分けて・独立に計算して最後に集約する。
- パラメータpを動かしながら f(g(a1), g(a2), ... , g(an)) をそれぞれのpについて求めたいという状況は頻出
    - 答え決めうちながら判定、最適化など

- この時、pを最初に固定するのではなく、要素を固定したのち、その要素の振る舞いだけに注目することによって高速化がなされる事がある

- 必要な事: 1要素に注目する考察で答えに辿り着ける事。他を無視する事で高速にもとまる事・「似たような要素」についてまとめる事で高速に計算できる事・既に計算したものの再利用
    - 特に、全体としてはfの結果は複雑だが、個々の g(ai) のpの変化に対する振る舞いは単純・単調・区間になっている時

- いつ考える: パラメータを固定しつつ、n要素についての判定をする時。上記を満たしそうな計算をする時。
    - 各a1, ... ,anが独立に振る舞えると特にやりやすい。
    - max(pを動かす時の, max(a1, a2, ... ,an)) -> 要素を固定し、各aiについて、aiが最大になる時の値を求めて、最後にそれをmaxでたたむ

    - pを動かす（この時、a1, ... , anが全て条件を満たすか?) -> aiについて、条件を満たすpを列挙して、合算


## 寄与への分解
- ある値が定義された時、それが $\sum 個々の要素の値$ や $\max 個々の要素の値$ の形で表されると、そうでない時と比べて色々なアプローチが取れる
    - 命題: 分割した1つに注目した時、それを求めるに当たって独立な（関係がなくなる）・無視しても答えが変化しない情報を全部ロストさせて良い
        - 問題が楽になるので、分解する度に考える
    - 別々に計算
    - 貪欲に良いものから採用
    - 背景に独立性がありそう

- よって、求め辛い値やふわっとした最適化をする時、値をキヨに上手く分解できると、そうでない時と比べて楽に解ける事が多い
    - ので、分解しようと睨むと自然と楽な議論が生える事がある
- いつ考える: 
    - 値が全体の関係から定まっている形で表されていて求め辛い時 -> 寄与への分解を考える
    - 寄与に分解できる形をしている -> 寄与に分解して考えてみる
        - 命題: $\sum, \max$ => 寄与に分解できる
            - 操作の回数も分解できることが多い
                - 操作を場合分けすると全体の回数が $\sum$ で表されるため
### $\sum$ の分離

### $\max$ や条件の分離
> 命題: $\max(a_0, a_1, \dots)$ を求める際、$a_0, a_1, \dots$ をそれぞれ独立に求めて良い
- 1回の $\max$ ならほとんど定義だが、複数回計算するというとき、都合の良い順序で求めて良い
    - 次元が起きることもある
- 一般に、 $\forall$ や $\exists$ で複数の値をまとめるような条件は上の様に対象を別々に計算して最後にまとめることができる


## 別々に計算して良いものは別々にする
> 命題: [l, r)の区間和は [0, l) と [0, r) の区間和で表せて、かつ次元が1つ落ちている

このように、別々に処理して良いものを別々に処理することで、実装が楽になったり問題の構造がシンプルになる場合がある。

> 命題: 「条件を満たすもの」について列挙する時、条件を考慮せずに列挙したのち、違反するものがあるなら消すという方法でも列挙できる

- 列挙のたびにチェックするよりも楽・高速。

## 独立性を持つもの
> 命題: 連続部分列に操作をする際、数列で常に不変な要素があるならば、その前後で独立
- 最終的に残るもの・操作しないものを決め打つとそこで独立になる


## k個選ぶ/k個だけOOである　ものの探索
> 命題: $k$ 個選ぶ選択をバラバラにできるなら、計算量は $k$ について多項式になる。また、一度に選ぶ場合は $k$ についての指数時間

<br><br>

# 段階的なもの

> 命題: 複数の段階に分けられる計算は、計算を段階的に行い、それぞれの段階においてまとめられるものを纏めることで高速化がなされる
- dp, たくさんの操作、$f^{-1}(y)$の計算(合成関数)

- 複数の段階の計算を一気にやると1つの計算が高速化されるのに比べ、段階的に分けた計算は複数の独立な計算を高速化する
<br><br>

# 何かを固定する考察
問題の整理・言い換え寄り


- 必要な事: 固定した問題がまず解ける事
    - 固定は解法の前提になったりする要素ではあるが、そもそも固定しても解けないならその固定の線はダメ
    
- 以下を踏まえ、**何かを固定したら、その固定による前計算や、新たに言えるようになった事、状況の変化を必ず考える事**
    - これが旨みの大部分
        - 高速化という一面が大きい時もあるだろうが
    - 例えば答えの固定
- >命題: 固定したものはもはや自由度を持たない
    - 自由度が減るので、一般に問題が簡単になる

- >命題: 複数の関わり合っているものを考える時、一部の自由度を固定した時に残りの自由度を決定できれば後は固定した自由度を動かす問題になり、実質的に自由度を独立に考えられる
    - 特に、2つ目の自由度について、一度解ければもう見なくて良い
        - 典型的: 最適な操作がわかれば、あとはもうそれによる結果だけ見れば良い
        - 典型的: 2つの操作について、両方の自由度を同時に考えない
    - >系: 操作1, 2とある時、操作1の後に操作2をするとしても答えが変化しないならば、「操作1を決め打った時の操作2の内容とその結果」を考えることで操作1と2を独立に考えられる

- >命題: 任意に固定した要素が満たす命題は、すべての要素が満たす
    - 考えるものの構造を調べたい時に有効
        - 特に、固定した要素依存のパラメータが必要な時こうすると圧倒的に考えやすい
    - **特に構造の考察において、固定の自由度が(全探索できないほどに)多いことは問題ではなく、固定を躊躇する理由にならない**
        - 上手い固定(途中段階)が作れた時点で考察が進んでいるというのもある


- 時には、固定するためには何を定めたら良いか？がはっきりしておらず、こちらを先に集中して考える必要が出てくる。
    - パッと出ないからといって諦めない


## たくさんの固定を多項式時間に落とす一般テク
> 命題: 固定をたくさんする上で計算すると言う時、以下の枠組みの2ができるならば計算量を落とせる
> 1. 探索対象を1つ固定して、それについて「この時の答えは何か」の計算を作る
> 2. 計算を段階的にすることで、固定も段階的にする
> 3. 各段階において、計算に用いる情報が一致するものを纏めるdpで数え上げる。遷移では各段階ごとに探索対象を固定する。

> 系: 固定が指数個/ nに対して大きすぎる多項式 であっても、上のテクで多項式に落とせる

- 他に、単に「最終結果が同じ」物を最初からまとめたり、固定の動かし方 = 場合の数 より動かし方を数えれば良いとなることもある

## 固定するもの
> 命題: 複数の制約を満たすものを考える時、一部の制約だけ抜き出しその制約に関わる部分だけ固定することで途中段階の固定ができる
- 制約を別々に考えられて良い
- 構築でも有用(一部の制約を満たすように、そこだけ決定してみる)\


> 経験則: 細かく固定して複雑になった時、固定の荒さを上げることでも有用な情報が手に入る場合がある
- 値まで固定したらやばい -> 要素のをいくつかの種類に大別して、その種類だけ固定


> 経験則: 何かを固定したら場合分けが複雑になった場合、より些細な固定にすると有用な構造が手に入る場合がある
- 全体を決定づけるものを一度に複数固定したせいで、固定の中で場合分けができたと解釈 -> 固定するものをより小さくする

上2つは荒くするor数を減らす

## 場合分けの固定
- 独立性や絡み合いなどを考えずとも、単に、「状況が複雑だ」と言う時に、上手い場合分けをすると簡明になる場合がある  
    - そして、その固定を動かせれば、解ける
    - イメージ的には、どうせ全て探索する必要がある時、とりあえず固定した時の解法を考えるような
- よって、意味がわからなかったら、とりあえず場合分け、そして固定を考えると良い

## 固定の順番
- 時々、固定するものは複数個になる
    - そういう時、固定する順番によって、オーダーが変化したりする

> 命題: 固定が前に来るほど、その固定に基づいた前計算ができる(そして、高速化される)
- 固定はできるだけ前に持っていった方が良い
  
      
## 余裕がある時の"損するかもしれない"固定
綺麗な解決めうちとは少し違う
- 最適な動きを取らなくて良いので、ある程度で実現しろ・可能かどうかを判定しろと言う問題は多い
- そう言う時、敢えて自分の動きを制限するような・損をするような固定をすることで、状況が単純になり、却って問題が解きやすくなると言う場合が往々にしてある
- モチベは「考察を進められる程度に状況を簡単にすること」

## 最終的な状態の固定
- 最終的な状態を固定した時の値の構造を考えることで、途中をどうすれば良いかわかる場合がある


<br><br>

# 探索対象・その周辺・遷移の"条件を満たす時の構造"についての考察
**大抵の場合、与えられた問題は一般ではなく特殊ケースについてである**
- > 命題: 何か条件を満たしている事を仮定している時、その条件から形に制約がつくことで一般の時と比べて条件や計算がdrasticに簡潔になる場合がある
    - 何を考察するにしろ、条件を満たしていると仮定した時点で一般の時と全く変わった問題に変化している可能性がある（上の命題より）を意識しなければならない
- > 定理: 「条件を満たすものだけ探索する」場合、「条件を満たす集合・その周辺が必ず満たす構造」を元に探索でき、元々考えていた探索対象のうちその構造を満たさないものを破棄できる
    - ので、考察がガラッと変わる場合が多い。**考察の枕詞として「探索対象ならば・条件を満たすならば・最適解ならば」がつきやすい**
        - もう少し弱いが有用なものとして、**「条件を満たす物でOOなものが必ずある」の場合もある**
            - 命題: 条件を満たす物でOOなものが必ずある => OOなものだけを探索しても、条件を満たすものが1つ以上見つかる
            - こちらも、数え上げでなければ考察の対象をOOに制限しても良い ので、同じぐらい有用
  
- いつ考える: 状態を持って遷移、では上手くいかない時で、探索対象の構造を活かせてないと感じた時
    - 特に、無駄な可能性のある遷移をしている場合、構造が上手く活かせていない可能性が高い
        - dp配列で、値が0が沢山な時は無駄な探索が多いかも
        - 最適化、最適なやつ以外も遷移
        - 数え上げ、将来的に条件を満たさないかもしれない / 遷移の度に、条件を満たすか判定
- 何を考える: 探索対象やその周辺、問題に関わる要素が満たす、探索に便利な構造/遷移の構造
    - **特定の対象に関する構造に固執せず、問題の解決に役立ちそう或いは単に綺麗そうな構造を満遍なく考察する。**
    - 1.いつも強い構造（独立性とか） 2.ある要素について、構造が沢山ある は強い
- なぜ構造なんて曖昧な言葉を使っているか
    - 何が役にたつのかなんて分からないから
    - 役に立ちそうな事実・定理・諸々まとめて構造と呼んでおく
- "構造"について、求めたいものとの距離が遠い形で得られた場合、近づけたい
    - 操作列 -> 結果 において、操作列に対して言えることがあるなら、それを結果に反映できないか・似た結論が結果にないか


## 必要条件・十分条件を積み重ねることによる整理
> 命題: 必要条件・十分条件が明らかになると、考えるべきケースが減る
- 必要条件がわかった -> それを満たすものだけ
- 十分条件がわかった -> それを満たさないものだけ


> 命題: 必要条件を積み重ねて予想した条件が十分でなかった場合、さらに必要な必要条件を積み重ねることで十分条件へと修正できる
- 投げ捨てなくて良い。足りない必要条件を考える



## 最終的な結果から逆算する、問題の構造
> 命題(必要条件): 操作をして 条件P を達成することを考える。この時、条件P が成立する必要条件が、操作の結果についての必要条件となり、操作の仕方の必要条件になる

> 系: どうやってもその必要条件を達成できないような初期状態 $\Rightarrow$ 達成不可

> 系: その必要条件が単調(一度trueになったらtrue/falseになったらfalse) $\Rightarrow$ その条件については、任意の操作の後に条件を違反しないことが必要十分


- 最終的な結果から逆算することで今の必要条件を増やし、状況を狭められる。あるいは、初期条件からの判定にこの考察を用いることができる。
- 途中仮定の操作を含まない議論で、簡単


> 命題(最適化の貪欲): 操作をして条件を達成する時のmincostを考える。ここで、  
最終的な結果を任意に固定した時に貪欲が存在する $\Rightarrow$ 常にその貪欲に従う解のみ探索すれば良い

> 系: 特に、その貪欲にそう操作しかしないとしてよい
- 今の操作しか見ないと最終的に無駄であることがわからず、省いて良い操作もしてしまう
- 最終的な結果(例えば操作する・しない列)を定めた時の貪欲が、任意の操作に対する貪欲を生む

> 命題(シュミレーションの判定の言い換え): シュミレーションをする過程で何かしらの判定問題を解く際、「その判定がtrueである時、シュミレーションが終わった際につく条件」はその判定の必要条件になる。特に、十分になる場合もある。
- 最終的な状態から条件を言い換えられる

## 求められるものを直接求める(上界・下界)
> 命題: 答えるものが f(x) であって条件を満たすものである時、xを求めなければならないとは限らない
- 特に、上界等を用いた議論が通用する時、答えを出すよりもその答えを実現する x を求める方が難しい場合が多い


## 成立しない時の議論 $\to$ 成立する時の議論
- > 命題: 多くの条件が、「その条件が満たされていない時」の構造よりも、「その条件が満たされている」時の構造の方が強力なものを持つ

- 成立していない時の議論を成立している時の議論にすり替えると考察が楽になることが多い
    - より強力な方を選択するということ(ただ、多くは成立している時が強力)



- > 命題: 満たしていない -> 満たす の条件に比べ、 満たしている -> 満たさなくなる の条件が非常に簡潔に書ける場合がある(非対称)
    - これは今Aを満たしているという仮定により構造が生まれ、それによって議論が簡潔になるから

- > 命題: 条件Aを満たす必要条件を考える時、 満たす => OO という命題より必要条件が得られる
    - そもそも満たしている時の考察より(i.e.最終的な結果からの逆算)


- >命題(区間の単調性): $L \le R \le R'$ に対し、 $(f([L, R]) = false \Rightarrow f([L, R']) = false) ⇔ (f([L, R']) = true \Rightarrow f([L, R]) = true)$
    - 後者の方が言いやすいことが多い

## 否定の・成立しない時の条件から導く構造
> 命題: (A $\Rightarrow$ 条件 P が成立しない) ⇔ (条件 P が成立する $\Rightarrow$ $\lnot$ A)
- 成立する必要条件を考える時、成立しない時の構造・必要条件から成立する時のものを導ける。


> 命題: (条件 P が成立しない $\Rightarrow$ A) ⇔  ($\lnot$ A $\Rightarrow$ 条件 P が成立する )
- 成立しない時の必要条件を導くことで、成立の十分条件を導ける
    - そのケースをもう考えない
    

- 他、対偶を考えると良いことがあるもの:
 
## 途中段階の集合の構造を考える
操作によってOOを作る時、そのOOの最適化/OOの数え上げなど
- 操作 -> 対象 -> 対象の最適化と、距離が遠くて考えづらいので、一旦途中段階までを整理すると良い


> 命題: 途中結果の集合・自由度がわかったら、もうそこに至る過程・構成要素は考えなくて良い。結果だけを用いて議論して良い


## 求める情報と使い道
> 命題: 計算(判定)に用いるための情報は、計算(判定)をするのに必要なだけで良い
- 自明な判定として「最大値を求めれば判定できる」があるが、判定の中身を考えると単に「ooが入っているかどうかで判定できる」等、判定の構造を考えることでより単純な・処理の軽い情報で済む場合がある

## 操作と目的関数の関係
> 命題: 答え(目的関数) の値が変化しない限り、操作を言い換えて良い
- 目的関数と共に考えて初めてわかる操作の言い換えが存在することがある



## 手続きによって得られる物の構造考察
- 手続きによる特徴づけより、より簡素に条件を満たすものとしての特徴づけの方が使いやすい・役に立つ。
    - 後の考察だったり、最適性の証明だったり、一般に。

- 一旦手続きによる特徴づけが手に入ったら、全く別の問題として、「その手続きによって得られる集合はどのような特徴を持つか？」を考える。
    - 特に、ストレートに特徴を求めようとしないで、その手続きを考察の足がかりとすると良い。遥かに考えやすい筈。
    
- 条件を満たす限り何かをするというシュミレーションは、結果として「条件を満たさない」物が残る
    - 条件満たさない場合をうまく処理できればこれも解になる
    - 命題: 条件を満たさない時、その条件の成立のみが反例となる様な命題が成立する

- シュミレーションによって得られた解が正しいことの証明
    - 最初のstepをして良いこと、そしてその後再帰的に解いていることが多い



## 自由度がない要素
- > 命題:自由度が一意に定まる要素は、今その影響を計算すればもう無視できる
    - 一意に定めるのは貪欲など
    - そういうのがあるなら、何かしら極端な要素がこれを満たすことが多い

## 1回も操作しない要素
> 命題: 1回も操作されない要素 $\Rightarrow$ 終了状態が一意で、それは初期状態
- 結果が一意な要素についての構造は考察が捗る

### 要素の順番
- > 命題: 要素の並び順が一意に決定できれば、その順に見て要素の使用・不使用を決定するdpができる
    - 他、dpに限らずとも前から使用・不使用を考察して貪欲ができる場合もある
    - つまり、順番が一意というのは良い構造
- 条件が明らかならばそれでも良いが、次の手続きでも条件を得られる:
- > 命題: 要素の集合を任意に固定し、順番も固定する。その上で隣り合う2要素を見た時、「その2要素をswapして良い条件」が要素に関する全順序になれば、その順でsortして良い
    - 例: 文字列を結合して辞書順minにする。隣り合う文字列をswapする事を考えると、swapして良い条件が要素ごとに定義される値の大小になる
- この命題を考えると、割と非自明な順番も得られる。よって、順番を固定したい時はこれを考えると良い。

### 重複がない
- 01になってオーダーが落ちる
    - 単調増加列の個数 >> 狭義単調増加列の個数


### dp解が最善とは限らない
- dpは全探索なので、dp解が一番良い解法とは限らない
    - より便利な答えが出る場合がある

## 言い換えた先での構造
個数が重要 -> 分布列・蓮橋圧縮列  

単調増加 -> 差分列
...



<br><br>


# 区間・連続
何かしら区間になっている時、それを上手く利用できると非自明かつ大幅な高速化・考察の変化が起きがち

## 区間演算
- > 命題: 長さkの区間にaddする時、mod k = 0の要素の総和 の変化 = modk = 1の要素の総和の変化... modk = k - 1の要素の総和の変化
    - これを元に必要条件が構成できる場合が多い
    - > 系: kが定数ならば、mod k事にみた要素の総和の差分は操作を通して不変（不変量）

- > 命題: 区間演算は、列に対し差分を取るなどする事で、変換した列上の2点への操作と同一視できる
    - 数え上げが容易になる場合
    - 応用：操作が存在する2点をグラフ上でも辺を張り、パスと操作列で対応が取れれば、後はパスを探す問題になる

## 区間同士の演算
- > 命題: 区間の共通部分は区間
- > 命題: 区間の和は区間とは限らない。特に、共通部分を持つならば区間
    - このように、区間同士の演算は区間になりやすい
    - > 命題: 区間同士の演算 $1$ 回が常に区間になるならば、演算を何回やっても区間

- そして、実際に区間になる場合、結局ずっと区間になっていて、考察が簡単になる・再帰的に処理できる可能性が高い。


## 集合としての区間
- >命題: [l, r] を、 集合 l, l + 1, ... , rを表すものとして見れる
    - >系: 集合のマージがO(1)でできる
        - 高速
    - >系: 集合の保持が整数2つでできる
        - これを持って探索する・場合分けする等の計算量が（元と比べて）drasticに落ちる
- よって、「全てを管理する」と言う愚直が、その全てが区間であるならば高速化される

- >命題: 最適化の問題において、最適な遷移がわからずともあり得る遷移を全て列挙できれば解ける
    - >系: 区間ならばそれができる可能性が高い
- > 命題: 数え上げにおいて、区間にしてまとめて遷移できる
    - dpでアリエル結果の集合を管理 -> 集合を区間を管理
    - (作れる要素の)種類数の数え上げ -> 集合を区間を管理して最後に長さを計算
       

## 寄与が存在する時間が区間
> 命題: 寄与が存在する時間が区間ならば、寄与をデータ構造に追加する・削除する回数はそれぞれ1回のみ
- 例: $\sum$ のmax を求めるという時、要素ごとに $\sum$ に貢献する時間を求めて、その時間だけデータ構造にaddする平面操作

## 区間をサポートするデータ構造
- セグ木
    - 区間演算
- 遅延セグ木
    - 区間変更
    
区間を管理するset、区間に辺を張るテク


## 区間同士の位置関係
> 命題: 区間を $2$ つとった時、位置関係について以下の3つのうちちょうど1つが成立する
> 1. 一方が一方を内包する
> 2. lが小さい方をi,大きい方をjとして $l_i < l_j < r_i < r_j$
>     - i.e. _________
>     -         _______
>     - のような位置関係
> 3. 共通部分がない

- 単純。以下、それぞれを関係1 ~ 3と呼ぶ

> 命題: 関係1であるペアが存在しないならば、関係2, 3で尽くされる
- Lでsortした図を書けば、想像上の一般よりもかなり簡単であることがわかる


## uniqueという意味での区間
> 命題: 数列の各項に色を塗ることを考える。このときとき次が成立する。  
> 任意の色に対し、その色が塗られる要素が区間を成す \Rightarrow 色iが塗られる要素の候補は $O(N^2)$ 個
- 他、単に"飛ぶ"ことがないので簡単

<br> 


<br><br>

# 単調性

## 二分探索
> 命題: 単調性があるならば二分探索できる

> 命題: 二分探索の計算量は、判定関数の計算量を $f$ として $O(f\log |値域のmax - 値域のmin|)$

> 命題: 二分探索の結果の候補がわかってる時、候補の数を $n$ として、事前に候補をsortする事で $O(f \log n + n個の候補の \text{sort} の計算量)$ である   

> 命題: $look[i] := 候補のうち、下から i 番目の値$ のアクセスを $O(k)$ でできれば $O((f + k) \log n)$ である。
- 値域が大きい時にオーダーが落ちる

## 要素の順番
> 命題: 要素の順番を好きに並び替えて良い時、適当にsortすることでkeyについて単調性が生まれる
- 例: マンハッタン距離 $|x_i - x_j| + |y_i - y_j|$ は、 $x_i \ge x_j$ ならば $x_i - x_j + |y_i - y_j|$ である。これを用いると、 $x$ 座標でsortすることで、マンハッタン距離最小のペアが $O(n \log n)$ で求まる

- 単調性は強い構造なので、このように問題が簡単になる・貪欲が正当になる場合が多い
> 経験則: 要素や操作・条件をsortして良い範囲で、先ずsortしてから考える
- 損が無い
- sortした後、何かの順で見ることでその単調性から貪欲やdp・高速化を考える
> 経験則: 要素の順番を並び替えて良い時、その並び順は1つに固執せずいくつか試すと問題が解けやすい。
- どの並び順が問題を解くにあたって一番良い単調性を生むかわからない
    - 例: 区間のl_sort, r_sort

> 命題: 1列に並んでいる要素が動く状況と考える。この時、  
> 要素が交差しない(i.e.1方がもう1方を飛び越えることがない) $\Rightarrow$ 要素の順番は最初のまま固定

> 命題(部分列を選択するdp): 数列の要素に値を割り振る問題を考える。このとき、要素の割り振りが「数列 A = a1, a2, ..., amに対し、 (a1が0個以上) (a2が0個以上)... (amが0個以上)」で表される形に制限されるならば、次のdpを考えられる。
> $$dp[i][j] := [0, i) に値を割り振った。最後に割り振った値がa_jである(ただし、長さ0であっても割り振ったとする)。$$
> 遷移として、a_jが1.空として割り振られた 2.1つ以上割り振られた　場合でつくされ、それぞれdp[i][j-1], dp[i-1][j] で表される。特にこの定義においては、計算量が $O(nm)$ であることが期待される。
- 一般的な「次の項としてあり得るものを m 通り試すdp」から遷移が1つ減っていることに注意。

> 命題: 一度OOの順で見る時と決めうち「OOの順でiまで追加した時」の構造のみを考察すると、そもそも「問題全体として要素xが満たす命題」を考えることがない

- 「OOの順で見て今xxなものは」という仮定がつくため、そもそも「全体でxxなものは」が満たす性質をみない(最後まで追加した時は一致するため、それを特別視しても良い)
> 系: 要素の順番を決め打った時、そもそも決めうちを無くした時に問題が満たす命題を考えると解けやすい  

> 系: dpを考えて解けない時、一旦dpから離れて問題が満たす命題を考えると解けやすい
- dpも順番を固定する考察

- 例: そもそも不要な要素を削除 -> 貪欲により決定


>
## 単調性と求値
> 命題: 状況を変えながら逐次求値をせよという設定でその値が単調に増加/減少する時、値の+1/-1判定ができるならば、O(変化量 * 判定の計算量) で値を求められる

> 命題: 単調でなくても、単調性に逆らう値の量が抑えられれば、同様に差分更新的に O(変化量 * 判定の計算量)で求められる
- 特に、毎回独立に求めることは必要ではなく、+1/-1判定ができれば差分更新的に求められる点が重要
- 例: データ構造に変更を加えていく、なんらかの条件を満たす初めての要素の順番 
    - 条件について改善するような変更をしたならば、その要素の順番は前に来るなど
    - 最善の変更をしてさえ改善しないならば即座に打ち切って良い

> 命題(単調性と平面操作): 「その時の最大値に注目するアルゴリズム」は、その最大値が単調に変化していくならば平面操作のように処理できる
- 制約を満たす要素について演算したい時、一度制約を満たすようになったらずっと満たすようになり、よって単にaddをしていくアルゴリズムによってクエリを飛ばす際値の制約を考慮しなくて良くなる
    
### $f(i, j) = f(j, i)$
> 命題 : $\oplus_{i < j}f(i, j)$ について、$f(i, j) = f(j, i)$ かつ $\oplus$ が可換ならば、 $1, 2, \dots , n$ の順列 $P_1, P_2, \dots, P_n$ について 
>$$\oplus_{i < j}f(i, j)  = \oplus_{i < j}f(P_i, P_j) $$ 

- つまり、要素を好きに並び替えて良い
    - ok: $\max, \min, \gcd$
    - ng : $f(i, j) = i - j$

## 単調関数と逆関数
> 命題: $f$ が単調増加である時、 $f^{-1}([l, r))$ は区間
- 二分探索によってその区間を求められる。 [x s.t. f(x) >= lとなる初めてのx,   x' s.t. f(x') >= r となる初めてのx')
<br><br>

# 凸
> 命題: 凸関数の和は凸関数

- 凸関数の集合のminやmaxは凸とは限らない。
## 三分探索
- >命題: 底以外で狭義単調増加・減少な関数 => 3分探索によって最大値・最小値を求められる
    - 系: a0 < a1 < ...  < an かつ b0 > b1 > ... > bn な関数について、 $\max_{i + j = k} a_i + b_j$ が $\log$ のオーダーで求まる

## 構造
- 凸であるという条件は強く、これが構造をもたらすことがある
- >命題: 何処で底を取るのか三分探索せずともわかれば、解の形を制限できたり、値を直接求めにいける。かつ、凸という制約によりそれは求めやすくなっている。
    - 単調性がある時、わざわざ二分探索しなくて良いことがあるのと一緒

<br><br>

# DON'T GET STUCK ON ONE APPROACH
- 一般に、強力な構造を元に建てた解法は速めだが、しかしいつも求められているオーダーに届くとは限らない
    - 例えば独立性は一般にはとても強力だが、今見ている問題に限っては別の構造を主眼に置いたような解法の方が強いかも知れない

- よって、例えいつもは上手くいく構造が見つかったとして、それで解法が立たないなら別の構造を探す必要がある
- 1つの線に深い考察というより、たくさんの線を考えて綺麗なものを見つける

- いつ考える: ある(強力に見える）構造に注目しても解法が立たない時
- 何を考える: 別の構造を探す・注目する


<br><br>


# 考える要素の中でも、極端なものに注目して考察する
> 命題: 全ての要素が条件を満たす => 極端な要素も条件を満たす  

> 経験則: 何か決定していく時や、構造について調べるときはまず極端な要素に注目すると、極端な要素がuniqueにそれらを持っていることが多い

- かつ、極端な要素は、その要素がユニークに満たす条件から追加で特別な構造を持っていることが多い。よって、どうせなら常に極端な要素を見れば良い。  
    - 上手くいく良くあるパターン
        - 他の自由度と比べ一意性が強くて
            - いま決定できる -> その決定によって問題が変化する
            - 考えやすくてなんか良い事がある
        - 全体の形に影響するため、それを固定すると問題全体の一意性が上がる
- > 命題:わからない事を全て解き明かさなくても問題は解ける可能性が高い**
            - 議論に曖昧な事を挟むのはよくないが、それに取り憑かれないこと。

- また、**極端な要素に注目する時は、必ず”全ての方向に対して"、極端なものをそれぞれ見ること**
    - min・maxの要素、最初・最後の要素
    - 1方向きで少し上手くいっても、それでは不十分なことがある

> 命題: 下界・上界になる $\Rightarrow$ 極端な要素である
- 上界や下界は極端な要素から生まれる

> 命題: 1つ決定して良いことがあり、かつその決定を再帰的に行えるならそれを繰り返すと解が得られる
- 例: 最小全域木や貪欲法、マッチング
- 往々にして、max/minのものを決定する(他ができるならこれも決定できる



<br><br>


# 重要な情報だけに注目し、他をlostさせる・無視するよう言い換える・言い換える・特徴量を見る
- 問題を解く上で、状態の変化をそのまま受け取る必要はなく、欲しい情報・条件・制約に係る情報だけを注目すれば良い。
- そのため、それらに関わらない情報は捨ててしまってよい.
    - 何をすれば良い:必要な情報とは上記のもの。あるいは、無視しても・言い換えても答えが変化しないもの.
    - 嬉しい: 問題が言い換えのごとに簡潔になる
  

## 寄与が一意のもの・寄与しないもの
- その寄与を処理することで、要素を1つ減らした問題に帰着できがち。

> 命題: 要素の順番を決定する問題で、先頭に来ない => キヨしない が成立する要素が存在する時、その要素から順番を決定することでその要素は「先頭に来る(i.e.今処理できる) or 寄与しない」になり、場合分けすると寄与が一意の要素として扱える
<br><br>

# 特徴量
> 定義: 問題から定義できる何かの値  

典系的に、ある程度うまい特徴量は必要条件や答えの上界を与え、議論の役にたつ。またその特徴量がcriticalであった場合、「その上界は常に達成できる・その必要条件は十分である」という形でそのまま答えを与える。これは特にその結果に辿り着くまでのアルゴリズムが複雑・発想が困難である場合に強力になる。

> 命題 (単調な時の特徴量による上界):特徴量 $d$ が減るのみで増えることがないとし、 $d = 0$ にするまでの操作の回数の最小化を目的とする場合を考える。この時、 $d$ の減り方について $-a$ と $-b$ の $2$ 種しかない $\Rightarrow - \max(a, b)$ の減らし方の回数を最大化するのが最適
- 正当性が保証されている。たとえば、 「今 $-\max(a, b)$ できるならする」という貪欲は正当性が保証されると限らない。 


## 偶奇
何かの偶奇は汎用性が高くて使いやすい。

> 命題(01flip): 0と1の集合があり、1の個数 C_1を特徴量とする。操作として集合から $k$ 要素選んで flipする時、$k$ が偶数 $\Rightarrow$ $C_1 \mod 2$ は不変


> 命題(グリッドの偶奇): グリッドの各マス(i, j) を i + j mod 2  で分類すると一松模様になる


<br><br>

# 不変量
> 定義: 特徴量の中でも、「操作によって変化しない」という構造を持つもの
- これを用いると、条件達成の必要条件として「S -> Tに与えられた操作で変化させられる => 不変量一致」が言える
    - 必要条件の補強
    - 不変量によっては十分性も自明
- > 命題: グリッド上で上下隣接移動する時、 (i, j) に対して i + j mod 2 は必ず 1 ずつ変化する
- > 命題: グリッド上で斜め移動する時、 (i, j) に対して i mod 2, j mod 2 はそれぞれ 1 ずつ変化する
- > 命題: 数列への区間演算を考える。この時、区間長が常に $k$ の倍数 $\Rightarrow$ $k$ 飛ばしの値の集約結果(i.e. 添字 mod kごとの集約結果) の変化は、$\mod k$ に依らず等しい。



> 命題: 問題文中のパラメータ $p_i$ について、
> $$f(p_1, p_2, ... p_n) = \text{const}$$
> であるような関数が存在する場合、これが関係式となって文字数の自由度が1つ減る
- 与えられたパラメータを組み合わせて不変量を作れるのなら、それには応用がある
<br><br>

# 先に処理して良いもの（一意なもの・決定したもの）を処理・無視する/解けるケースを先に解いて、状況を再定義する

- 一意に確定した物
    - 確実に発生する物
- 必ずOOになるもの
- 自分で固定したことによって上記のいずれかになった物
- 解けるケースを除いても、その旨みがわからない時もある
    - そういう時もわざわざその制約を捨てずに残した方が良い
    - 黒魔術的なdpに走ってはいけない

- また、何か「もう処理した」部分が発生したら、その部分を全く考えなくてなるように(情報を)整理することも大切
    - 余計なものがあると、貪欲や再帰的な状況に気付きづらい
    - また単に、情報のロストによりdpの計算量改善


## 最初から存在しなかったとして考えても良い/一旦忘れても良い
- もう自由度を決定して、その影響も処理した
- 他の要素によって、代用されうるもの
    - 考察では「でも迂回されるかも...」といったわずらわしい婆位訳として登場するが、実はそういうのは「毎回replace先を使えばよい」となったりする
  
- 明かに損なもの 
    
    
- ものすごく自由に動かせる物
    - あとから都合が良いように決めればよく、一旦考慮から外して良い
        - 決定を保留する解法？
- 今決めなくても良いもの
    - どれかから選ぶ <- 後でどれから選んだが決めれば良い
    - 必要な事: 保留しても次の状況が変化しない(選択肢によって分岐しない)・保留してるものは、全ての選択肢にとって等価でないといけない
    - **特に、今一意に決めて良いものは、保留せずに決定して処理をするべき**





<br><br>


# nが小さいケースに帰着
> 定理: $f(n) := 問題の答え$ について、 $f(n)$ が $f(n-1)$ で表せれば、 $f(0)$ から求めることで $f(n)$ が求まる
- パラメータ(i.e.問題のサイズ) $n$ が小さくなっていればよく、問題の中身は変化しても(i.e. subsetになっていなくても)良い
- 関数の中では、小さいサイズに帰着することだけ考えれば良い
    - dpと似ているが、こちらは帰着さえできれば良い。
- fの個数 * 1回の帰着の計算量が抑えられれば解ける

- > 命題(一意な帰着): 決定できる自由度が1常に1つ以上あるならば、その自由度の決定を繰り返すことで問題が解ける
    - よって、今決定して良い極端な要素があれば解ける
        - 例：マッチング
    - 常には存在しない場合 -> 適応条件を明記して、それが守られているか確認する


- sortして良い時にsortして大きい・小さい順に見るという方針と相性が良い
- 「次々決定していく」という形のアルゴリズムが正しい答えを返すなら、背景に上の命題があることが多い
    - 例: 最小全域木...コストminの辺を含んで良い -> 縮約するとサイズn-1
        - 応用: 連結成分をk個にするという時もコストminの辺を含んでよく、同じアルゴリズムが使える

- > 命題(一意とは限らない帰着) : 自由度が他より絞れる要素が存在して、その要素の周りを変形することでサイズが小さい問題に帰着できれば解ける
    - 一意に決定できなくても問題のサイズを小さくできるなら良い

- > 経験則(再帰と探索空間): 再帰関数による探索は、初めから形を決め打つものよりも表現力が高い
    - ifで分岐することでいくらでも複雑にできる
    - この意味で、再帰的な解法は(それが唯一の解法となり得るほど)強力な解法
    - ルールベースで困った時は、一度全ての仮定を捨て去って、f(S) := 答えが S の物を構築する関数 として、fを表せないか考える

- n -= 1
    - 端や外周、n番目を埋めるパターン
        - 何かしらについて決められるパターン
        - 問題によっては、綺麗にn-1に帰着するために、決定するものが固定な場合がある
    - 必要なこと： ある要素について、n-1に帰着できるような形で今決定できること。あるいは、解けてる・ベースケースに行けること
        - ベースケースは全探索など。また、なんでそのベースケースで成立するのかの考察は無駄なこともある（帰着できればそれで良い）
        - n-1に帰着する際に消す要素は特徴的な要素 かつ いつでもあるやつ が好ましい


- n -= (小さい時に可能な構築)
    - 構築を組み合わせてサイズが大きい構築が作れる時

- 問題の分割
    - 数列をどっかで区切って独立に解く、など


## 問題の制限上の注意
> 命題: 状況を制限した上で「この状況の時に解く関数」と定義すると、小さい問題に帰着する際に帰着の仕方にその制限がつく

> 系: 解くケースを広くすると、考慮するケースは増え、帰着は簡単になる
- 多くの場合で、解く場合を制限するのは問題を簡単にする。しかし、帰着して解く上ではその制限のせいでうまく帰着できず、却って「一般の状況で解く」関数の方がより簡単に書ける場合がある。
## 帰着させる時、何を決定するか
- 条件を導いて、それを満たすものを決定しても良いことを示す
- なんらかの評価値を作って、それが一番良い（小さい・大きい）ものを決定しても良いことを示す
    - 貪欲。いつでもmin/maxは存在する

## nが小さい時の答えを利用して構築
- 割とある
- 基本要素みたいにして組み合わせる



<br><br>

# 解けるケースに帰着
問題のパラメータが特殊な時に解ける時、残りのケースをそのパラメーターに帰着させられれば解ける。$n$ を小さくする、をより広くした感じ。  

例えば: パラメータ $d$ = 1 なら解ける時、残りの問題も $d = 1$ になるよう変形する

<br><br>

# 最適戦略
- 期待値問題やゲームでは往々にして「最適化な行動をした時」の何かを聞かれる
    - 最適化な行動が気になる
- 「パラメータがnの状況において最適な行動をした時の結果」がわかってる前提の元では、それらの値を用いることで「パラメータがn+1の状況における最適な行動」が記述できる場合が多い
    - つまりdpになる
<br><br>

# 全単射/1対1対応するもの
- 命題: ある集合のサイズを考える時、その対象と全単射が存在する別の集合が存在するのなら、別の集合のサイズと一致する
- 命題: 性質を保つ全単射が存在する場合、元の問題を別集合上で言い換えて良い
    - 集合のサイズ -> 数え上げ
    - 性質...コストとか。最適化

## 数え上げにおいて
- よくあるのは 操作 : 結果
- 必要なこと:
    - 条件を満たす要素全体の個数さえわかれば良いという状況である事
    - 1対1対応するものがあり、それなら数え上げられること
        - 片方にだけ良い構造があるのかと思うかも知れないが、そういうこともある
        - 特に、1:1対応に移すという事は集合のvalidな要素の個数だけが重要で、よってvalidな要素の個数がわかりやすいような対応先は良い（特に、集合内の要素が全てvalidな時、もう集合のサイズさえわかれば良い）
        - 特に、数え上げる対象そのものに直接良い構造が無くても良いことに注目
- いつ考える:
    - 1:1対応が取れた かつ　困っているならば、対応の方に眼を向ける
    - 特に 操作 : 結果


- 命題: 単調列の個数は、単調とは限らない列に比べオーダーレベルで少ない
    - 単調列は集合と列に全単射があるので、個数が集合の個数になる（順序の自由度がなくなる）
    - 例: distinct かつ $0 \le a_i < n$ である数列 $\{a_i\}$ の個数は $2^x$ であり、冪乗のオーダー

## 最適化において
- 例えば: グラフで言い換えた時
    1. 操作列が存在 => 対応するパスが存在して、パス長がコスト
    2. パスが存在 => 対応する操作列が存在して、操作列のコストがパス長
- という時、コスト最適な操作列を考える上でもうパスの最短経路を考えても良い


## シミュレーションの言い換え
> 命題: シミュレーションによって定義された値についても、同じ値を返す別の条件があれば、その条件を満たすものを求めるとして良い
- 単にシミュレーションをそのまま高速化するよりも柔軟に高速化できる

<br><br>


# 逆関数・逆操作
> 定義: 関数 $f: A \to B$ に対し、$f^{-1}(B'\subset B)$ を返すような $f^{-1}$ を逆関数と呼ぶ。

> 命題: この定義は次の口語的な定義と一致する。「操作の結果を与えた時、その結果になりうる状態をの集合を返すような操作」

注意: $f^{-1}(b \in B)$ は集合の時がある
    - もちろん、集合でない(i.e. ただ1つ)の方が扱いやすい

> 命題: 元の操作に事後条件がある時、逆操作には事前条件がつく
- >命題(modの逆操作): mod mを取る -> 任意の回数 mを足し引きする。ただし、操作の直前の値は[0, m) に収まっている必要がある。
    - 1回しかmodを取らない　かつ　事前条件の成立が自明なら良いが、そうでない場合考慮する必要がある


> 命題(数え上げの定式化): $f(x) = y$ を満たす $x$ の数え上げ = $|f^{-1}(y)|$ の求値

## $f^{-1}(y)$ の求め方
> 命題: $f^{-1}(y)$ を $f^{-1}(y')$ の式で表せて、引数がDAGになっている場合順に求めていけば集合が求まる

> 系: $f(x)$ を段階に分解する(i.e.関数の合成で表す)ことができた時、それぞれの関数について $f^{-1}({y})$ を求めることを1段階としたdpができる
- 数え上げで言えば、まず $f(x)$ を段階に分解して、段階ごとに逆関数を求めることで $f^{-1}(y)$ を求める
    - 条件が（逆関数を求められる)関数の合成で書かれているような場合に有向

### 操作列を実行して終了状態になる初期状態
> 命題: 「操作列を適応したのちに、状態pになるものは最初何か」という状況を考える。この時、操作に対して逆操作を定義できれば次が成立する   
> 状態pになる初期状態 = pから逆操作をした結果
- ただ操作をするだけで求まる
> 命題: $A \to B$ にできるか ⇔ $A \in (B を f^{-1} に通した集合)$
- 逆操作を独立に見る必要は必ずしも無く、最終的な集合に含まれているかを考えれば良い



### 操作をk回して終了状態になる初期状態
> 命題: 「初期状態が終了状態になるまで操作をする」という状況を考える。この時、操作に対して逆操作を定義できれば次が成立する   
> 状態S から始めると、k回の操作で終了状態になる ⇔　終了状態から逆操作をk回することで S になれる
- k回操作できる物を作れ => 単にk回逆操作をした物を出力
    - 逆操作の際、往々にして事後条件・事前条件がつくことに注意

- 上の例の、「最初: 構築対象なのであやふや  最後: 終了状態が定まっている」とした適応例


### 同じ方向の操作は連続しないとして良い
- 2方向なら、初手を決めた時点で方向は一意
    - これだけより



<br><br>

# 数え上げ
- 数え上げは全探索なので、多くの手法が他の分野の問題に使える



## 条件を満たすものの数え上げをdpに落とす一般的なテク
たくさんの固定を多項式時間に落とす一般テクと同じ。
> 命題: 条件を満たすものの数え上げは、一般に次の枠組みで解法を作れる
> 1. 探索対象を1つ固定して、それについて「これは条件をみたすか」の判定を作る
> 2. 判定を段階的にすることで、固定も段階的にする
> 3. 各段階において、判定に用いる情報が一致するものを纏めるdpで数え上げる。遷移では各段階ごとに探索対象を固定する。

> 系: 探索対象に重みがついている場合も、「この探索対象の重みは何か」の判定を元に同様の計算ができる

- 効率的な数え上げが浮かばない時も、上の手続きにおいてうまく段階に分けられればそれば効率的な数え上げ方になる


## 否定
- 肯定ではふわっとしているもの <-> 否定なら固待っている・より構造を課すかも
- たくさんのバリエーション <-> 否定なら少ないバリエーションかも
> 命題 $\lnot$満たさない = 満たす  

> 系: $\lnot$ 2以上 = $1$ 以下

> 系: $\lnot$ 部分木内にない -> 部分木内にある

- 「ooでない」という条件が出てきたら解法ローテの択としてとりあえず入れる

- 操作列 -> 結果 で、作れない結果を探索する時、
    - 作れる :$\exists$操作列
    - 作れない:$\forall$操作列
- となって、考察の方向性が変化することに注意(判定の貪欲が変わったりする)

> 否定(余事象): である <-> でない (他にも変化する時はある) 

> 包除: 1つ以上 <-> 全て
- 全てにすることで独立になる

 


## 包除
> 命題: $L0 \le l < L1, \ R0 \le r < R1$ についての探索は  
> $f(L, R) := 0 \le l < L, 0 \le r < R$ についての探索  
> を定義する事で、 $f(L1, R1) - f(L1, R0) - f(L0, R1) + f(L0, R0)$ と一致する。

> 命題(包除原理を多項式に落とす一般的なテク): 包除原理によって展開した後の計算は、「全ての01列に対する重み詰みの総和」と同一視できる。つまり、次のアルゴリズムが成立すれば $n$ に対する多項式時間に落とせる。
>1. 01列を固定したときのsumの計算をアルゴリズムにする
>2. 1のアルゴリズムを段階で分ける
>3. 分けた段階ごとに列の0/1を決定していく。このとき、後の計算に必要な情報が一致するものは同一視してまとめる



> 命題(包除原理を多項式に落とす一般的なテク2): 包除原理によって展開した後の計算が「1を指定した要素の個数」にのみ依存する場合、その個数でまとめて計算することで $O(n \times ?)$ になる

> 命題(包除原理を多項式に落とす一般的なテク3): 包除原理によって展開した後の計算は和の和である。つまり、キヨに分解できれば $O(n \times ? )$ になる
## よくわからない -> 何かを固定した時の数え上げを考える
なにかを固定 -> 一意になったことによる影響を考え、真っ先に処理
- 固定したものを動かしながら総和を取れれば解ける。
    - 固定した時について考えた時、数え上げる上で固定すべき情報」がより少なく済むとわかれば、固定を緩和することで動かしての数え上げが簡単になる。固定したものを動かせるなら解けるし、固定の緩和によって動かせるようになっても解ける。
- また、固定する事で状況が単純になって、構造・数え上げるものにつく強力な必要条件がわかりやすくなる事がある
    
- いつ考える: 数え上げでよくわからないなら割といつでも。

## 何かについて場合分け -> 問題のサイズの小さいのに帰着されていて、終わり
- 特に、その何かには極端なものを選ぶとうまくいきやすい。（集合の最小の要素とか、数列の左端とか）

- 必要なこと :場合分けすると、うまく問題のサイズが小さくなるような要素がある。高速化すれば間に合う
    - これさえ成立すれば、他がいくらわからない状況でも解ける
- いつ考える: 極端な要素がありそうな時。集合の数え上げ。他より際立って考えやすい要素がある時。

## 集合(非順序対象) の数え上げ
- 数列と異なり、「1項目 -> 2項目 -> ... 」と決定できない
- 1. 要素ごとに何個使うのかを決定していく
- 2. 集合について、max/minの要素が何かを決定していく
    - max/minの要素を決定 -> その要素の影響を計算して、もう無視
    - 一度に個数まで決定しなくて良い(遷移が1より細かい)


## iによらない遷移
- 高速化: 行列累乗など
- 考察: シミュレーションが行われると捉えずに、全体を俯瞰すると良さそう？


## 数学的な考察

### xの倍数である
- 1: kを自然数として、 xkで表して立式。ユークリッドの互助法など。
- 2: mod k で考え、 = 0とする(mod k以上の情報を捨てて、同一視。数え上げなど。)
    - Ai + Akがkの倍数 -> Ai + Ak = 0 ⇔ Ai = -Ak     
        - iとkで独立!
### パラメータをずらした・状況を一部変えただけ
- ずらす前・より簡単な状況で綺麗に表せる操作は、ずらした後・変えた後でもある程度綺麗に扱える場合が多い。かつ、それでも綺麗なので、その結果が使える事が多い。
    - 例: 線分上での対称移動    
        - 基準点をaとして x -> 2x - a
    - 例: 円環上での対称移動x
        - mod 円環の長さになるだけ
        
### 区別すべき物を区別せずに、後から係数を掛ける
- 嬉しい: dpにしやすい
    - dpは同じ状況を纏めるという側面があるので、状態の情報量が減ると当然高速化につながる
- 必要: そのような係数が求められる事
    - もとまるにするために、dpの設計をし直す場合すらある
    - 結構大変

- 疑惑: そのようにできる場合、そもそも人に対して制約が対称的であり、dpにおいて「具体的に残っているのは誰か」をロストさせられる

### 互いに素でない時
- gcd = gとする。
- 倍数関係について、割っても変化しない -> gで割って、互いにその場合に帰着

### 丁度 $k$ <-> $k$以上の言い換え
ちょうど $k$ より、 $k$ 以上の方が好ましいやつ。あるいはその逆。求めるものに逆元があるならば、片方をもう片方に変換できる。

- 全てのkについて列挙ならいつでも言い換えて良い
- ちょうど$k$ の方が状況が絞られているので、それが効く場合は求めやすい
- 「各素因数について、次数が $k_i$ 以上」である整数であって、 $n$ 以下の個数 (from : 各素因数について、次数が丁度  $k_i$)
    - ⇔何かの倍数
- 集合に $x$ が $k$ 個以上含まれる (from : $x$ に丁度 $k$ 個含まれる)
    - $x$ を $k$ 個とって来たとして、残りの集合についても以前 $x$　を含んで良い
    - これによって分割統治がうまく行ったり
        - そもそもの条件が「$x$ が含まれて良い」の時に、 $x$ が $k$ こ含まれる場合...で場合分けした時

- a or b $\subset$ $k$ (from : a or b = $k$ )
    - 条件が「a と b が共に $k$ の部分集合」になる
        - 演算に逆元があれば、左から右を復元できる
            - メビウス変換
-min(a, b) $\ge$ k (from : min == k, max == k)
    - 全てがk以下、とk-1以下を解いて引く
        - 逆元が必要
    - 「どれかについて丁度kが存在」が消え、それぞれの要素が独立に動けるようになる
    - 期待値問題とか
    - 判定問題にも使えそう
    - min(A1, A2...)の期待値の求め方:
        - minがx以上である確率を足し合わせていけば良い
        - すると、全ての値がx以上の確率を求めれば良いことになる

### $\sum_{i=0}^{n-1} ai \le S の時の組み合わせ$
- $n$ 項目を追加して、そいつにも重みを負わせることにすれば、「sumがちょうどS」に帰着できる場合が結構ある
    - 何かの固定を動かす場合、動かしてsumを取らずとも求められたり
    
### 数列に対するスコアのsum <-> 数列の個数の数え上げ
- 数列のスコア $\ge a$ となるような数列の個数が、a全体にわたって求められれば良い
    - 上のテクと合わせる場合
### ある値aiを含む集合のgcd
- 単調に上位集合になっていく時、そのgcdはせいぜい log ai 通り
    - aiの約数通りではない
    - 割り算するので、という理由
    - 単調に... -> 区間とか
## 約数包除
- 動機(いつ考える): gcd(a, b) = k は条件が独立じゃ無いせいで難しく、 gcd(a, b)がkの倍数は独立なので容易い。
    - lcm(a, b) = k -> a, b共にkの約数
    - （素因数の視点から見て）ちょうどx -> xの倍数
- ここで、この左右の値を結びつけるのが約数包除とか呼ばれるもの

### テーブル -> テーブル
- f(x)が与えられた時、 F(x) := $\sum_{xの約数であるようなy}f(y)$ とかを求める
- 簡単
- ライブラリにある

### （疎なテーブル) -> 変換後sum
例として、F(x) := $\sum_{xの約数であるようなy}f(y)$ を扱う
- F(1), F(2), F(3), F(6)が与えられ、他のF(x)は0だと言う時、$\sum f(x)$ を求めると言ったような
    - テーブルを変換する手法よりも計算量が落とせる(単に変換するよりはhard)
- $\sum f(x) = \sum A_iF(i)$となるような $A_i$ (つまり係数)を求め、それを用いて F(i) != 0の項を集計すれば良い
    - 係数の求め方1: 機械的に係数を求める
        - (1): 既知の配列{bn}と、求めたい配列{an}の関係を約数や倍数の言葉で書く
        - (2): 式変形して係数列を導く
        - (3): 求める
        - (4): n, mを丁寧に書く。入れ替わると全く変化する。
            - [そう言う問題](https://atcoder.jp/contests/arc185/tasks/arc185_e)
            - この手法では$\sum B_if(i) = \sum A_ig(i)$ のように、求めるものにも係数がかかっていても求められる
            - Bのうち特定の項だけ集計したいとかもok!
    - 係数の求め方2: 包除原理の考え
        - gcd(a, b) != 1 ⇔ a, bが共になんらかのpの倍数 ⇔ 素因数が1, 3, ... に+1, 2, 4... に-1, p^2に0(メビウス関数)
        - 素因数に関する包除原理は、一見（素数が多くて）計算量がやばいが、有効な値の範囲から見ると間に合っていることが自明な場合が多い
        - [係数を求めることで疎なテーブルについて変換後sumを高速化する](https://atcoder.jp/contests/abc230/tasks/abc230_g)

    
### 多項式復元
- 方程式
- なんか上手い方程式であって、値がそうなるもの
    - (x - ?)^? みたいなのを足し合わせる

### 数え上げ: 補集合/否定
否定や補集合を考えた方がわかりやすい場合は多い。
特に、OOでないという形の制約は考える対象が多い・漠然としていることが多く、保守業を考えた方が良い。
区間であって、交わりを持つようなペアは何個あるか？
→実は、交わらないという条件の方が数えやすい。


## 纏めて数える数え上げ
何か、パラメータを共有するものを纏めて数え上げられないか？
- 探索の軸を変えるという事
    - しかし、軸を変える理由の全てがこれというわけではない
        - 他: 持つ情報を減らすとか
- 高速化に悩む時、これを考える事によって軸の変更を考えるのは有意義
    - 計算量が「元々の母集団」から「まとめた後の種類数」になる
        - 種類数のオーダーの方が小さければ高速化


    
## 数え上げの主客転倒・寄与の分解
和の和の時に、シグマの順番を入れ替えること。あるいは、多重ループで処理をする際、ループの順番を入れ替えること。

- 全てのooについてxxの和

> 命題: シグマの・ループの順番を入れ替える事によって、一番内側のシグマがオーダーを落として求まれば、その落ちたぶん全体でもオーダーが落ちる


- 何をする: 分割した1つに注目した時、それを求めるに当たって独立な（関係がなくなる）・無視しても答えが変化しない情報を全部ロストさせる
    - キヨに分解すると独立性が生まれ、問題が急激に変化する場合が多い。この変化を忘れず整理する

> 命題: 操作回数 = $\sum_{操作が起こりうるイベント} 1_{操作をする}$
- これを用いて、 $\sum 操作回数$ を寄与に分解できる(i.e.  = $\sum_{操作が起こりうるイベント} \sum なんか$　にする)
> 命題: $\sum_{s} \sum_{i < j} |A(i, s) - B(i, s)| = \sum_{i < j} \sum_{s} |A(i, s) - B(j, s)|$
- 数列を変化させる時の abs sum の sumに対応。後ろの $\sum$ が高速に計算できれば良い。

> 命題: $|a - b| = \sum_{x\in [-\infty, \infty]} 1_{\min(a, b) \le x < \max(a, b)}$

>  $ = \sum_{x\in [-\infty, \infty]} |1_{x \le a} - 1_{x \le b}|$
- 後者のループは、値を $0$ か $1$ の 2値化して計算すれば良いと言っている
- 2値になると答えが同じものがたくさん出てきてまとめられる

> 命題(0項削減): $\sum_{k} \sum_{i} f(i, k)$ について、 $f(i, k) = 0$ の項がオーダーレベルで多い時、$ = \sum_{i} \sum_{k} f(i, k)$ とした上で(i.e. iを先に固定するようにして) $\sum_k f(i, k)$ が $f(i, k) = 0$ の項を調べる事なく求まれば、全体のオーダーが落ちる

##  寄与への分解をする、と宣言したら解けるというものでもない/分解の上手い定義
- 寄与への分解の仕方についても、「うまい分解」の仕方を考える必要がある

- まず、**分解した対象には文脈がない方が良い**
    - 文脈あり: 「OOという手順でシュミレーションした時、この要素までやったら...」
        - これだと、結局シュミレーションを実際にやりたくなって、状態量が爆発してダメになりやすい
    - ない: 全部をし終わった時、結果としてこの要素は?
        - これなら、「全てを動かす <-> 今の選択がなんであろうが、他の要素は全体を独立に動く」という、"全ての変化"を考える時の独立性を活かしすい。
        - および、「関係のない情報を全部ロストさせる」という目的から見ても、関係のある情報は少ない方が良い。

    - よって、シュミレーション中にこのイベントが起こる回数を求めたい、などは、そこまでのしゅみレーションの結果に依存するところがあって求めにくいだろう



- 寄与に分解したのちも、係数を求めなければならない
    - ここでさらに寄与に分解することもある

- いつ寄与が発生するのかがわかれば、寄与を数え上げるdpにする事ができる
    - 必要な事: いつ寄与が発生するかの情報　という事


- 寄与に分解して求める時、同じ寄与を複数回足さないよう確かめよう
    - 特に、極端な部分だけ場合分けして足す場合
    - maxとminだけ別に足す <- max = minの時バグ


### 寄与の分解を用いた条件の分離・言い換え
- 条件A, Bに対し、「A かつ notB なら寄与2, A かつ B なら寄与1」のような時
    - AとBが絡み合って、数学やdpに起こし辛い
- **条件ごとの寄与を求める**
    - 言い換え: 「Aが成立なら寄与2 かつ B が成立なら寄与 - 1」
        - 条件を分離できた

        - 実際には、条件の成立関係(B ならば A等)が上手くなってないといけないので、確認する
     

## 差分更新をする数え上げ
- K = 1, 2, ... , nについて問題を解けと言う時
    - Kの変化であって、変化量が小さいような変化順があれば、その変化順に従って求まる
        - 最も典型には K = 1, 2, 3, ...


- 基本的に、なんらかのテーブルや値を維持・更新していく
    - 途中で、テーブルのある部分の値が意味なくなったりする
    - **ここで、意味のなくなった値について考察してはいけない/必要な値が正しいかだけ考える**
        - 何を考察すれば良いのか？
    - 及び、テーブルの値について、途中で意味がなくなった（必要が無くなった)かと思いきや、その後再び正しい値が必要になる場合がある
        - その時は、必要になったタイミングで、正しい値が格納されているか考える
            - 途中を考えない
                - どうなっていれば良いのかわからないため


### 全てのprefixについて求めよ
- 差分更新の考えを使うことが多い
    - 数列がほとんど変化しない -> 新たにaddした要素による変化を考える
## 敢えて立式しない方が簡単な数え上げ
- 代表: 組み合わせ的な数え上げ
- 入りそうなもの: 組み合わせ的な物、数え上げる対象の条件が簡潔に表せる物(特に、生成手順ではなく、満たすべき条件が与えられる物)
    - 対応を用いることもある
    
    - 順列であって、i, jに対し、「(i <= k <= j), P[k] >= P[j]」
        - 言い換え: P[j]がP[i]....,P[j]の中でminである
        - 数え上げ: 全ての順列に対し、P[i]...,P[j]を抜き取ったものを考えると、P[j]がその中でminであるものが1つあって、つまりN!/(j-i)+1 みたいな感じ


- 2つの要素のペア
    - N!通り
    - 行列のdetと近い式をしていて、実際利用できる場合がある


### 具体: 連結成分の数え上げ
- そのまま考えて出来そうならいいが、dpしたいとなった場合、連結性をどうやって持つのかが問題になる
    - 難しい場合が多い

- 別のものの言い換えにしよう
    - case1: 列上のグラフ o-o-o  o-o o-o-o
        - 切れ目ごとに、連結成分数に寄与 + 1
            - 切れ目ごとのキヨを数える問題になる

    - case2: 木、森
        - 辺ごとに、連結性分数に寄与 - 1
            - 辺の本数を数える問題
<br><br>

# 期待値/確率

## 命題
- 遷移のグラフを(アバウトに）考える。それぞれの状態vについて何らかの期待値 $\mathbb{E}[v]$ が定まっているとする。この時、
 $$\mathbb{E}[v] = \sum_{vから出る辺(v, u)} \mathbb{P}[vからuに遷移する確率](\mathbb{E}[u] + 遷移のコスト)$$
 $$\mathbb{E}[v] = \sum_{vに入る辺(u, v)} \mathbb{P}[直前の頂点がu　|　現在vにいる] (\mathbb{E}[u] + 遷移のコスト)$$

- のどちらかが成立する。
- 一般に、 $\mathbb{P}[vからuに遷移する確率]$ は問題で与えられていることが多い。また $ \mathbb{P}[直前の頂点がu　|　現在vにいる] $ は与えられていないため自分で計算する必要がある。

- 直前の頂点が排反なので
$$\mathbb{P}[直前の頂点がu　|　現在vにいる]  = \frac{\sum \mathbb{P}[現在uにいる]\mathbb{P}[u \to vの遷移をする]}{\mathbb{P}[現在vにいる]}$$  
になる？
## 「今までの」ではなく「これからの」を持つdp
- **上の命題より、期待値を求める問題では多くの場合で「これからの」期待値を求めることが、「これまでの」を求めるよりも難しい**

    
- 期待値を求めるdpでは、1回の遷移で状態が変化しなくても良い場合が多い
    - 右辺と左辺に共に未知数が入ったとしても、式変形で消せる
    - よって、「1回の試行」をもとにdpの値を求めていくと楽で良い
    - [例題](https://atcoder.jp/contests/arc016/tasks/arc016_3)

## 初手の試行の結果で場合分けすると問題が小さくなって解ける
- 必要な事:　初手の試行で場合分けすると、問題が小さくなる事。および、全部計算できる程度に状態数が少ない事
- いつ考える: 線形性での分解とかよくわからない時・方針に困った時
    - 上の「これからの」に発想が近いと思う
    - [合計がX以上になる最小のiの期待値](https://atcoder.jp/contests/abc382/tasks/abc382_e)
        - これからの、で考えても解ける。状態は「これからX枚取る」
        - 初手で場合分けしても、問題のサイズが小さくなってる。上と全く同じ。

## 保留するような遷移を無視
- 保留するような遷移は試行回数には影響するが、最終的な勝敗やスコアには影響しないことが多い。そのため、一旦保留を無視して計算して最後に保留による試行回数の増加を足し合わせる解法が取れる。
- > 命題: 試行回数 = (保留の回数) + (validな試行の回数)

## 期待値の線形性・寄与の分解
$\sum$で表される(例:個数や回数)期待値について、それぞれの要素について、**独立に**期待値を求めた後和を取って良い。
- 使える必要条件
    - 分解したのちのそれぞれが求まる事
    - 分解したら計算するものが多くなるなら、全てについての和が高速に求まる事
- いつ考える: 期待値で、状態が多い時
    - ほぼ毎回考えて良いが、素直に定義に従って分解できる程度に単純なら、定義から求める（分解しない）方がよいこともある[区間転倒数がわかれば定義通り求まる。かつ、分解した時高速に求める術がよくわからない](https://atcoder.jp/contests/abc380/tasks/abc380_g)

- 基本的に、独立で分解したほうが解きやすい。
    - 独立性より
    - よって、求めるものを、できるだけ「要素ごとに+で結合されるような・要素ごとの重みの和で表される」式で表したい。
    - 表示が一意でないなら特に。
        - 例: 順位の期待値を求めるとき、 i * (i位の期待値) とするより、 $\sum$ 要素iが自分より前に来る確率 とした方が分解しやすい。

- dpと分解は独立なテクではない
    - 要素の個数の期待値について、要素毎に持っている確率を求めるとして良い...[例題](https://icpc2024.jag-icpc.org/icpcdomestic/contest/all_ja.html)
    - 操作の回数の期待値について、それぞれの操作毎に行われる確率を求めるとして良い...[例題](https://atcoder.jp/contests/awtf2024-open/tasks/awtf2024_b)
- また、本当にこの言い換えによって独立にしてしまって良いのかの保証は、期待値の線形性を用いて行えば良い


独立なら、積についても分解して求めて後で掛けるとして良い。

## 状態の分解（定義より）
- $\mathbb{E}[試行で発生するスコア] = \sum_{試行が取りうる状態} \mathbb{P}(試行がその状態になる確率) \times \mathbb{E}[その状態から遷移する直前までで試行で発生するスコアの期待値]$
    - >命題:状態 -> 状態の、細かい遷移を考える必要がない。状態を固定した時、その状態になる確率と、そこでの期待値がもとまれば良い。
        - 遷移を全て計算するには状態の情報が大量に必要だという時、dp[状態]:=そこからかかる期待値 というdpだと計算量が爆発するが、これはその計算がいらない。
    - 例えば途中状態が膨大でも、終了状態が少なければ卓に上がる



### シャッフル
なんかすごいランダム  

シャッフルした要素の中から1つ選ぶ <-> シャッフル範囲内の要素からランダムに1つ選ぶ

### 分解典型1: $\mathbb{E}[試行の回数]$
- $\mathbb{E}[\sum X_i := i回目の試行をしたなら1, else 0]$ の形に落とす。すると、$期待値 = \sum i回目の試行をする確率$ になる。
    - 確率の方が一般に扱いやすい
    - 分解したところで、それぞれが関わり合っていて高速にもとまらないなら、あまり良くないかも

### 分解不可典型1: $\mathbb{E}[max(X1, X2...)]$
- 分解できない
    - かと言って、期待値の定義通り分解してももとまらない場合がある
    - そういうときは、E[max(X1, X2...)] = $\sum_i (P[max(X1, X2...)] >= i) $ を用いると良い
        - maxの条件が、要素ごとに独立になって、愚直に定義通り展開するよりおそらく考えやすい

### 分解不可?典型2: $\mathbb{E}[\sum X_i \ge K となる初めてのi]$
- 双六とかである
    - 初手で場合分けしても良いし、「これからのdp」（再帰的なdp）で求めても良い


## 分解不可? $\mathbb{E}[\max(X, Y) >= kとなるまでの試行回数]$
- 例えば: 「最初にk回勝った方が勝ち」
    - 負けた方の勝利数を固定すると確率計算になる(状態の分解)

## sum / 場合の和 の還元して、sumを求める
- 分解するよりも、こちらを考えたほうが楽なケースがある
    - 楽で無いケース <- [グラフの削除回数の期待値](https://atcoder.jp/contests/agc049/tasks/agc049_a)
    - 少なくとも、積の和典型を使おうと思うと、コレをすると格段に見やすい
    - 積の和典型は場合の和を経由する



## ループの解消
- 漸化式ではループを持つ時の解消法
    - 0: 移項する
    - 1: ループの1点を、漸化式とは別の方法で求める
        - 計算量を多くかけても良い場合が多い
        - 元々求まってる場合も多い
    - 1-2: 1次式を持つdpでやって、だす
        - 巡回の解消がとても無理な場合
        - (1) : 1次式の形で全て表す
        - (2) : わかっている等号からxを導く
            - 期待値... ax + b = cx + dとか
                - 等号
            - 確率... a0x0 + a1x1 + ... + anxn = 1の連立方程式を解くとか
                - 確率sum = 1
                - 特に, ax = bx ならばx=0であり、これが出た場合勘違いしている可能性が高い
                    - ループの1箇所でだけうまくいかない漸化式を考えているとか
    
    - 3: 循環 -> 回数の情報をつけて、無限和にして、公式から計算
        - 考察重め、実装軽め、いつもできるかわかんない
   

## 条件付き確率が厳しい時、問題の言い換え/dpの言い換えで対応する
- dpの設計によっては、「この操作でooが起きる時の操作回数の期待値」& 「この操作でooが起こらなかったという条件のもと、操作回数の期待値は何か」が知りたくなる場合がある
- 難しい場合がある
- そのような時は、dpを言い換える事で、「ooが初めて起きるまでの期待値」だけを必要とする、というテクニックがある
    - case: 幾つか独立な要素があって、それぞれについて1回以上ooを達成したかが重要な時
         - ooを達成した場合と達成しなかった場合で分けると、どうしても達成しなかった場合の期待値が必要になる
         - どうしよう
         - ooが達成されることを1段階とすると、「達成した時にした場所が、ooをすでに達成してたかornotの確率がわかれば良くなる」
<br><br>

## 対称性
> 命題: (key, value)の組みを計算するとき、同じvalueをとるとわかっているkeyはまとめて考えればよく、2回計算しなくて良い
- 系: dpにおいて、同じ値を取るkeyを持たなくても良い
- 系: シミュレーションにおいて、高次元の情報をもたなくてよくなるばあいがある

> 命題: ランダムワープを繰り返すとき、全ての場所について、そこにいる確率は等しい
> 命題: 打ち消す様な操作について、それが起こる確率が同じなら期待値は0
に、期待値ならばこれは打ち消しが起こる可能性



<br><br>

# 最適化

## ノイズとなる要素の排除
- 考察の上で、「明らかに無駄な要素」は邪魔になることが多い
    - これを考えるせいで綺麗な貪欲がないなど
- そう言うのは最初に排除した方が良い
- しかし、これは結構時間と労力が要る
- しかし、問題の見方を変える事でその作業が「明らか」の1声で済む場合があり、積極的にしようね

- 2パラメータ -> 平面プロット
    - 実数係数なら
    - 2要素の組み合わせ -> 線分
    - 3要素以上 -> 平面
    - 無駄を省く -> 凸包
    - に対応しがち
    - (こう言う都合で、inf・極限->実数に言い換えが良い)

- > 命題: ボトルネックとなる要素がある場合、それ以外の要素を無視してよい

## 最適化をdpに落とす一般的なテク
> 命題: 探索対象を固定した時のスコアが存在し、途中段階の貪欲が成立するならば次の解法が適応できる
> 1. 探索対象を1つ固定して、それについて「この時のスコアは何か」の計算を作る
> 2. 計算を段階的にすることで、固定も段階的にする
> 3. 各段階において、判定に用いる情報が一致するものをmaxやminでまとめるdpで数え上げる。遷移では各段階ごとに探索対象を固定する。

- 3でmaxやminでまとめられることが必要

> 命題: この方針は、固定する対象(操作など)については全探索することを前提にしている
- 探索対象を全探索しないことによる高速化をしたいなら別の考察も混ぜる必要がある
    - 数え上げだとどうせ全探索するので問題にならない
    - 特に、貪欲により決定していけるタイプの解法とは方向性が異なる

> 命題(貪欲解法): 最適な操作を選んでコストminの時、操作を固定した時のコストminの計算がうまくいかずとも、選ぶべき操作の列挙が高速にできるならばその列挙を元に答えられる

**複雑そうな最適化において、dpは忘れがちなのでちゃんとローテの対象にする**

## 貪欲法(i.e. 探索空間の削減)
全てを列挙せず、アリエルのだけ探索する

極端な要素に注目

両方向を見る

### 無駄な処理が多いのははっきりしているが、どうにも解法は生えない
- 「しても答えが正当」であるようなomitを、非自明・あまり役に立たなさそうでも良いので思いつく限り挙げると、非自明にそれが良い構造となって計算量が抑えられることが多い

## 問題全体の貪欲
> 命題: 何か1要素に注目して、その要素に成立する命題を考えるだけでは、他の貪欲が見つからない

> 系: 詰まったら、「何か問題にかかわる要素について成立する貪欲はないか」と考えるべき。それで見つかれば、より問題の構造がわかる


## しなくて良いの利用・自由度の制限

最適を取らないような探索を省いて良い。そのために、「ooしなくて良い」「ooとして良い」のような貪欲が見つかりやすい
- 必要な事: 最適化の観点上、しなくて良い探索がある
    - 特に、全体の形に対するものでなくても、特定の部分に対して「OOは連続しなくて良い」等は多い
- いつ考える: 最適化で高速化に悩んだらいつでも
- 自由度が制限され一意になることにより、状況が簡潔になって考察し訳すなる・全探索ができるようになるのが旨み

> 命題: 答えが $x$ 以下ならば、 $x$ より大きくなるような探索はしなくて良い
- $x$ が特に小さい時に構造が生まれ有用
- 最適とは限らないが、いつでもできる強い構築によって $x$ を得る


## 下界・上界
> 命題: 下界・上界がもとまって、かつそれが達成できるならばそれが答え

> 命題: minを求める(i.e.上界を求める)ならば、必要な命題は「少なくともOOの損失が発生する」という形である
- 下界・上界を求める時に考えること
    - あえて悪くなる条件を考えるのがちょっと非自明
- 例:一致する個数のmin ならば、 「少なくとも異なる」ような条件を探すことになる。

> 命題: 上界・下界は特殊ケースについての回である
 - その上界・下界が達成できるケースは解けている $\Rightarrow$ 他のケースのみとけば良い  

 また、上界・下界が（独立に）得られる場合、 $\min$ や $\max$ で結ぶことになるが、この時  
 答えがminで表されない $\Rightarrow$ それぞれの上界を達成する条件が1つも満たされていない  
 ということになり、連立した時は場合分けすることで考察が進む可能性が高い


## 答えが確定するので計算しなくて良い場合
> 命題: 答えが確定した時点で、それ以降の計算はもうしなくて良い
- 答えが確定したかを判定してしていたらbreakなど


> 命題: 場合分けのうち、「そのような場合になった時点で答えが決定するので、その場合は計算しなくて良い」と言えれば、そのパターンを計算しなくて良い
- 複雑になるようなケースをこれで潰せることがある
- 答えが決定する...最適化における-1, 判定におけるyes/no
> 命題: 最善な改善でも答えが悪化するならば、今後改善することはない

> 命題: 条件を満たすうち最適値を求めよという問題について、そもそも条件を満たすことが不可能なinputについては考察しなくてよい。条件を満たすことが可能なinputだけについて最適化を考えれば良い
- そもそもinputによっては絶対無理というとき、可能なinputである条件・判定アルゴリズムをうまく出せると問題に構造が増える



### 目的関数を最大化するように並び替えろ
何かしらの比較関数でsort
  - 比較関数の作り方
  - [1]**隣接する**2つの要素について、どちらが前に来るべきかの判定関数を書く
- [2]その順序が、推移律を満たすことを確認する

さえすれば、その隣接要素の判定をそのまま比較関数に用いて、sortしたものが最適であることが言える。


 - 極端な物を見た時、「後ろに・前に持って行った方が良さそう」という感覚がある時に有用

### 関連: 順番を入れ替える: sortする考察
隣り合う2つについて、入れ替えても良いことを言えば良い

## ある選択肢について、決定をのちに保留・選択肢や分岐を持ちながら探索
- 持ちながら探索とは: それぞれ別々に探索するのではなくて、あり得る集合を持って1本の探索するみたいなイメージ

- 必要なこと
    - どの選択肢を取ろうが、後の選択肢が変化しない
        - するなら別々に探索しないといけない
    - あり得る結果の集合を管理できること
        - 区間の場合は頻出
- いつ考える: 上記が満たされていて、かつ「今決定」は無理な時
    - 保留せずに一意に決めていいなら、今決めてしまった方が影響の前計算ができて速くなる事が多い
    - とはいえ、殆ど全探索なので、本当に選択肢を保持できるならほとんどの場合解けるはずで、これ単体で解けるぐらいには強い構造
        - 保持する上で余計なコストがかかる分、決定できるならしようという話


## 最短経路への言い換え
- 何が嬉しい: DAGでなくともO(|状態数+遷移数|log)或いはO(|状態数+遷移数|^2)ぐらいでテーブルが求まる
    - つまり、DPできなくても答えが求まる

- 必要なこと: (1)始点(すでにコストがわかっている点)があること (2)各状態間での遷移のコストがわかっていること (3)状態数+遷移数が間に合う程度に小さいこと


## こちらに有利になる制約 -> 敢えて外すことによって、答えの自由度を上げる
- いつ考える:考察の過程で「結果を固定した時、実際にこれはあり得るか」を考える時、有利になるような制約のせいで、実際にあり得るのかの判定が複雑になる時
    - 最小化で min(ai, bi)を選ぶ -> ai, biから好きな方を選ぶとして良い。かつ、そうすると採用するai, biを決め打った時の実現判定が楽になる(biを使うと決めたが、実際はaiが小さい場合...の場合分けが減る)

- 具体例: どちらか洗濯することにして、選択を全探索すれば答えが求まる


> 重要な例題: $n$ 種類のアイテムがある。 $i$ 番目のアイテムを買うと $1$ のコストがかかり、種類依存のスコアがもらえる。このスコアは同じ種類のアイテムを買うごとに減っていく。 $C$ のコストをかけて良い時、スコアを最大化せよ  

解法: 一番スコアが高いアイテムを買うとして良い。シミュレーション

これによって、いろいろな問題が解ける
> 系(同じ解法): 要素に0/1割り当てをする。0を割り当てた場合 A_i, 1を割り当てた場合B_i のスコアが得られる。ここで、A_i < B_i。 ここで 1 を割り当てる要素数が決まっている時、スコアを最大化せよ
# 最大値・最小値

## 判定問題
答えをxにできる・x以下にできるか？を解く
- 必要な事: 固定したら（解きやすくなっていてかつ）解ける事。また、その固定を全て動かしても間に合う事。
- 最初に、条件を与えられた数値 $x$ で書き直す
    - 最大値がx以下...全ての要素がx以下


- 目標によって（最低限）取るべき解の形が変わる時に特に有効
### 二分探索
単調性があれば、判定問題を解く回数を減らせる。
かつ、基本的に、最小値が存在するならば、「値をx**以下**にできるか？」は単調性を持つ。よって、この判定問題が解けるならば、その問題は解ける。
- 動機 : 愚直なら思いつくが、完全な愚直は間に合わないという時に、愚直を実行する回数を減らして間に合わせる

なお、常に単調性があるとはいえ、判定問題が解けなければ意味がない　例 : 無向グラフ　サイクルのサイズの最小値

## convex full trick
- 基本アイデア：傾きが大きい方から見ていって、なんとかする

- 直線...convex full trick 

- 折れ線: 始点が共通...始点バラバラに比べて綺麗な形をしていて、上側の変化の計算が楽
![alt text](<スクリーンショット 2024-12-16 23.20.01.jpeg>)


### maximize  x ⇔ minimize -x


## 単調性/区間
- 単調性は嬉しい性質

- 単調性を持たないが、似たものがありそう <- 区間になっているケース


### 大きくなりうるスコアと上限が小さいスコアの加算
- 大きくなるうる方をB, 小さい方をSとすると、スコアが小さい方ではSの影響が大きいが、Bが大きくなってくるうちにSの割合が小さくなっていく
    - よって、Bの大小でスコアの大小が決まるようになる
        - 枝刈りになる


### 複数のオプションと、それぞれにスコア
- ある選択肢であって、他の選択肢のスコアのsumより大きいのがあったら、それを貪欲にとって良い。
    - 2値...値がでかい方を貪欲にとって良い。

<br><br>

# 判定

## 最適化との際
> 命題: パラメータ $n$ が大きい時常に yes ならば、パラメータ $n$ が小さい時だけ計算すれば良い
- 最適値を求める時より計算量が落ちる


<br><br>

# 特定

> 命題: $p_0, \dots, p_{n-1}$ を特定する時、これらについての独立な方程式が $n$ 本立てば特定できる
- 特に $n = 2$ の場合など


<br><br>


# 証明

## 貪欲の証明


- 「答えは必ずPを満たす」
    - Pを満たさない限り改善できることを言う
- 任意の状況について、より偏らせた方が得 => 極端なものが最適
    - a^2 + b^2 <= (a+1)^2 + (b-1)^2 等

- その選択をした後の状況に注目して、「今最善をとっても状況が悪化しないのでおk」をいう
    - のちの状況が単純で、良い・悪いが比べられる時

- ある操作について、「いつかしなければならず、かつそれをするまで、その操作に関わる部分の状況が変化しない（周りと独立？）」時、今すぐして良い
    - いつ考える: 操作ができるならば、今すぐして良いの証明

- （ある特徴量によって）上界が示せて、それにそうならその操作が最適
    - 操作の最適性を言いたくて、いい感じの上界がある時  
        - 操作によって動きが大体一様なもの/どんな操作でも一定量変化するものを選ぶと良い。特に、必ず+1 -> 操作回数の下界

- 任意の探索について、1.その探索の中に最適解が含まれる 2.その探索において、Aが最適 => 全体においてAが最適解
    - 探索を絞る時の正当性


    
-  任意の最適解を持ってきた時、初めて貪欲から外れる点に注目して、そこを貪欲ベースで選ばれた選択肢に置き換えても解が悪化しないことを言う
    - よくあるのはswap。最後に持っていっても良いはswapせず、抜きだして移動など


- 2方向の自由度がある -> 全部を極端な物で初期化して、それを減らしていく一方向で考えると変更の方向性が一意
    - 全体に総和制約 && 日毎に累積和で総和制約 最適化[例題](https://atcoder.jp/contests/abc250/tasks/abc250_g)
    - 全ての日を最適な選択肢で初期化 -> 日毎にこれまでの解を改悪する事で制約を満たすようにする
    - この時改悪の選択肢を貪欲に選ぶ

- 複数の要素がある状況で貪欲したい -> 考慮する要素を順々に減らしていく方針にする
    - 極端なやつについて決定 -> 無視できるならもうその要素は無視

- 困ったら
    - 場合分け
    - 特に、対象の個数が小さい時はできる
    - 前提条件はちゃんと明示する
        - 特に、再帰的にくり返す系
## 必要十分条件
- 最後の操作に注目 -> 最後の操作はそのまま残るので、それにつく必要条件が考察しやすい
    - 操作をしていく/置き換えていく系で、可能・不可能の必要十分条件を考えるならば、常に有効

## 同じと見做せる -> 制限
- 同じと見做せるものは、「条件を満たすか」「最適か」を考える上では、制限しても良い

- 特に単位元的なものは好きにadd/削除して良い
- 例
    - a + b or a ... a を a + 0とすれば、常にa + bの形で操作を表せる

### 2つの操作列から同じ結果
- 片方の操作列は発生しないとして良い
    - 操作1をx回 = 操作2をy回 -> 操作1はx回未満

## 最適化の探索・DPの正当性
- 最適解が探索に含まれる
- 最適解より良いスコアをだす違法な解が探索に含まれない

- の2つが必要十分
- 多くは前者を考える



## 背理法
- 自明に解けるケース: 成立するケース
    - 成立しないとした時、何が言えるか?
 

## 過去を改変する貪欲
- 命題: 局所的な最適と全体の最適が異なる時、「常にその時の最適を取る」で構築した解は全体の最適解とは限らない
    - 命題: 一致するならば、常にその場の最適を取る解法が最適解と一致する。(一般的な貪欲)
    - しかし、次の命題のような条件を付加する事で、そのような状況でも貪欲できる場合がある
- 命題: 「今までの範囲**だけ**見た時の最適解と何らかの情報」を元に、新たに1要素追加した時の新たな「最適解と情報」が求められるなら、それを続けることで全体の最適解が求まる
    - 1要素だけaddした時に修正できれば良いという事
    - 局所的な最適と全体の最適が異なっても良い
    - 往々にして今まで構築した解を変更する <- 過去改変貪欲
        - 改変について、「過去に決めたやつの中で最悪なやつを追加した要素とswap」するなど
## misc
- 手続き型の記述の証明 -> その手続きによって得られるものを条件の形に落として、そこから議論
    - 頭を一回スッキリさせて、「その手続きから作られるものは？」を解く
        - 最適なものは何？より考えやすいだろう
    - 常に最適が示せない時に考える
    - 例えば: 作れるものの必要十分条件は、この手続きで得られるもの <- 距離が遠くて考えづらい>
        - この手続きで得られるものとは？を先に解く解く
<br><br>

# 状況が変わる部分で問題を区切って、変わらない部分は一気に求める様な計算
- 必要な事: 状況が変化しない範囲での答えが出せる
- いつ考える: 状況が変化する時・情報を持って探索するが、必要になる情報が途中から変化する為たくさんの情報を持つという時
    - 例えば、最初の方は初期HPを使い、途中から回復するという時、両方をまとめて処理しようとすると「今のHP、回復量」の2つのパラメータが必要になる
    - しかし、初期HP -> 回復ゾーンでそれぞれ分けて計算したのち、初期HPが切れるタイミングを全探索して状態を合わせる事ができれば、持つ情報が1次元に落ちる
    
<br><br>

# 選択肢を全て列挙しない・条件を全て確認しない
- 必要な事: 求めることが「全ての自由度の対してある値」なのでは無いこと。例えば「最適な値」であったり、「何かの判定に必要な値である」こと。
- いつ使う: 愚直に全ての選択肢を試してそれを集約しては間に合わないが、上記の条件を満たす時。
- よくある手法: 最適なものから「選択肢になりうるか」を試す。選択肢になりうるなら、そこの自由度は確定なので、その自由度を考慮から省く。

- $n \times n$ ペアの探索対象 -> 全ての $n$ に対して、理想な相手を探す

## 問題の構造的に等価なものを両方調べない
- 情報のロスト的な
- 主に最適化・判定で、等価なものを両方調べなくて良い



## 二分探索による高速化
判定の回数がlogになる。
## 並列二分探索
シュミレーションを完了するのはある程度まともな時間に収まる かつ 独立な二分探索をたくさんしたい時に使える

### 各選択肢について、そこで取れる選択肢のうち最適なものだけを計算する
- 必要な事: 愚直に全ての選択肢を列挙している状況において、ある選択肢を取る事を固定したら、その自由度の中でも「これを取れば良い」という一意な選択肢が存在する事
    - 固定みたいな
        - 内側の選択肢を消す

    - 選択肢になりうる、未確定の自由度の検知が高速にできれば間に合う


### top2だけ持つ探索
- 必要な事: 「いくつかの選択肢から最適を選ぶ」という時に、例えばtop2の選択肢さえ求まっていれば良い(的する方を選ぶ等)なら、それだけを求める（ダイク小さい方から）探索をすることによって、全ての選択肢から全ての対象への値を求める事をしなくても解ける
    - 特に、全ての選択肢について最適な値を出さなくて良い事を使える
        - 最適な選択肢について、その値を求めるというのは頻出
    - 最適化ならば、小さい方から・最適な方から求めるというのはダイクストラ方

<br><br>



# 構築
- コツ: 
1. 集中して
2. 解法ローテ

> 命題: 今まで考えた解・解法が全てダメなら、より多くの解・解法を検討する必要がある
- 手で解を探すときに、その探索空間をどんどん広げることを意識すると良さそう？(以下、表現力と呼ぶ)

## 一般が複雑なら考えない
- 一般的な議論は漏れがないことが保証されるが、複雑すぎて手に追えない場合がある
> 命題: 単純な構築の中に条件を満たすものがあれば、それを出力すれば良い。特に、「最適な」ものを出力する必要はない  

> 系: 制約が厳しくなければ、無駄なことをしても良い
- を元に、そう言う時は簡単な物を考えたり、簡単にするためにあえて無駄をしたりすると良い

## 1発綺麗なのドン
- 答えになれば良いが、合わなかったときそこまで。表現力があまり高くなさそう

- ベースアイデアとして、小さいケースでの解を転用すると良い

> 命題: 構築の形を制限した時、その制限によって「構築がその制限を守る上では不可能か」が容易に判定できる場合がある
- 最初に考えて、そもそも無理だったら具体例を試さない・無理な原因を改善する

### 最悪ケースを考える
何について綺麗にするかがわからない時、「構築できるならで一番条件がきつい」初期条件のもと考えると貪欲に綺麗にすべき指標がわかりやすくなる
## 大雑把な解をベースとして、それを改善する
> 命題: 任意にパラメーターを変更できるベース解を作成できれば、あとは制約に合うよう変更を加えると構築が完成する

- まず一部の制約を満たす（時には: 何も満たさなくても良い)解を作る。その後、他の制約も満たすように解を修正する
    - 一発ドンよりも表現力が高そう
- このとき最初に合わせる制約が自由度だが、基本的には後から合わせるのが大変な制約を最初に合わせると良い。

- このとき、「既存の制約に違反しないような操作」が表現力に関わってくる
    - あるいは、違反してもすぐに修正できればよし
    - 行・列swap

> 命題: 一度trueになったら他に関わらずtrueになる制約は、最初にtrueにすればあとは無視できる
- 最初に合わせておくと、もう無視できる(後から修正などはない)
- あるいは最後まで忘れておいて、最後にそう言う部分をaddすれば良い
    - 例: 全体gcd = 1 について、 2, 3 $\in S$ $\Rightarrow$ 全体gcd = 1






> 命題: 一部のケースでだけ成立する解を、他のケースに転用できるように修正できれば構築が完了する
- 一部ケースでだけ成立する解が先に得られる場合もあり、直ちに転用できないからと言って転用を諦める必要はない


### 制約逆伝播
定義: 構築が一部の条件だけ満たさない時、まず結果がどうであればその条件を満たすか考え、その結果になるように初期状態を修正すること。
- 追加の条件が満たされるまでまた新しいのをローテするよりも強力



## 綺麗な操作・要素を組み合わせる
- 扱いやすい操作を組み合わせて構築を目指す
- 特に、極端な要素を絡めた操作は良い性質を多く持つ



### 典型的な"綺麗"な操作・事実
小さい操作
- 一致させよ
    - +1/-1できる...
    - swapできる...
        - 特に、隣接swapさえできれば任意の並べ替えを作れる

大きい操作
- 一致させよ
    - sortできる...
    - 種類の違うものを前後に分割できる...
- 最適な物を構築せよ
    - 上界が達成できる...
        - 上界を作ることだけを考えれば良く、目的が定まって嬉しい
- 数列SをTにせよ
    - 先頭から合わせる事で高々定数項を残して一致させられる...
        - 残った数項は不変量で評価



- サイズが大きくなるとだめ・常にok
    - ダメなものを貪欲に取ると、maxが指数オーダー
    



## 再帰的な解法 in 構築
問題が、より小さいサイズに帰着できさえすれば良い。
- 帰着の時にいくらでも場合分けを挟んで良いので、表現力が高い

制約がパラメータによらない、定数で与えられていてその制約が 状況によって厳しくなると難しい
- 再帰関数の設計がそのままだとできない
        - 次に渡す時、制約が1厳しくなる...そもそも作れるかわからない

## 解けているケースを組み合わせる
帰着の逆。解けているケースを組み合わせて、解けてないケース・nが大きいケースを解く。


## 必要条件から探索空間を絞る
作れる・作れないの判定が必要な場合は勿論、そもそも制約の範囲内で作れるものの必要条件を絞ることは探索空間を絞る意味で有効。

- > 命題：答えとなるパラメータを仮定した時、何かしら等号で結ばれる式を立式できれば、それがパラメータに対する必要条件となる
    - 敷き詰めけいの個数が有名。一般に、操作ごとに増加する値についての等号を取る。



## 存在しないものを作ろうとしてはいけない/できない時がある
- 出来ない場合について「条件を満たす」手段を考えたって解けない
    - 特に条件が複雑な時、存在しない事が見え辛い
- まず、判定を先に解くべき(判定問題ならはなからこれ)
- すぐに解けないなら、必要条件を出して状況を整理するだけでも良い
    - 旨みが状況の固定化なので、これでも十分恩恵を得られる
  


## 不変量による必要条件

### 不変量の見つけ方
典型的な不変量を頭に浮かべながら実験する。

### 典型的な不変量
操作によって、全体として必ず減る・必ず増えるもの・常に不変なものを考える
 - 個別の要素間では増えたり減ったりするかも知れないが、全体では減る事がある

- **何かの偶奇**
    - 和の偶奇、差の偶奇、個数の偶奇...
        - 0にしろ...最終的には偶数
        - 操作できない状態...偶数・奇数・あるいは個数
            - ゲームを不変量で解析するときに頻出
- 大小が制約に関わる(sort, swapの条件)時、転倒数を見るのは良い
- 数列の和、mod M

- bit/ bit演算
- b進数表記した時の桁の数について...
    - [例題](https://atcoder.jp/contests/arc145/tasks/arc145_d)
- +1と-Nをする操作... mod(N+1)で、一様に+1 
    - [例題](https://atcoder.jp/contests/arc079/tasks/arc079_c)
         - 任意の順で操作しても答えが変化しない事の証明
             - 任意の順で最小A回→定められた順でもA回、を証明する...総和とmod(N+1)の一致より、数列一致

或いは、何かの証明をしたい時に、"これは不変なので、これ以上は操作できない・これ以上この遷移が走る事はない"の主張で使える
 - その時も、"その操作で"全体で不変・増加・減少しているものを見る

### 典型な必要条件
- 不変量に注目した必要条件

- 最初の操作による必要条件

- 最後の操作による必要条件
    - 途中は自由でも、最後だけはきっかりとした事が言える場合



## どうなっても良い（決定を自由度として保留しておく）のは構築において便利そう

#### "できる事"は丁寧に集める・早とちりしない
- 時間の浪費
- 回数制限クエリ系、 $O(???)$でoooが求まりそう...本当にそのオーダー？
    - 丁寧に見る事で、応用にも繋がる
    - 誤った考察を元に考えるのは本当に時間の無駄


### 利用の仕方がわからない制約・規則
- 機械で答えを列挙して、何か答えに良い性質が生まれないか実験する



### 一致・変形判定標準形の利用
一致判定に良く使う
最初の状態S,目標状態Tを共に綺麗な状態にする
- 01列...1だけの列
- この時、置き換え操作ならば、その操作の逆をできないか考えると良い
    - 逆ができるならば、もう2始点と思って良い

### 条件を満たす"部分"ができるように操作しろ
- [1]条件を満たす集合を選択 [2]その集合を、条件を満たすように操作 の 2段階に分けられる
    - 集合を固定した時の操作の仕方をまず判定問題として解いて、その結果を元に何を選ぶか考えたりdpする

## 似たようなものを複数用意する時
- サイズが大きいものを1つ用意し、それを部分的に利用するような構造にできれば、用意するものが減ってコストが減る。


## 掛け算 / 足し算
- 掛け算...「始点と終点が定まっているが、途中で分岐する」という時、その外側の経路に対して、今見ている分岐の数だけ掛け算になる
- 足し算...一つのブロックの分岐を増やすと、足し算（そこの係数に対して）になる


## 存在するなら1つ見つけろ
- 鳩の巣原理
    - 嬉しい: 実質的な全探索が小さい計算量で行える
        - 存在する条件で絞れない・枝刈り全探索が無理とかの時
    - 必要: "適切な"巣
        - そもそも鳩の巣原理とは、「どのような要素もいずれかに該当する」という条件の集合を見繕った時、「いずれかの条件について、それを満たすものが2種類存在する」というものであった
        - よって、任意の重複 <-> 答えの発見 出なければならない
        - 式にすると、f(i) = f(j) のような式が一つ見つかるので、それを元に答えを構成できれば良い
    - あるいは、重複がある程度少ないなら、探索を進めることで巣を完全に埋める(:= 答えを見つける)ことができる

- 乱択
    - 必要な事: 1回の失敗確率が小さい
    - いつ考える: 条件を満たすものが（存在するならば）多い時

- 範囲を絞り込んでいく
    - 候補:= 全体集合とする。その集合を小さくしていく。 
        - 特に、候補を二分割して、「存在するならば少なくともこちらには含まれる」というのが分かれば、log回の深さでわかる
    - 必要な事/いつ考える: 集合に対するクエリが捌ける

### 集合から要素を1つ見つける: 条件を満たす要素が多い時
- 必要な事:　条件を満たす要素の個数が多い・全体からの割合で表されている事
    - これが満たされていれば、全ての選択肢を試さなくても、うまくサンプルすれば小さいオーダーで良くなる・乱択ですぐにみつかる
- いつ使う: 条件を満たすものが存在するなら1つ出力せよという時に、愚直に全ての選択肢を試していたら、その削減策(最適化の時みたいな)

- 例: 集合の部分集合であって、条件を満たす&&サイズがn / 2以上
    - そのような集合が存在するならば、適当に2要素のペアを取った時、そのペアが共に集合に含まれる確率は 1/4 <- 確定的にするなら $O(N)$通り試せば良い。
        - 特に、1つ選ぶ時は1/2 <- 確定的にするならどのみち $O(N)$通りであり、ペアを試してもオーダーが変化しない

## 連続と離散の違い
- 連続では対称にすると最小値を取る関数が、離散では少し偏らせた方が最小値を取ることがある。
    - 対称で条件を（少しだけ）満たさない時は少しだけ偏らせると値が小さくなり条件を満たす可能性がある
## 埋め込み
- 無理に関数で実現しようとおもわず、視覚的に埋め込む（2次元配列とか）で、適宜コピー関数で埋め込むのが早い&&安全そう[参考](https://atcoder.jp/contests/agc041/tasks/agc041_c)
## examples 

- [マス目を01にする。個数の比を保ちつつ制約を満たせ](https://atcoder.jp/contests/kupc2024/tasks/kupc2024_b)
    - 解法1: ox, oox, ooox, oooox の基本要素を使ってA : B の列を1つ作る
    - 解法2: どっちでも良いますをたくさん作って、それを変更して作る
        - 小さい時の綺麗な解法を繋ぎ合わせる
<br><br>

### 他
- 初期状態を作っておいて変化させるという構築の場合、初期状態はシンプルなほど良い
    - デフォルトで1だけ重みを持つなどすると構造が少し複雑になって、そのせいで解けなくなる場合がある
    

- 一致させよ・全てkにせよ
    - 差分がall0が必要(十分)
    - 差分での言い換えがしやすい
- 開始状態、終端状態が与えられた
    - 片方が特別単純な時 : 開始、終端をswapして考えると、dpで持つべき状態が減る...
    - 両方複雑な時 : 綺麗な"標準形"を作り、開始・終端を共に標準形にした上で、一致判定
        - sort..
- 簡単な操作を見つけた
    - 他のバリエーションは？
        - 似たようなことによって、数値が少し変わっただけのを作れるかも...
    - それによって解ける問題のケースはどのようなケース？

- 一部のケースが解けることがわかった
    - 解けない問題のケースは？
    - 何でそのケースで上手くいく？

- 複数制約がある時、後から辻褄を合わせやすい制約は後で合わせる
    - 総和とか
    - [例題](https://atcoder.jp/contests/arc145/tasks/arc145_d)

- 要素を選ぶ。隣り合わないように選べ
    - 要素の集合を2つ用意できれば、どっちサイドを使うかを適当に割り振ることで隣り合わなくできる

- 整数nの表示
    - 三角数(nC2)3つの和としてどんな整数でも表せる
        - 四角数（=平方数)だと4 [link](https://manabitimes.jp/math/926#5)
        - ただし、三角数の時、隣り合う数字を使うことが下の3つでのみ起こりうる。かつ、1については、2つ使うことがアリエル。


## 実験の仕方
- 一番解きやすそうなパラメータの時を考える
    - 順列: {1, 2, 3, 4, ... , n}の時
- 一部の制約を無視
- 小さいケースについて列挙

- **見比べる考察**
    - 必要条件を出したい時、「それが成立するもの」と「しないもの」を見比べる
    - 必要条件に対して、本質的な違いがあるはず
        - いきなり出せなくても、事実->理由->必要の順

- 状態にループがある時、単一始点なら解ける場合が多い
    - 一度探索した頂点は見ないとする
    - 有向グラフにおける、単一始点での到達可能頂点列挙
    - ただし、始点以外の結果は誤っている可能性がある


- 条件のエスパー -> それが必要十分か
    - 他のものは一歳満たしてはいけない
    - サンプルを全てためそう

<br><br>

# 操作の構造の考察

## 順番に寄らない操作
> 命題: 操作の結果が順番によらないならば、好きな順で操作を決定して良い
- 特に、dpと併用する

## 操作の独立性

> 命題: 最適解において、「...-> op1 -> op0 -> ...」 となっている時、答えの値を変更せずに「... -> op0 -> op1 -> ...」とできるなら、op0をしたのちにop1をするとしても答えは変化しない
- 答えが変化しないとは: 例えば操作回数が変化しないなど。操作の内訳は変化して良く、種類がswapされていれば良い。

## 一意な操作
> 命題: ある要素 $x$ であって、操作のされ方が一意で、なおかつ最終的には操作した方が良いと言う時、即座に操作して良い。逆に操作しない方が良いのなら、その要素にはもう操作はされないとして良い。
- 最適な操作列において、一番前に持ってきても答えが悪化しない


## 要素に一度しか操作しない
> 命題: 全ての要素が、その要素に操作する回数が高々1であるならば、単に操作する・しないの2値を決めれば良い
- 他、1度しか操作をしないとすると動きが少なくなって良い
    - 特に、操作が移動である時、移動が小さいと言う事になる
    - >命題: 数列へのswap操作について、各要素移動する回数が高々1回である時、[0, i) についての問題が i-1番目の場合分けによって [0, i-1) と [0, i-2) の問題に帰着される

## 可逆な操作・打ち消す操作
逆操作が存在する場合に言えることがいくつかある。
- 操作回数を最小化しなくて良いならば: 標準形を使ってよい
    - とりあえず考察がしやすそうな形にしてから考えるということ。
- A -> Bにできるか？の場合、 A -> 標準形、 B -> 標準形 （標準形は一意に定まるもの) で判定しても良い
    - 考察のstepが減りやすい
    - 「作れる集合の中で」一意なものにすると良い
        - A <-> Bにできるなら集合が同じ、できないなら違う
        - 作れる集合の中で辞書順最小等


> 命題: 可逆な操作を2回しないとしても、作れる集合は変化しない  

> 系: それ自身が可逆操作である場合、一度しか操作をしないとしても作れる集合は変化しない
- 例: flip, xor


### 可逆な操作を両方行える時
- 操作A -> 操作-A のようなものは意味がない
    - これを禁止して仕舞えば、結果的に (-A)(-A)(-A)AAAA のような操作しか存在しない
        - (-A)の回数全探索等、随分考えやすい状態になる
   

### 打ち消す操作をするとして良い
- 片方しかしてはいけないという時、両方しても答えが変化しない。よって、独立にそれぞれ考慮するとして良い
    - 最適化で考えやすくなるかも
        - 株の問題 売る・買う


## 操作が交わらない
> 命題: 操作が交わらない時、操作の境界線でそれぞれ独立に最適化すれば良い(i.e. dpする際、持つ情報がない)

## 操作の単調性
- 単調性とは:一方向きにしか変化しない
    - 数が大きく/小さくなる方向にしか動かない

- 今min/maxである要素に特徴ができる
    - 貪欲ができる
    - つまり良い構造

- これを作るために、部分的に逆操作を考えて、操作を1方向にするとうまくいく場合がある
    - 増やすて減らす->増やすときはゴールを下げる

- いつ考える: 逆操作を導入したら操作に単調性が作れそうな時

## 操作を組み合わせてできる単純な操作
- 与えられた操作を組み合わせてより基本的な操作を達成できる時、その操作から構造の議論を始める事ができて、元の操作を元に考えるよりもかんがえやすくなる
    - swap
    - 移動
- いつ考える:与えられた操作とその結果が捉えづらい時
    - 組み合わせてできる単純な操作は構造の考察に不可欠な場合がある
  

## 移動させる操作

> 命題: 問題が元の配列の添字を抜きにして表現できるなら、相対位置だけで問題を記述できる  

**最初の状態と最後の状態に注目し、途中経過を考えない**  
**(時には)相対位置だけ見れば良い**
- 目標の数列に一致させる問題で頻出
- 隣接swapする時、最小の隣接swap回数
    - それぞれの要素の、最後の位置を固定すると...
        - 転倒数
    - よって、最後の位置を考える問題になる
- 最後の相対位置似注目 : ~を合わせる上で、実は操作OOは最初にやるとして良くて...
- 移動しないと決めた要素について注目 : 単調増加列の必要があって、LISを選べば良い...
- 最後の転倒数は0で、かつ操作ごとに転倒数は減る、転倒数を1だけ減らす操作が存在して最適...

## 2種類以上の操作の構造の整理
- 考察: まず操作が一つだけの時に注目して、その中に他方の操作を1回だけ挟んだ時にどう影響するかを見る事で、操作の関わりが見やすくなる
    - 嬉しい: 操作を1回に絞る事で、1回の影響が見やすくなる




## 逆から見る操作

**操作を逆から見ると簡単になっているとは限らない(むしろ、解けない程複雑になっている場合もある!逆も然り)**
> 命題: 逆操作の戻り値が集合である時、集合に対し考察をする必要がある(i.e.自由度が増えている)
- 有利に働く場合もあれば、構造がぼやける場合もある、一意な方が嬉しい場合もある

> 命題: 逆から見た時の命題が言えたとしても、順方向から見たらもっと良い命題が言える/上界が言えることがある

**逆から見ると決めるのではなく、両方を並行に見ると決めるべき!(経験則)**

### 代入・置き換える操作
次の命題が成立
> 命題: ある要素について、将来的に置き換えるならば今の状態は答えに寄与しない  

置き換えないならば結局今の状態が寄与するので、このままだと上の命題は利用しずらい。
ここで時間を逆から見ることで、上の命題に対応する次の命題が成立
> 命題: ある要素について、初めて置き換えた時の状態が答えへの寄与である  
- >系: 置き換えた時点で寄与が確定する
- 「どの要素が1回も置き換えられて無いか」の01列のみで探索できる

さらに、逆から見た場合次が成立
> 系: 1回置き換えた要素について、その要素を再度置き換えても答えへの寄与は変化しない  

> 系: 1回置き換えた要素に再度置き換えをすることで、その置き換えを無視できる

これが良い構造を持つ事が多い(greedy等)。

また、
> 命題: 1回した操作の結果が、他の操作によって変化する時、最後にした操作の結果は変化させられてない  

> 命題: データ構造への要素の削除は、単位元への置換で置き換えられる場合がある

> 命題: 挿入は、最初から位置がわかっていなかった場合、実際に動かす必要が出る

> 系: 挿入する状況なら、逆から見て削除にすると計算量が落ちる場合がある

> 命題: シミュレーションに加えクエリが「最後の状態が Sであるものについて」である場合、シュミレーションを逆再生する事で「今状態がS'のものについて」のクエリに置き換えられる
- 順方向:最終的な状態を指定されても、どれがそれになるかわからないため全て持たなければならない状態
- 言い換え後: クエリの個数だけ状態を持てば良い


また、直接的な置き換えに限らず、「前やった操作の影響を上塗りするような操作」は、逆向きに言い換えると良い。

また、「順方向にやると操作が無限に広がるが、逆にすると有限」という時、有限性から何か制約が発生 -> 一意の流れが出たりする
- 例: 加算...+無限にいけるが、逆からにすると、最初が>0なので、 <0となるような減算はできない


一般: 最初にやる操作より、最後にやる操作の方が条件が厳しそうな場合
- 最後の方が制約が強く、今何やったらいいかわからない・必要条件がなくても、最後には必要条件がつくということはある



### 最初綺麗で最後汚い
> 命題: 最初綺麗であっても、途中操作をすると汚くなる
- 最初の状態だけを見て全てがわかれば良いが、途中経過が存在すると両方汚くなる
> 命題: 最後は変化しない

> 系: 時系列逆に見ることで、最初汚いが最後は綺麗になる
- 片方でも綺麗になることで考えやすくなる場合がある



### 1回そうさしたらもう訪れてはいけない
> 命題: グラフについて、「いくらでも訪れて良いが、操作を1回したらもう訪れてはいけない」という時、逆から見ると「初めて訪れた時に必ず操作をする」となり、する・しないの自由度が消える


## 操作をしていく際、最初に比べ最後の形が定まっている時
- 最初の方は自由度が高いのに比べ、最後の状況が定まっている場合、「最後の操作」にかかる制約がわかりやすくなる場合があり、そこから考察を進められる場合がある

- また、「制約がどんどんキツくなっていく」タイプでは、「最後でもok -> 最後に決定 -> 最後のは前に影響を及ぼさないので、無視する」という流れにより、最後さえわかれば問題が解けるという場合もある



## 区間操作
> 命題: 01数列への長さk区間flipについて、左 n - k + 1項を任意に変更できる。同様に、右 n - k + 1項も任意に変更できる    

証明: 左から目的に揃えれば良い
> 系: 区間任意整数addでも同様。


> 命題: 長さk区間作用について、添字 mod k 事に値を集約した時、集約値への作用は 添字 mod kに関わらず等しい。


# 操作の貪欲

## 他の操作で置き換えられる操作
- 片方の操作をしないとして良い

> 命題: 操作列について、1回の操作でその結果を実現できるなら、そのような操作列はしないとして良い

- 2種類以上の操作であっても、片方の操作でもう一方のある動きを代用できるなら制限できる
> 命題: 1点+=k,  連続k点 += 1 の2つの操作について、同じ場所への連続k点 += 1 は (k-1)回までとしても達成可能な結果は変化しない


<br>


> 命題: 操作はするだけ有利になる時、最終的なスコアに寄与しない要素に操作しなくて良い
- > 系: 操作をした後条件を満たす要素の個数count $\Rightarrow$ 最終的に条件を満たさない要素には操作をしないとして良い

<br><br>


# 問題の言い換え
## 答えが変化しない範囲で自由度を増やす
- 不利になりうる方向に言い換える
    - $\sum min(a, b)$ の最小化 -> $a, b$のうち、好きな方を選ぶとして良い
    - 答えは変化しない上、考察が軽くなる場合がある
        - 特に、「結果を固定した時、実際にあり得るか（もっと有利になってしまうのでは）」と言う時、上の言い換えをすればそのようなややこしい議論を消せる
## 解けるケースへの帰着
- あるケースなら解けるという時、答えが変化しない範囲で他のケースを言い換えることによって帰着できる
    - 単位元的なものをaddすると良い

## 文字を数字で言い換える
数学の上で扱える
- 一般に、文字より数学の方が扱いやすい
    - 式変形
    - 貪欲
    - 寄与の分解
## 数列 <-> 差分列、累積和列、転倒数列
- 命題: 数列上で見ると手がつけられない程複雑だが、差分列や累積和列に置き換えると単純になる操作が存在する
    - 列の短い部分列に対する操作は典型
    - こう言った場合、まず言い換えないとどうも手が出ないことが多い
- よって、数列上でのよくわからない操作（特に上記を満たす操作）が与えられたら、累積和列や差分列上での振る舞いを考える

## 例
- 隣に移動 -> x'i ＝ xi - i　の変換によって、同じ場所に移動
- 言い換えた後の問題の対応がわからない時: 元の座標で考えた後、結果だけを座標変換で移せばわかりやすい
   
<br><br>


<br><br>

# 転倒数
寄与の分解の仕方が複数ある。
- 数列の転倒数
- 全ての2要素単位での分解
- 全ての要素について、その要素が持つ転倒数を考える（転倒数列)


- 転倒数と順列は1:1対応しない
    - N! vs N^2ぐらい

- かつ、転倒数は距離のように扱えない
    - d(A, B) = d(A, C) + d(C, B)が一般には成立しない
    
> 命題 順列 $P$ について、
> $$Pの転倒数 = Pの逆順列の転倒数$$
- $x \in [a, b)$ のみ見た時の転倒数を、数列の区間転倒数に言い換えられる

<br><br>


### 言い換えが問題を難しくする場合もあり、後戻りも必要
- 言い換えを忘れて、もう一度考え直す姿勢が必要な場合もある
    - 条件は簡潔になっても、操作が複雑になってしまう...
    - ただしある程度の模索は必要で、やることがなくなったぐらいで戻ると良い(15分は長いだろう)

### クエリで情報を復元する問題
- 一部の情報がわかったら、その情報をクエリに盛り込むことで、今までよりも強力な情報を引き出せることがある
    - 特に、最小値や最大値がわかったときなど

- 必要な事: クエリ系問題/何かが明らかになったとき
- いつ考える: 常に
    - [1が分かる -> 単純な大小比較ができるようになる](https://atcoder.jp/contests/arc154/tasks/arc154_d)


<br><br>

# 実験
## サンプルが欲しくなったとき
手でやるよりも機械の方が漏れがない。かつ、そんなに時間が変わらない。
## 言い換えたとき
問題を言い換えたとき、言い換え先で元の構造がどの様に反映されるかは、機械でたくさん列挙して見た方が早い・漏れがない



## 入力が少ない -> 実験エスパー
- しやすい
- 手が出ない問題にも有効
- グランディ数が典型

<br><br>


# 数列への値の振り分け

## 最適化
振り分けのコストが単調増加なら、安い方から貪欲で良い
- それで、安い方からk個取るを達成できる

## 数え上げ

### 素因数の振り分け
数列の総積を考える時、約数ではなく素因数まで分解すると、素因数を振り分ける問題になる（かつ、素因数ごとに独立になる)

### 組み合わせ的な振り分け
- 振り分ける対象に対称性があるなら、コンビネーションに落とせるかも
    - dp[iまで][cこ振り分けた]からオーダーが2つ落ちる
    - [例題](https://atcoder.jp/contests/arc102/tasks/arc102_c)


<br><br>



# 数列の連続部分列
積極的に累積和/差分列の問題へ言い換える
- 一様ならば: 2要素への何かになる
    - 一般に、n要素より計算量が落ちやすい
            - [例題](https://atcoder.jp/contests/abc365/tasks/abc365_e)
        - 2要素への操作はグラフに言い換える典型
    - 言い換える時は、ちゃんと問題が丸ごと言い変えられる必要がある

- 生で見るより、言い換えた方が見通しが良くなる問題は確実にある
    - [例題](https://atcoder.jp/contests/arc129/tasks/arc129_d)


### 連続部分列に関する制約
- 左から決めていくdp
    - [0, r]に収まる制約を全て満たすような...
        - 違反する可能性があるのが、[?, r]しかないような場合
        -
- 区間dp
    - [l, r]に収まる制約を全て満たすような...
        - ある特徴的な要素の位置を決めると、そこを跨ぐ制約が全て無視できる場合
### 連続部分列へのクエリ
分割統治的な解法で解くことで、セグ木に乗せられる場合がある。
l = 1, r = nを分割統治で解くと良いだろう

### 数列の区間

#### 「区間が交わる」条件より、「区間が交わらない」条件の方が簡潔
 - 特に、関係は一意なので、右側 or 左側のどちらかに注目すれば良い
 - https://atcoder.jp/contests/abc355/tasks/abc355_d

### 区間 ⇔ 2d平面の言い換え
データ構造の利用・平面操作の利用を期待できる。
理由 : 区間(に限らず2値で大小関係が重要なもの)を、2次元平面上の問題に落とすことで、次元が増える代わりに問題が簡略化される。

#### 全ての区間についての計算
dp[r] := 右端 = rの区間についての答え (注 : [1, r]に収まる、でも良いが、単にこちらの方が制約が増える)
とするdpが成立しやすい
    - 理由 : 区間の計算について、どこかで"切って"考えて良い場合は、昔の結果を利用するという意味で上のdpが成立することが多い https://atcoder.jp/contests/arc169
    
<br><br>

# 順番に寄らない
好きな順番で決定できる。よって、dpと相性が良い。疑うべき。

   - 違反するような部分が無くなるように数列に操作...左から、「これより左に違反部分はなくて、かつ末尾の状態がSTATEのうち、操作回数が最小」等 P329
   - 交わる部分が無いように、数列を分割...前から分割を決めていく
   - 集合に0/1を割り振る ... 前の要素から0/1を決めていく

# 順番が一意にさだまる
sortして、前の方から決めていくdpができる。
- 影響が数式で簡潔に書けそうな時

- [例題](https://atcoder.jp/contests/abc366/tasks/abc366_f)
- [例題](https://atcoder.jp/contests/arc053/tasks/arc053_c)
    - Ai - Biの符号と Aj - Bjの符号で、議論が変化する
    - よって、混じったsortは無理そう
    - しかし、Ai - Biについて、符号が違うやつは混ざらないことが言える
<br><br>

#### 操作によって要素が独立になる
どんどん問題を小さく&&独立にしていける。dpと相性が良い。
また、独立性という観点から、グラフとも相性が良い。

#### 操作をすること自体にもコストが発生する
言い換え : [1]どの要素に操作をするか [2]どれだけ操作をするか
の2つを決めると思う。すると、構造がすっきりする。

<br><br>


# 単調増加
- 命題: Aが単調増加 ⇔ 差分列の要素が全て0以上
    - 他の条件も言い換えられるなら、問題が単純になる場合が多い
        - [例題](https://atcoder.jp/contests/arc023/tasks/arc023_3)
- 命題: 極値が存在しない ⇔ 単調減少 or 単調増加


## 区間についての単調性
- 命題: 尺取り法・二分探索ができる
    - 差分更新ができる時 / 区間クエリが独立に高速に求まる時
- 命題: 単調より、$\forall l$, 条件を満たす最小の$r$ のテーブルが求まれば、任意の [l, r]についてのクエリの情報が得られる
    - 系: 区間クエリに独立に答えられない時、尺取り法によってこのテーブルを前計算すれば任意の区間クエリが $O(1)$


### 等差数列
- 同様に扱いづらい
- 差分列を取ると、条件が"全ての要素が等しい"になる
- 及び、3項の場合
    - $x \le y \le z$について、 $z - y = y - x$
    - を
    - $2y = x + z$
    - や
    - $2y - x - z = 0$
    - のように、$y$が片方にしか登場しない形にした方が良い場合がある
    - 一般に、条件に含まれる = が一つなら、両辺に同じ文字が登場するよりまとめた方が単純？
    - [例題](https://atcoder.jp/contests/arc145/tasks/arc145_d/editorial)
        - 任意のx, y, zについて 2y != x + z
            - x < y< zを課さない方が考えやすい&&課さなくても良い
        - 2倍したやつが一致しない...
        - 3進数で0/1のみ

<br><br>


# 辞書順最小・先頭から貪欲
## 一般の枠組み
- 採用できる母集合を求める
- その中で最小のものを求める
    - 採用できる母集合を厳密に求めるのが難しい時: より広い集合をとって、小さい方から「採用できるか？」の判定問題を解く
- 値としてそれを採用する
- 値としてそれを採用する中で、まだ残っている自由度・それを採用する上での操作の自由度を整理する
- 制約にその自由度を加算した上で、次に進む...


- よくある勘違い: なんらかの制約によって、ある桁について見る時、あり得える母集団のうち最小値がとれない時
    - 最小値が取れないからといって、その桁を無視して良いわけでは無い。取れる値のうち最小値を取らなければならない
    - つまり、あり得る母集団のうちminする事が叶わないなら、2番目にする、3番目にする...としなければならない
    - 一般に、ある桁について、一意で無いならば、"無視して良い"と言える状況は少ないだろう

- 一般の枠組みを上に書いたが、一番難しいのは「1番目を小さくする上で2番目を最小に、その上で3番目を...」の制約が積み重なっていくところの処理
    - 2番目を最小に、その上で3番目...と、近い繋がりで全体が関係しているタイプ
    - よって、i番目の決定の際に、全体を考えなくても「i+1の番号の答えを決定するのに必要な情報」を持って探索・遷移しても良い
        - 結局うまくまとまらない場合もあるだろうが


## 桁dp


### 桁数を固定して探索する時、leading 0を認めない方が良い
認めてなんやかんやしようとすると頭がばくはつ
- 桁数の定義を変更する必要
<br><br>

### 操作の復元・構築
 - 結果のうち、極端な物を見る
     - そこに関与する部分の操作が一意に決まり、それによってまた"極端な物"が生まれる可能性
     - グリッドなら左上等
     
     
## sortする
言い換え :転倒数を0にする

<br><br>

# 転倒数
> 定義: 数列Aに対し、転倒数d(A) を $(i, j)$ のペアであって、$i < j$ かつ $A[i] >A[j]$ を満たすものの個数とする

> 命題: 数列 $A$ を隣接swapを繰り返してsortする時の最小のswap回数は $d(A)$

> 系: 数列 $A$ の各要素の並び替え $B$ について、 $A \to B$ に隣接swapを繰り返して変化させる時の最小回数も求められる

> 命題: 数列 $A$ にswapをした時の転倒数変化は奇数

転倒数は 
1. 各要素ごとの寄与に分解
2. 全てのペアごとの寄与に分解

の2通りの分解がある(2が都合が良いこともある)

## 転倒数と2d平面
- 数列 $A_0, A_1, ... $ に対し、 $(i, A_i)$ に点をおいた平面 $D$ を考える。
> 命題: $\forall i$, $A[i]$ が関与する転倒数 = $D$ 上の2つの長方形領域に含まれる点の個数
- 転倒数と長方形領域の点の個数が対応する。

> 命題: $A[i] > A[j]$ となる $A[i], A[j]$ をswapした時、$D$ の変化は $x = i, j$ の点の高さのswapである

> 命題: $A[i], A[j]$ をswapした時の転倒数の変化は、その2点を角とする長方形領域の点の個数 * 2 + 1

<br><br>


# k番目の値を求める

- dpしながら: topKを保持しつつ、配るdpではなく貰うdpで計算することでオーダーレベルで高速に計算できる
    - $O(KV\log K + V ^ 2)$

- shortest kth path(not DAG) : https://qiita.com/nariaki3551/items/821dc6ffdc552d3d5f22
    - $O(KV((E + V)logV)) or V^2ダイクストラで O(KV^3)らしい$

- kth takoyaki : 今順位が決定している集合と、それを一段回だけ悪化させたものを持って貪欲に決定していく。https://atcoder.jp/contests/abc297/tasks/abc297_e 


- 桁dp : 上の方の桁から決めていく

### 辞書順k番目
- 先頭から数字を決めていく。
    - 必要なこと:「prefixがoooである様な要素は何個存在するか？」を解くことになる。後ろが空文字列、つまり打ち切りという遷移が常にあり得ることに注意。
    - よって、これがすぐにはもとまらない場合、別途dpして求める等の必要性が出てくる
    

## 0 ~ k番目について列挙/計算...
> 命題: k番目の値が $x$ がわかれば、問題は 「値が $x$ 未満のものについて」 + 「値が $x$ のうち、kに届くまでについて」に分解される
- 後者は簡単なはず
- よって、[0, k]全てを調べるタイプでも
1. k番目の値を求める (この時、二分探索で行うならば値x未満のものについて調べる過程を経るはず)
2. 値 x 未満のものについて調べる (1 で使ったものを流用できる可能性が高い)
- と言うアルゴリズムができる
- 特に、2で用いるものは1でも用いるのだから、単にk番目を求める時と然程変わらない可能性が高い

## k番目までを列挙する
> 良い構造: $f(i, j)$ について、 $f(i, j) \le f(i+1, j), f(i, j+1)$
- これを満たす時、小さい値から列挙することを考える。すると、$f(i, j)$ を考えるのは $f(i-1, j)$ または $f(i, j-1)$ が列挙された後で良い
    - 列挙する時に調べる個数が $k$ の定数倍になる

> 系: n個の集合の和集合からtopkを求める場合、 $f(i, j)$ := 集合 $i$ で $j$ 番目の要素$ とすると、 $f(i, j) < f(i, j + 1)$ が成立することから、 O(n + k) この列挙で topk が求まる

<br><br>

# k乗和
- >命題: $(S + a)^k = \sum_{0 \le i \le k} \binom{k}{i} S^i a^{k-i}$
- これにより、k乗和の和は 0乗和の和 ~ k乗和の和
を持つことで計算できる
<br><br>

# 重複

### 重複に気づく為に
思い出す: dpが満たすべき条件
-  (重複を許さないならば)1つの探索対象が、dp重複して探索されないこと
    - ⇔任意の探索対象について、探索の任意の段階において、2つ以上の状態へと分かれて遷移することがない
        - 気づき方: 重複しやすそうな探索対象を一つとって、手でdpしてみる
            - ポイント: 具体例を持ってきて、実際に判定する姿勢
            - 例: (1, 2)を、要素数1の集合に分解した集合族の個数は？
            - dpで一つずつ集合に分解すると、 ((1), (2)) において、 $\emptyset$ -> (1)/(2) となり、最初の遷移で2つに分かれるためダメ


- 同じ数え上げ対象が、2つ以上の状態を持たないか
    - dpで持つ状態を増やすとなりがち
    - 特に、操作列の数え上げでは無く、数列の数え上げですという時
 

### 数え上げ: 重複なく数え上げる
これら全て、重複を省く: 1回だけ数えるというモチベの元の案である

- 重複がない <-> 全ての探索対象が、探索の各段階においてちょうど1つの状態に当てはまる
           <-> 全ての探索対象が、1回も分岐せずに最後まで探索される
    - 2つめを意識すると照明が楽なことが多い

- 考察 : **数え上げる対象 or notはどうやって判定するか？**
dpを考える時に基本的な考え方。基本的に、判定の過程で同じものが分岐することによって、重複は起こる.
    - つまり、分岐さえなくせれば良い
    - 分岐がないような判定方法をdpとする...
        - 部分文字列: 先頭から貪欲に採用する
    - 可能性を全て情報とするdpをする...
        - NFA -> DFAみたいな
        - 状態の集合を状態とする
            - [例題](https://atcoder.jp/contests/arc058/tasks/arc058_c)
            
- 一旦全てを区別するものとして数え上げながら、要所要所で掛けて区別しない場合に還元する
    - 集合の数え上げなど
    - 係数をかけられる必要がある
            
- 考察 : どういう時に異なるか?/どういう時に重複が発生してしまうか？
重複特有の考え方
    - **"異なる操作"を1stepとするdpを立てる**
        - 例: 選んでいくdpなら、
        - dp[i][State]...iまでみて...から
        - dp[i][State]...最後にiを選んで変化させた。State
        - にして、次に変化させるまで飛ばす（間で変化しない選択を何回なするかもしれない)
        - この時、遷移では"遷移で0回/2回以上変化する"遷移を許してはいけない。**数え上げるdpは常に最小単位で遷移しなければならない**。
            - 最適化は重複しても良いので、2回以上遷移しても良い(しかし、最小単位に満たないやつは事故りやすい)
        
    - 重複の方を数える
        - 部分文字列の種類数...SA + LCA
    
- **重複が発生しないようなルールを作る**
    - 数え上げる対象を具体的に一つとって、それが一意に・1回だけ数えられるようにdpの遷移を制限する
    - 必要な事: 各数え上げ対象が、dpの遷移のそれぞれの段階においてちょうど1回含まれる事
        - 逆に、これが満たされていれば他に懸念することはない
    - いつ考える: これも重複を省くスタンダードな方法の1つ
      
- 考察 : **数え上げの対象になるのは何か(視線を数え上げ対象に移す)
    - 判定問題になり、重複は最早関係ない
    - 数え上げの一般的なテクでもある

- 2つの集合から重複を省く : 母集団が大きい方を含め、小さい方から排除する方が楽
https://atcoder.jp/contests/abc361/tasks/abc361_f

### 否定と重複の関係
- 1箇所以上でooを満たす、を数え上げる際に「全く満たさない」を数え上げても良い
    - 1箇所以上の判定では、複数箇所満たす場所があった際に、素直なdpでは分岐してしまう恐れ
    - 全く満たさないならば、満たしたらoutを守るだけでおk


- tips:集合二分割していくdp
- 終わりを見ればわかる通り、集合の数だけ「切り出し方」に自由度があって重複しやすい
- 係数を途中でかけて調整も難しい
    - 個数ごとに切り分けるとしても調和級数logがかかる
    - 個数に制限ない時、最後に修正も無理
- 一意に分割するルールを決めた方が無難
<br><br>

### 操作: 同じ操作を2回しては行けない
- 集合を決めるdp

#### 同じ位置に2回操作をしてはいけない
- 極端な場所からやる
    - 区間について、左からやる事で lについて独立が保証される

### [0, r]を全て作れ
n進数(特に、2進数)
発展 : [0, r]を一意... 簡略化: rが2冪 - 1をまず考える。 解法例 : 表せない分は下駄を履かせた上で[0, r2]に帰着
発展 : [l, r]を作れ...[0, r - l]に簡略化


## 集合の数え上げ⇔数列の数え上げ
- 集合の数え上げをする時,
    -  並べ替えを全て数える
        - 並べ替えで条件の違反の可否が変化するものでもなければ、普通全て数えられる
    -  後から並べ替えの通りで割る
- という条件さえ守れば、数列を数え上げるとして良い
- 探索的に解くと集合に重複が発生してしまうという時、それを解消出来る
- 特に、集合の数え上げだからといって、小さい要素からadd/notを決めていくという事をしなくても良くなったりする
- [例題](https://atcoder.jp/contests/arc146/tasks/arc146_c)

<br><br>

# 小さい・極端な値の制約
- 小さいサイズの例では、小さい値の働きが良くわからない
    - 高速化も見え辛い
    - 小さい制約が出た時は、大きなサイズの例で考える
## その値を軸にした探索
- その値の1変化を軸とした時、探索はどのように記述されるか
- 状態数が小さい事は保証されているので、これが意味を持っていると嬉しい
## その値についての全探索により、情報を得る
- 答えのあり得る値が少ない時、あり得るか？を全探索...
- プレイヤーについて直接確率を求めるのが難しい時、盤面についてbitdpで確率を求めてから人について確率を求める...
- グラフのマスの個数が少ない時、それ、あるいは頂点のペアをkeyにして何かを計算する...

## keyとvalueのswap
- dpの値として入れる要素について、keyと比べてかなり大きくても良い。
- よって、小さい値をkeyに持ってきて、残りをvalueに入れると高速化になる


### 制約の列挙
意味のある制約だけを抜き出そうとせず、列挙してしまうと楽


#### 小さい値のキーについて、"意味のある分だけ一気に遷移する"ようなdpは悪手がち
- 別に、一気に遷移させる旨みがない
- dpが複雑になり、他の部分の高速化が見えずらい
- 問題の構造も見え辛くなる
[url](https://onlinejudge.u-aizu.ac.jp/problems/0537)



### max/min 
一般のk番目と比べ、場合分け的な発想により高速に求まる場合が多い

### 2, 3番目
max/2/3番目を全て管理することによって求める

### 全体・集合への条件
各2要素への条件に分割して、グラフアルゴリズム
    - 「辺で結ばれていたらng」...最大独立集合
    - 「0 / 1割り当て・罰金や報酬」...燃やす埋める
    
### 条件を満たす小さい集合の最大サイズ・合計スコア
答えの集合を全探索・半分全探索
  - 条件が「満たさないなら入れてはいけない」の時、集合の条件を2要素間の条件に言い換えられたらば、最大独立集合
  - 条件が「入れても良いが、入れたら罰金」みたいな時、フロー・燃やす埋めるの可能性
#### 一般化せずに、列挙するような条件変形
例えば、「木において、間に1頂点しかない」という条件を考える。
 ・距離 = 2 ... 2という小さい値を活かせない 一般の距離を求めらんないときつい
 ・実際の位置関係...  じつは数通りしかない。よって、それらを全探索する。

### 小さい方・大きい方から選べる
- マージテク

- 合計が定められている数列において、相異なるQこのペアのminの和
    - distinctであることが重要
    - https://x.com/SSRS_cp/status/1819732406972404184
    

<br><br>

# 差分を更新する計算
- 必要なこと: 差分の更新が高速にできること
- いつ考える
    - 順々に何かの値を求めていく時
        - 差分を取る以上、複数種類のを何個も求める時に良い
    - 毎回のクエリを独立に捌くことは、前計算込みでもできそうにないが高速化したい時
        - 特に、差分の更新さえ高速であれば良い。
        - 二分探索 <-> 尺取り法
            - 集合の要素を全て保持したい時、毎回集合の要素を1から拾っては間に合わないが、差分は小さい（合計変化が抑えられる）など

- 区間内の集合管理は、区間について何らか単調性があれば計算量が抑えられることが多い。単調性がなくても、激しく境界が動かなければ。
- [grundy数の計算...パラメータをちょっと変えて計算していく<-差分更新](https://atcoder.jp/contests/abc278/tasks/abc278_g)
    - 毎回高速にやるのは（mexの中身を毎回構築するのでは）無理
        - mexの集合の変化を考えると、せいぜい2n個ずつしか変化しない
        - セグ木でシュミレーションすれば、差分を更新する手法で求まる

<br><br>


# シュミレーション/判定

## シミュレーションを初期条件をちょっと変えて何回もやりたいとき
> 命題: 処理に共通部分があれば、それを共有することで高速化される

- シミュレーションで扱う要素が増える場合も多い。その場合、次の命題が有用。

> 命題: 要素の間に処理順で全順序が定まっているとする。この時、次のアルゴリズムが有用である。
> 1. 全ての要素を考慮した時のシミュレーションをする.
> 2. 1の過程で、ある要素を処理し終わった段階で、「今まで処理した要素で全てが尽くされる」ような初期条件に対し結果を反映する(ここが成功すればアルゴリズム成立)
- 特に、考慮する要素の集合 $S$ が $S \subset S' \subset S''...$ となっている時に成立しやすい

- 自分の要素を全て処理した際、本来入っていない要素も処理する可能性がある。その場合には、その本来入っていない要素の分を引く必要がある。
    - > 命題: 考慮する要素の集合 $S$ が $S \subset S' \subset S''...$ となっている かつ 要素の処理順の順序 と それぞれの要素が $S$ に登場する順番が同じならば引く必要がない

## 長いシュミレーション
以下では、遷移が一意なシュミレーションに対する高速化の手段を述べる
- 単に、シュミレーションせよと言われた時...
- 貪欲によって、判定問題の遷移が一意になった時...
## ダブリングによる高速化
> 命題: 状態と遷移が与えられたとき、状態から伸びる遷移が1本だけ: 遷移が一意ならば、状態数 $\times$ log step でダブリングができる

- 遷移が一意でないとダメ
- 状態のテーブルサイズが大きすぎるとダメ

## 状態の抑え方
- keyとなるイベントを状態として、その間は頑張って計算する

- "似た状態"が繰り返される時、その遷移のテーブルからk回を辿れる
    - 特に、それはシュミレーションの最初の状態を含むと良い

### 「初めて条件を満たす」までの遷移
- 命題: 遷移条件を「遷移後も条件を満たさない」にして最後に+1の遷移を自分ですると上手くいく
    - 条件を満たした後に追加で遷移されると困る
    - +1しなくても条件を満たしているかもしれない
    - +1しても条件を満たさないかもしれない（から実際に+1の遷移を別実装して試さなきゃいけない）

## ループを利用したショートカット
- ループがある事が必要条件
- ループに入るまでの距離・ループの距離によっては、ループがあっても利用できない
- ループに入るまではどこまでか・どこからループでどこまでループなのか・の処理がやや面倒くさい
- しかし、これでしか解けないタイプのものもある（計算量の話ではない)
  


## 同じ遷移をまとめる高速化
> 命題: シミュレーションにおいて、
> - 遷移の種類が切り替わる回数が少ない
> - 同じ遷移をどこまでするかが高速に求められる 

> の2つが満たされれば、高速に結果を求められる

- 種類が切り替わる回数が少ない <- 切り替わるたびに何かの値が指数的に増えていくなど
- 同じ遷移をどこまでするか <- その遷移をする条件を式にしたとき、単調性が出れば二分探索できる

## 定数回しか同じ操作をしないことによる高速化
> 命題: シュミレーションで行う $m$ 種類の処理について、各処理をする回数がそれぞれ $k$ 回で抑えられるならば、 高々 $mk$ 回の処理で終わる

> 系: 各種操作について、1回しかしなければ、高々 $m$ 回の処理で終わる

- $k$ 回について、「改善は高々1回で、合計で2回まで」のようなことはが典型
## シュミレーションを、数学的な値で表すことによる高速化
- 手順が与えられた時、結果を高速に求めろというのは難しい
- しかし、数学的な操作（和を取るとか、何かのsumがOOになるまでやるとか）で表せれば、高速化しやすい
    - 色を数字にするのはこの動機
    
## シュミレーションの特徴量を考える/前計算をすることによる高速化
- 愚直は自明なので、高速に求めましょうという時
    - いきなり解法について考える前に、前計算として有効なものを考える
    - シュミレーションで追うべき情報は何か
    - シュミレーションでロストしてしまって良い情報は何か？

## 何かの種類数が少ないシュミレーション
それを段階に全探索ができれば通る
たんｔちょう単調なうご動きをしているなか中でｚじょうｎん条件をみたすま満たすまで、をかんがえれ考えればよくな良くなりら楽

### 変化の回数が少ないシュミレーション
- 毎回求め直していては間に合わないという時、変化の回数が少ないならば、「今回変化するか？」をやる事で間に合う
  

## 途中まで単純な動きをするが、ある時点から変な動きをするシュミレーション

- 最初に変な動きになるのはいつか？が二分探索で求まりがち
    - 直前まで単純な動きをしていたと仮定した時、今変な動きに変化するか？の判定問題で二分探索


- 状態がまとまる...一つに扱える
    - 特に、まとまる条件に単調性がある時、「まとまる」をさらに「境界にある状態と同じ動きをするようになる」と言えたりする
        - これにより、状態が[1] 状態Xと同じ動きするやつ [2]最初から単純な動きしてるやつ の2つに分けられたりする
     
## 初期条件を決めたらシュミレーションの様子が一意に定まる
- 初期条件から結果を表せないか。特に、数式で表せないか。
- 取りうる結果の必要十分条件は？


## 動的に形を変化させるシミュレーションは遅いがち -> させなくてもなんとかなりがち
形を保ったまま重みの変更にで対処
- 例えば、木の辺が縮約される、配列がrotateされる...
- これらを素直にやると、大抵計算量が厳しくなる
- 実際にやらずに、必要な情報を得る方針で書くように努める


- 区間に対する何かしらの"変化"は、遅延セグ木で扱えがち
  
### 最適化

- 典型: 要素の並び順を決めたのち、シュミレーションに従って要素を振り分けていく...結果の集合を固定したら、大抵の場合その集合になるような並び順が存在する
 

## 無限に続くかもしれないシュミレーションの無限判定
- 大抵グラフのサイクル検出に落とす。ダブリングと同じで、状態の考察が重要。繰り返されるもの。
- 有向グラフ・サイクルがあるかもしれない...in[v]とout[v]を持つ。in[v]とout[v]の値で場合分け。


<br><br>

# 平面走査
何かを順に見ながら答えを求めていく
> 命題: 平面操作の過程で全探索をしたくなった時、その全探索がセグメント木に乗るならば高速に解ける
- 例: xを増やしながらyについて全探索したい -> yそれぞれについての値・集約がセグ木に乗るなら |X|log|Y|

> 系: 2d平面sumは、offlineであれば平面走査で $\log$ 1つで解ける

- 平面操作をすると、2dクエリが1dクエリに落ちやすい
    - 1つの次元についての制限を、単に「ここまでaddした時にデータ構造にアクセス」で済ませられる(逆元があれば)

- 平面操作は並行2分探索に使える

<br><br>

# 重実装・シミュレーション

- 書く前にサンプルを試す
    - 後から実装を膨らませないようにする
- 処理の共通化をする
    - 積極的に関数を作る
    - しかし、一つに統合できる関数は統合する(例 : add/delete )

- 枝分かれしないシュミレーションはwhile文で書ける
    - 速い
    
- クエリの重複
    - クエリごとに代表のクエリ番号とか付けるより、クエリそのものをkeyに答えを出して、それを後から還元した方が楽

- 長さを表す変数の値は変えない方が良い
    - [失敗例](https://atcoder.jp/contests/arc181/submissions/56364913)
-  処理に「中途半端な場合」と「纏めて処理する場合」の様に場合分けが生じる場合、「1stepだけ進める」処理を書いて、それの繰り返しで両方を表すことにすると処理が共通化される。


- 1回の処理で、どれだけシュミレーションを進めるか決定する

- 処理すべき対象：起こりうるイベントを列挙する
    - 1回の処理で、そのイベントが2回以上起こる場合をちゃんと処理する
        - 要素が直進する中で、要素がぶつかる... 2回以上一度にぶつかることは？

## 初期値が与えられるシュミレーション
- 初期値がノイズとなる場合がある
    - ある程度シュミレーションが進むと、ある動きに収束する
        - 初期値が極端な時は、それを補正するように動く
    - よって、シュミレーションの挙動を考える時、「ある程度シュミレーションが進むとどうなるか？」を考えると良い
   
- 必要な事: 初期値が与えられるシュミレーション
- いつ: とりあえず考えたら良いのではないか




- whileは、「条件が違反されたら処理の途中でもbreak」という関数ではない
- query関数の中に、回数でassert入れた方が良い

<br><br>

# 違反が無くなるまで操作する

> 命題: 違反が存在しなくなるまで操作する時、違反がある限り操作ooをするというアルゴリズムは、最終的にooをすることが確定しているなら正当である

## 1回違反から補正したら、あとは連動する

> 命題: 数列で、隣接項間で違反が定義される問題を考える。この時、一度「i, i+1間に違反が発生して、これを補正した」 => 「iに1回操作したらi+1に1回操作する。逆も成立」 が成立するならば、iとi+1をまとめて考えれられる。特に、1回操作をするたびにまとめが発生するので、処理回数が $O(項数)$ になる
<br><br>

## ２次元平面シュミレーション

- 大座標、小座標を使い分ける。0-indexedで座標を扱う。

- x, yで処理を共通化したい←点集合を管理する構造体を作る
    - [例題](https://atcoder.jp/contests/abc130/tasks/abc130_f)

- HWのサイズを持ったらダメだが、頂点に関しての情報を持ちたい
    - info_x[y] := i = y の頂点についての集合
        - のように、x, yごとに持つので十分な場合がある
        - 十分なら、サイズが大抵間に合う
### 点が動く
- 右に動く/左に動く　ではなく、　速度が+1/ -1 とする
    - 処理の共通化
    
- 速度が設定されている場合、速度ごとに点集合を分類して管理する
    - 一つの集合内で注目すべき点が単純化されたりする

- 特定のイベントが起こる時間の集合を得たくなった時
    - 数学的に処理する
    - シュミレーションでの出来事に言い換える
        - x座標maxの傾きが変化する→速度が違う点のうち、xがそれぞれmaxのものがすれ違う

- 最適化: 特定のイベントが起こる場合（例: 値の傾きが変化する), そこで時間を区切り、各区間内での答えをそれぞれ求める
    - 動きが単調になる
        - 三分探索できる
        - 数学的に求まる
        - 端だけ調べれば十分である

## シュミレーションの1遷移の条件をそれぞれ列挙
- 独立に記述できる場合シミュレーションの高速化に有利
    - 値がx以上 <- セグ木など

## シュミレーションせずに結果を得る
- 問題を解いた時、シュミレーションに帰着される事はよくある
    - しかし当然、シュミレーションじゃ無い方が嬉しい
        - そも間に合わない場合
        - のち後のもんだいｎ問題へのおうよう応用がわからないとき
- そういう時、シュミレーションの動きが一意なことを利用して、けっか結果のあたい値をこうさつす考察する/こうそくにえ／こうそくにえる順々に結果を得るのが必要になったりする
  
## 計算が必要になるまで、計算を（損するかも知れなくても）保留する
- 計算すべきになった時だけ計算することで、計算の回数が減る。
    - 必要なところだけ抜き出すのと同じ発想。途中損しても、計算すべき所で補正すれば結果的に損しない。
    - [食べたら強くなる <- 食べられなくなるまで強くなるのを保留する](https://atcoder.jp/contests/arc189/tasks/arc189_d)
## x, yで独立になるように言い換える
- 2次元では不可能に見えても、1次元なら意外といけると言う問題は多い
- そう言う時、次元で独立に問題を分解できると解ける
    - 独立なことは結構ある・言い換えで独立にする

<br><br>

# 平方分割の手法

## 数列・クエリをブロックにしてまとめる平方分割
### 数列
- セグ木における、層状の構造が現れない
    - これがメリットになる処理があった気がする

<br><br>



## 解法を切り替える平方分割
### 2通りぐらいの解法を考える
- クエリ問題
    - [1] クエリ個々に対する解法
    - [2] クエリ全体を、与えられた情報を走査することで処理する解法
### オーダーが小さい値を見つける→それをキーにした全探索
- 例えば： 調べるべき要素数が $B$ より大きい人は $\frac{N}{B}$ 以下
    - その人全体をテーブルに持ちながら走査する
    - 全探索に近いので、割と色々求まる


<br><br>

### 桁和
- A + Bで、i桁目に繰り上がる⇔ i桁目未満の和が B ^ i 以上
- A + Bで、i桁目に繰り上がる⇔A[i] + B[i] + carry >= B
  
<br><br>

### 01割り当て
- dp
- 燃やす埋めるの表現力は高い
        - 特に、燃やす埋めるは2要素間の制約 && ある集合について、「1つ以上が 0 / 1の時罰金」⇔「全てが0 / 1である時, 賞与」を表せることから、グラフ上の01割り当てと相性が良い。https://codeforces.com/contest/1082/problem/G

### 01 / 2値の高速化は ｂitset
- 存在判定 : 分布を陽に持たず、bitsetで分布を管理
- 足し算: xorに対応　並列的なアルゴリズム

#### 部分文字列を含むような文字列の数え上げ
部分文字列を**含まない**ような文字列の方が数え上げやすい、かつ典型的な問題がある。
https://atcoder.jp/contests/npcapc_2024/tasks/npcapc_2024_a

<br><br>

### ランダムではなく、順々で良い物
- 何かテーブルを更新しながら計算...
- bitの桁のループ : bit演算について、((1 << (新しい桁数)) - 1) - x はbitの反転を意味する

<br><br>



# 一致判定・ハッシュ
いつ使う: 一致判定の処理が重い時
重い一致判定は、ハッシュして扱うと一致判定及び記録が軽くなる。

大体のアイデア: 
- 1つの要素を比較するために、実際に比較しないといけないものがたくさんある
    - ->実際に比較する要素それぞれに値を割り振って、xorやmodでまとめてしまって、比較するものを1つで済ませる
## でかい数
- 素数mod

- 演算が * と / だけの時: logで管理
    - 少数にはなる
    - 評価すること: [1]元の数字から、logはいくつぐらいになるか [2]logがいくつ違うことを認識できれば良いか [3]その値は精度に収まるか
        - [例題](https://atcoder.jp/contests/arc035/tasks/arc035_d)

- ad_hocなでかい数の扱い
    - アイデア: でかい数を無理やり括り出す
        - 分数部分ができようとも
    - [例題](https://atcoder.jp/contests/arc047/tasks/arc047_c)
        - N! / k を (N-1)!でわる、(N-2)!でわる...
        - N! / kを、ｋ番目がかけたと思わずに、先頭に補正がかかったと思う
## 列
ローリングハッシュ
- 繋げるのは簡単
- 切り離すのは難しい
## 集合
zobrist hash

## 多重集合
zobrist hashを和にしたhash
- 集合のmergeが簡単
- [例題](https://atcoder.jp/contests/abc367/tasks/abc367_f)


## n個の独立なデータ（n次元の点)
次元と値ごとに独立な値p_xyを割り振って、そのxorを取る

## 木
文字列に単射を作って、その文字列でロリハ

<br><br>

# 差分更新
> 命題: 計算を複数回する時差分更新さえできれば全体を高速に求められる。この時、それぞれの計算が独立に高速にはできる事を要請しない。

- 特に、全ての種類のクエリの情報が必要な場合、1回事に求めるよりも差分更新の方がうまく行く場合が多い。
- 例えば: 区間prodを取る時、prodの範囲さえ小さければそれぞれについて求める元で対処できる
        
> 命題: 演算が+ではなくmaxであっても差分更新ができる
- 削除あり...それに対応できるデータ構造
- 削除なし...新たな要素でchmax

## 尺取り法
- 特に動き方が単調な時、動く回数が抑えられる

## Mo    

## セグ木
> 命題: 変更箇所が少ない時、セグ木にクエリが乗るならばセグ木で差分更新に対応できる

> 命題: 分割統治による解法がある場合、分割とうちの結果をセグ木で保存することによって更新すべき計算が $\log n$ 個になる

- 添字を値の大きさに対応づけるなどによって数列によるクエリ以外にも拡張できる。
<br><br>

# 要素の削除
定理：計算結果を要素の削除に対応させることは、追加に対応するよりも難しい
- 削除する予定の要素を使ってないものだけから集計することになるが、普通その様な物を計算しない（しようとすると状態量が増える）ので、逆元が使えないと厳しい
- よって削除に対応する時、「元からある程度削除されている状態で計算された情報」から要素の追加に対応する方が筋が良い
    - 全てを計算し直す必要はない。削除するにしろ、「削除を考えた上で絶対に使って良い要素」だけを使う計算を（多分全部の削除事にやったら間に合わないのである程度大味に）行う
### 1回しか削除しない(削除の種類は複数で良い)
- 命題: 要素[0, i) と [i + 1, n) を独立に考慮できるなら、iを削除した時の結果は [0, i) と [i + 1, n) の結果をマージする事で得られる
    - 変更であっても、[0, i) に新たにaddしたのをmergeすれば良い
    - 例: 1つ除いた時の集合minクエリ

### undoできる時
- offline dynamic connectivity

<br><br>

# インタラクティブ
> 命題: 極端な要素は他の要素より満たす条件が多い

> 命題: 極端な要素ほど情報量が多く、特定が容易い

> 系: 順に特定していくなら、極端なものから特定するのが簡単

> 命題: 情報を手に入れた時、それをクエリに用いることでクエリの情報に制約・構造が増える
- 例: 区間和クエリを考える。$a_0$ の位置と値がわかったならば、それを左端にすることで得られる情報が累積和になる


- 色々試して一番上手くいく方針を取るのが良いみたい
## クエリ回数の見積もり
> 命題: 有効なクエリの他に無効なクエリ（情報を捨てるクエリ）がある場合、クエリ回数は 有効なクエリの総数よりも多い
- よって、定数倍が厳しいときは、スカをなくす（情報を捨てるクエリをなくす・全てのクエリで情報を使える方針にする）必要がある

## 2分探索
> 命題: 1要素を特定したい時、その要素が含まれる集合（つまり候補の集合）のサイズを割合で小さくしていけるなら、それをクエリ返すと特定が $\log$ のオーダーで求まる
> 系: 候補の集合を $S, T$ でサイズについて2分割した時、そのどちらかに絞れるなら $\log_2$回

- 単調性がある => 二分探索できる　が、単調性がなくても良い
    - 例: 01列に置いて、0と1がこの順で隣接するところはに分探索で求まる


補足: 特に、集合に関するクエリが投げられる時は候補に上がる
- 特に $S, T$ 2分割について
    - 乱択と組み合わせることが多い
    - 必ずしも $S, T$ 間の情報を聞く必要はない
        - $S$ と 他の何かを比較するのが筋が良い場合もある(真にゼンタイ集合を $X$ として、 $X\setminus S$ とか)

- 1つの方針にこだわらず色々試してうまく行ったものをつかうとよい 
- 何かがわかる事を仮定して、そのうえでかんがえる 
    - 例: 全てのクエリの答え
<br><br>


# 前計算
> 命題: 計算するものの種類数よりも計算回数の方が多い場合、あらかじめ前計算しておくことで計算量が落ちる

> 命題: メインのループの中で計算量をかけて計算する値を前もって計算して置けるなら、その計算の分の計算量が落ちる
- dpの遷移とか

- 特に、値を求めるのが一度きりではないと言うときに使える

- 前計算のオーダーは計算するものの種類数に対して線形
    - 前計算は使いまわせた方が良い



## 情報の共通化
- 条件を満たすかの判定に用いるとき、個別の条件に対して前計算は難しい
- > 命題: 要素ごとに値を振り分けて、条件を「値がv以上」の様にすることで、前計算はその値の計算だけで良くなる
    - 例: [l, r)に点がない/ [l, r)に点が1つ以上 -> [l, r)の点の個数を累積和で持ち、点がないの判定を「点が0個以下」にすれば共通の前計算で処理できる。
    - 前計算の情報量を増やしているとも考えられる(可能かのbool値 -> 評価値 int64_t)
    
- > 命題: パラメータを固定した時の条件に対し、パラメータ依存部分を無視してもそれが意味を持つならばパラメータに依存しない前計算ができる
- 例: $g$ で数直線を二等分した時、両端から取っていく動きが最適 -> 両端から取っていく動きを、終点を全探索しつつ探索できれば良い -> 単に両端からとっていく動きを前計算

## 情報の補正

- 前計算したものを修正しつつ、クエリの答えを高速に求められる場合はある
    - 前計算依存部と依存しない部を式の上で分けると良い
- この時、前計算には個別のパラメータが必要な部分は含まない方が良い

- 例: 要素数 $n$ の配列 $A, C$ があるとする。その時、前計算 $O(n \log n)$ / クエリ当たり $O(\log n)$ で次のクエリに応えられる
> 整数 $x$ がオンラインで与えられる。 
> $$\min_{i} A[i] + |C[i] - x|$$
> を報告



<br><br>





## 再帰関数・ループがある場合
- 正当性を考えるのが難しい
- seen[v] := vからの探索を始めたことがあるか のほかに、 done[v] := vからの探索が終わったか　を持って、seen[v]の時にdone[v]の値で場合分けすると良い。
- uを探索の途中、vに関する値が欲しくなってf(v)を読んだが、seen[v] = trueだった場合
    - done[v] = true:
        - 探索が終わっていて、値が正しく求まっている
    - done[v] = false:
        - v -> u -> vと状態が遷移してきたことを意味する。多くの場合、この事実を元にuの値も求まる（無限に循環するとか、サイクルに含まれるとか）
        
<br><br>

# 推定
要素a, bをランダムに取ってきた時、a, bは似たような振る舞いをする。
- 集合 $S$ をランダムに・何らかのランダム性のある手続きの末に取った時、 $a \in S$ の確率 = $b \in S$ の確率
<br><br>

# 乱択
> 命題: 確率 $p$ で成功する事象を成功するまで続ける時、回数の期待値は $\frac{1}{p}$
- $p$ を保証できれば良い

## 条件を満たすものを見つける
- 必要なこと
1. 条件を満たしているかの判定ができる
2. 発見確率がある程度抑えられる
- 特に、どうすれば見つかるか？どのような解か？考えないで良い

- 例: 原始根

<br><br>

# misc

## LCS
> 命題: 列 A, B に対し、  
> |列Cであって、A, Bを共に部分列として含むものののうち|C|がminであるもの| = |A| + |B| - |AとBのLCS|
- 証明: CからA, Bを復元する時の添字集合をとり、添え字が共通するものを取るとそれは共通部分列である。つまり、|列Cであって、A, Bを共に部分列として含むものののうち|C|がminであるもの| $\ge$ |A| + |B| - |AとBのLCS|。等号成立は構成すれば良い。


## 複数の要素の中で、ある1要素の振る舞いが知りたい
- n ^ 2個全てを見なくても、ある要素 * n の n通りの関係を見れば良い
かつ時間を他のnこの区間全てに対し計算してsumを取れば良い
    
- 1d/点の縮約
    - range set
   
- 1秒に重みがある時
    - 幅で考えると分かりずらい? 
    - 下の図のような考えで![alt text](<images/スクリーンショット 2024-12-16 23.22.01.jpeg>)
    - [i, i+1) について決めるときは、大体i + 1のところから見る（右端について半開区間)
    - 終了までi秒あるのは、i)の区間を決めるとき


## あり得る、という条件や言葉は言い換えた方がよし
- > 命題:  同値な言い換えとして「存在する」で言い換えられる場合が多い
    - そもあり得るの定義より
    - あり得る、だといつあり得なくなるのかなどをいちいち考える必要性が出る


## でかい数

- log なんか
- 掛け算しかない かつ　かける数字は $k$ で一定 ... x * k ^ ? の形で持つ