# クエリ


## 逆元があるクエリ
例えば sum [l, r] -> sum[0, r] - sum[0, l-1]
- クエリの次元を1つ落とせる
    - クエリの個数が定数倍増えるだけで、かつ次元が落ちる
    - 常に考えて良さそう




## 何を管理するか考える -> 出力クエリに応えるのに必要な情報
- 出力クエリを計算するのに必要な情報のうち、管理しやすいものだけ管理すれば良い
    - 必要のない情報はロストさせて良い
    - 特に、言われた通りそのままシュミレーションする必要はない
    - 何が管理しやすい? <- 勘
     

## 配列のスライド
- dequeを使うと O(スライド幅)
- 全体+1とかできる

## 置換は合成ではなく代入・かつ、区間作用では一様な置換が存在しないかも
左側では 0 -> 1, 右側では 1 -> 0があり得る。
素直に現物を管理するのが良い。


## 似たような計算の、パラメータを変えた物を何回もする時
- 個別に求めずに、テーブルを作ってしまう
    - k番目を直接求めるより、1, 2, 3...と求めていった方が一般に楽

- 特に、寄与に分解した時、分解した先で必要になる情報が似た形の場合が多い上、この発想に至りづらい


### 補集合クエリ
- oo以外の総和
    - 全体 - oo
    - オーダーが落ちる

## 加算クエリ
逆元を使うと、素直にデータ構造を変形させなくて良くなる場合が多々ある。

## swag
区間prod無理そう

## 各要素1回しかクエリが来ない・意味のあるクエリが1回だけ
- 愚直に1つずつやっても間に合いがち
    - 意味のあるクエリが1回 -> 代入クエリであって、その先が定数とか



## 状況やデータ構造に変更を加えるようなクエリ
- 命題: 状況やデータ構造が一致するようなクエリにはまとめて答えられる
    - 命題: クエリの種類ごとにまとめて答えれば、データ構造へのそれぞれの変更を1回だけやれば良くなる
    - クエリ毎にデータ構造を変更する必要がない
      
## データ構造雨が持つ値に追加の情報を与えたい・場合分けしたい時
- 1つのデータ構造で頑張るのではなく、追加の情報毎にデータ構造を持つようにすると上手くいきやすい
    - データ構造を上手く改造する試みは難しいといった方が良いか


## マージテク
> 命題: マージテクをするならば、任意の要素 $x$ について $x$ が挿入される回数は $\log n$ 以下  

> 系: 全体の挿入の回数は $n \log n$ 以下  

> 系: 要素ごとに挿入のコストが変化する場合も、 全体の挿入のコストは $n \log n \times \text{max insert cost}$

<br><br>

# static query
> 定義: 変更クエリを全て処理したのちに取得クエリがくること
- そうではないものをdynamic queryと呼ぶ事にする

> 命題: 数列への変更クエリにおいて、変更クエリを与えられた順のままセグ木に適応するのは dynamic query
- それで処理できないなら、static queryにのみ使える手法を検討

> 命題: クエリの順番を入れ替えても結果が変化しないなら、順番を入れ替えても良い

> 命題(差分更新): static・区間変更クエリ・最終結果配列取得の場合、以下のアルゴリズムを考えられる。
> 1. 適切なデータ構造を構築する。
> 2. i = 0 , ... , n-1 の順に答えを求めていく。この際、iが進むごとに、また、変更クエリの範囲にiが出入りするたびにデータ構造を更新する  

- この時、計算量は $O(\text{データ構造の構築コスト} + \text{データ構造の変更コストの総和} + n \times \text{求値コスト})$
- 差分更新さえできれば良い。 $i$ 事に独立に求める必要はない。

<br><br>

# offline query
> 定義: クエリが前もって与えられること
- そうではない(あるクエリを処理すると次のクエリが与えられる)ことをonline queryと呼ぶ

> 命題: クエリで与えられる値を前もって取得する事で、座標圧縮ができる

> 命題: 数列への変更クエリにおいて、変更クエリを与えられた順のままセグ木に適応するのは online query
- それで処理できないなら、offline queryにのみ使える手法を検討

> 命題(時間軸 分割統治による、staticクエリへの還元) : offline ならば、次の再帰関数を考えられる
> 1. f(l, r) := 時刻[l, r) に収まるクエリを処理する。
> 2. f(l, (l + r) / 2), f((l + r)/2, r) を呼ぶ。
> 3. 時刻[l, (l + r)/2) でのクエリについての、時刻[(l + r)/2, r) への寄与を処理する。この時、寄与はstatic queryの形をしている。



<br><br>




<br><br>

# 2次元
- (x, y) / [l, r) 等、2つのパラメータを持つものは2次元平面上の問題に言い換えると議論が簡単になる場合がある


## 疎な2次元平面
- 座標圧縮 -> 全探索
## 2次元クエリ
- 2つの情報(a, b)に対応するクエリに答える状況

- 平面操作
    - aについて全探索しながら、データ構造を更新して、それによってbを答える
    - 必要なこと: 
        - bが指定された時、結果を求めるのに必要な情報の更新が高速に出来ること
            - 往々にしてセグ木
    - いつ考える:
        - 2次元クエリなら割といつでも
        - 区間である必要はなく、(t, x)だったりすることも多い
- Mo
    - 必要なこと: 
        - a, bの値域のはばをN, クエリ数をQとして、 N√Q * (伸縮)が間に合うこと
            - 特に、(a, b)が区間である必要はない。
    - いつ考える: 
        - 伸縮が高速
        - 平面操作ができない
## バラバラな区間クエリ
- 区間add。ただし、配列Aに対し A[i] = xを満たすiにだけadd
    -  配列の値ごとにセグ木作って、構造体に「これは足す対象か」のフラグを立てる。

- 配列を区間にadd。ただし、スライドしていく
    - 各要素について見た時、加算する対象が区間になっている。 O(addする配列の長さ log )でもできる。![alt text](<images/スクリーンショット 2024-12-06 19.21.34.jpeg>)

- 順列を見ていく。seg[v] := P[i] = vとなるhoge。「値がP[j]が以下、かつ添え字がi以下であるようなseg[P[j]]について」
    - セグ木を全部分用意して、「値が空 <-> 単位元」とすれば良い。値が小さい方から見ていけば、値の大小の制約は無視できて、添字はprod。

- 配列のバラバラ要素sum
    - バラバラの種類数が少ないなら、差分更新の考えで計算量 O(クエリの種類数)
## 点が密集していない
- ブロック分割 <- それぞれの領域の点の個数が抑えられる
    - [距離K以下の点を列挙](https://atcoder.jp/contests/abc234/tasks/abc234_h)

<br><br>