## 概要
d進数表記の整数に対し、dの冪乗の形のadd/subtract,及びmsbクエリをサポートする。
参考:いつかのcodeforcesのeditorialのコメント
verifyのリンク先から観察できる様に、定数倍はやや重い。

## コンストラクタ
**MSB\<int d\> msb**...  d進数で値が0の整数を作成する


## 関数
以下、操作の過程で管理している整数xが、0でない桁を最大でn桁保持したとする。
- **add(int a)**...x += d^a
    - 計算量 償却 $O(\log n)$

- **del(int a)**... x -= d^a
    - 計算量 償却 $O(\log n)$
    - 制約 delの後、xは0以上で無ければならない。違反した場合の動作は以降未定義


- **top()**...最上位bitの位置を返す。x=0である場合、-1を返す。
    - 計算量 $O(\log n)$

- **bottom()**...最下位bitの位置を返す。x=0である場合、-1を返す。**未verified**
    - 計算量 $O(\log n)$

- **is_power()** ... 今のxがd ^ ? の形かを返す。**未verified**
    - 計算量 $O(\log n)$


## 使い道
[1] msbクエリ
[2] $x \ge d ^ a ⇔ msb(x) \ge a$

## 解説
S[a], T[a]共に D^aの桁に関する情報を持つ。
ここで、Sは正の係数、Tは負の係数を持つ。
つまり、
S[a] = b の時は b*d^a
T[a] = b の時は -b*d^a
だけxへの寄与を持つ。
この様に、負の係数を追加で管理する事によって、繰り上がりやくり下りの際のデータの大規模な変更を防いでいる。

また、msbクエリに答える事を目的に、このデータ構造は以下の制約を追加で持つ。
**Sに登録されている桁の最大値をM, Tに登録されている桁の最大値をm とする。 この時、 M > m + 1**
これによって、Tによる繰り下がりを考慮した上で、msbを高速に求めることができる。
## 計算量解析
ポテンシャル関数$\Phi$を、自然数の定数$a = \frac{5}{B-1}$を用いて以下で定義する。ここで、操作の過程で管理している整数xは、0でない桁を最大でn桁保持したとする。
$$\Phi := a \times (Sの値の合計 + Tの値の合計) \times \log_2n$$

### insert(a)
insertは再帰関数である。今、insert(a)を呼んだ結果、$1$以上の整数$k$を用いて合計で$k$回insertが呼ばれたとする。
$$ (実計算量) + (\Delta \Phi)$$
$$ \le(5 + ( - a(k-1)(B-1) + 1)) \log_2n$$
$$ = ((5 - aB + a)k + aB - a + 1)\log_2n$$
$$ =(\frac{5B}{B-1}) \log_2n$$


### del(a)
delも、insertと同様の計算から、
$$ (実計算量) + (\Delta \Phi)$$
$$ =(\frac{5B}{B-1}) \log_2n$$

### balance(a)

