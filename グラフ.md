
# グラフ


扱うのが得意な構造:

[0]独立性
[1]2要素の関係
 - 2項方程式についても、グラフで表現することができる。
 - 2部グラフに出来ない⇔奇数長閉路が存在する

[2]状態の遷移
ともに、独立性を顕にし、かつ操作や遷移を辺として表現できる。
- 操作の最小回数

歩道: 辺列であって、グラフ上で辿れるもの  
パス: 歩道であって、辺の重複がないもの  
単純パス: パスであって、頂点の重複がないもの
閉路: 単純パスであって、始点と終点が一致するもの
## パス
> 命題: $a \to b$ の歩道が存在 ⇔ $a \to b$ の単純パス であって、元の歩道の部分集合であるものが存在
- 証明: 
1. 歩道 -> パス
辺列について、2回以上登場する辺が存在する限り、その辺の区間を両端を含んで消す
2. パス -> 単純パス
点列について、2回以上登場する頂点が存在する限り、その頂点の区間を [, ) の形で消す

## 閉路
> 命題: 始点と終点が一致する歩道が存在する時、その歩道は閉路に分解できる


## 取り敢えず全域木を取る
- 0: 連結なら良いという時、木の方が扱いづらい
- 1: 端（葉）から順々に考える(構築していく)のでも上手くいくという時、全域木をとってから考えると上手く構築できる。
    - 特に、制約が「後から修正できるタイプ」の物（総和とかmodとか）だと、「部分木の結果を見て、根を調整する」のような手順で解ける場合がある

- 2: グラフの全てのパスの長さについて考察する時、あるいは、頂点を塗り分けるという時、全域木をとったのち各頂点について深さを求めておくと、その深さの値を用いて議論ができる場合がある
    - 例: 2部グラフ判定　深さ mod 2が異なる頂点を結んでいるかどうか？
    - 特に、ある頂点vを始点とするパスについて調べたい時、vを根として取る
 
## 木における2頂点u, v
u, vを引っ張って両端に持っていく。u-vパス上 or notに分かれる。
パスが一意であるという性質から発生する諸々を理解しやすい。
- 例: 頂点 i, j, kがこの順で並んでいるか？
    - ⇔パス(i, k)上にjがあるか？
    - ⇔ dist(i, k) == dist(i, j) + dist(j, k) (ここで、辺を引っ張る考察を用いた)

## 連結成分数
- 間にパスがある頂点を同一視する時、頂点の種類はいくつかという事
    - 頂点と状態は対応するので、頂点 -> 状態 の言い換えをするとわかりやすい時がある
- 或いは、到達可能という同値関係で頂点を割った時の商集合のサイズ
    - よって、 u,vに辺がある条件より、u -> vに到達可能な条件の方が近い
    - 連結成分数計算の1個の解法として、 $\forall v \in V,$ $v$ から辿り着ける頂点の数 の分布がわかれば、(無向グラフで到達可能は⇔関係だったので) それから上の式で寄与をまとめて計算できる
        - 完全グラフの時の頂点のキヨ: 辿り着ける頂点数(自分を含む) を $c$ として、 $-\frac {c-1}{c}$ のキヨ（たしあわせてnから引く）

- > 命題: 連結成分の部分グラフは連結とは限らない
    - 部分問題になりづらく、dpしずらい
- 基本的にキヨに分解したりして、何か別のものの数え上げにする

- u, vに直接辺がある条件を考えそのグラフ上で連結成分数を(uf等シミュレーション的な解法・その構造の考察から)考えても求まる
    - グラフそのものに良い構造があるときは、そっちを使う
    - 超頂点も使う
        - 常にまとまって辺を張られる => 1本以上辺があるとき、先にまとめた頂点に張るとして良い        
- 積極的にキヨに分解したい

## 強連結成分
> 命題: 有向グラフにおける2つの強連結成分 G, H について、次の何れか一方が成立
> 1. GとHの間の辺は、全て G -> H の向き 
> 2. GとHの間の辺は、全て G <- H の向き 

### 到達できるか
多始点1終点ならば、1始点多終点にした方が良い。
- 無向グラフにおいて、到達可能性は同値関係である。そして、1始点多終点は計算量が良い。

## 同じ属性を持つ任意の2点への辺
- 属性を頂点にすることで、へんの本数を減らせる場合がある
    - 頂点と辺が入れ替わることもある

- 頻出: y座標を表す頂点とx座標を表す頂点で2部グラフ

## 頂点倍化
### 計算量
> 命題: dfsの計算量は O(V + E)

> 命題: dijkstraの計算量は O((V + E) \log V)

> 系: 計算量を見積もる時、頂点数と辺の本数を別々に考えれば良い

> 命題: 頂点を増やすと辺も増える
- 頂点数が抑えられるからと言って満足してはいけない。特に、普通辺の方が多い
- 頂点を $k$ 倍したら、辺も最悪で $k$ 倍になる


### 超点倍化・計算量削減
- 辺の本数の合計が抑えられれば良い
- 多くの頂点倍化は(v, 追加情報) のペアを新たに頂点とする
- ここで(v, 追加情報) から伸びる辺/遷移を、その追加情報が必要なものだけに限ると、辺を全てコピーした時から本数が減る

## 橋
- サイクルに含まれる⇔橋では無い
- 同じ辺を使えないパスを考えるとき
    - パスが端を含む⇔辺素なパスは1種

## 複雑なsort/トポロジカルsort
全順序ではないが、「aよりbは前」のような制約がたくさんある状態で制約に違反しないように並べ替えたい時はトポロジカルsortする
- 閉路があるとダメ
- なお、トポロジカルsortの数え上げは、一般には難しい
- 隣接項にしか制約が無いとかだと2乗時間

## 最短距離
- > 命題: 最短距離が存在 ⇔ グラフに負閉路が存在しない  
- > 命題: 1 -> n の 頂点v を通る時の最短距離は、 1 -> vの最短距離 + v -> n の最短距離
- > 命題: 1 -> n の 辺 u -> v を通る時の最短距離は 1 -> uの最短距離 + v -> n の最短距離 + u -> v の辺の重み
    - 最短距離の独立性
   
   
## potential
任意の長さ $n$ 配列 $p$ に対し、グラフの辺 $i \to j$ の重み $c$ を $c' = c + p[i] - p[j]$ としたグラフ $G'$ を考える。この時、
> 命題: 任意の歩道に対して、
> $$G での歩道の重み = G' での歩道の重み + p[歩道の終点] - p[歩道の始点]$$
証明: 計算すれば良い(打ち消し合う)
注意: 特に、始点と終点が同じ時、
$$G での歩道の重み = G'での歩道の重み$$

> 定義: $\forall Gの辺, c' \ge 0$ となる $p$ をポテンシャルと呼ぶ。

> 命題: グラフ $G$ にポテンシャルが存在 ⇔ $G$ に負閉路が存在しない  

証明:   
(<=)
p := $G$ における、任意の始点からの最短距離配列
とすると $p$ はポテンシャルとなる

(=>)
対偶を示す。背理法で示す。$G$ に負閉路が存在する時、$G'$ 上でその閉路を辿ると重みは $0$ 以上になるが、これは $G$ で負閉路であることに矛盾。

# 全域木
## 最小全域木
> 命題: 重み最小の辺は使って良い

- 使うことを決めたら頂点を縮約(つまり、連結なものを結ぶ辺は無視)と言うアリゴリズムが正当

## 最小最大重み全域木
- 定義: 重みmaxの辺の重みが最小
> 命題: 重み最小の辺は使って良い
- 同じアルゴリズムで得られる


## 最短経路木
- 定義: 頂点vを根とした時、v -> any への元のグラフでの最短距離を維持した全域木
> 命題: 存在する
- 閉路がある限り終わりを切る
- dijkstraで辺を残していって求まる


## 最短経路木(経路 = 重みmaxの辺)
- 定義: (u, v) について、経路コスト = $\min_{全てのu->vパス}(\max(パス中の辺の重み))$
とした時、全ての (u, v) について元のグラフでの経路コストを維持した全域木

> 命題: 存在する

- 構成
> 補題: その様な全域木が存在するならば、元のグラフで重みminの辺集合は閉路ができない限り使う必要がある
あとは縮約すれば良い(重みが増加するのでして良い)
1. 辺重みがminの辺を採用
2. 縮約して1に戻る
- を連結になるまでやる

## 次数が小さいグラフ
- 無向グラフ
![alt text](<images/NBMetadataCache.jpeg>)

- 有向グラフ
![alt text](<images/NBMetadataCache 2.jpeg>)
# フロー
psp(頂点2つの選択肢、最適化)
辺cut, 頂点cut

- 特定の要素をなるべく使わないflowを流したい時
    - s -> その要素 の辺を外したflowと付けたflowで2回やると良い？


## フローがあるなら貪欲がある
- らしい
- グラフを構築 -> そこから発想
    - 特に, maxflowならグラフが改善していく様子を、わざわざ探索せずにやる
        - maxflowなら頂点増やして再度流す、が許される   

## グラフアルゴリズム・頂点/辺の削減
ベースアイデア: 2要素間に辺を愚直に貼らずに、代表的を表す頂点を作って、 (辺を出す側の集合) -> (代表頂点) -> (辺が入る側の集合)
とすることで、辺の本数を(要素)^2から(要素)ぐらいにする。

- 必要なこと: 変形したグラフを用いても答えが変わらない事
    - もとの問題でその辺が表すべきだった状況が、変更後のグラフでも表せていれば良い
 


## クリーク⇔補グラフ
> 命題: クリークである ⇔ 補グラフで独立集合

及び、

> 命題 2部グラフである ⇔ 独立集合2つに分離できる

より、問題を二部グラフに落とせたりする

## 同型
> 定義(一般グラフの同型): グラフ (V, E) と (V', E') について、順列Pが存在し(P(V), P(E)) = (v', E') となる時、またその時に限り同型という
- 直感的には: グラフを変形させたら形が同じ


> 定理(根付き木の同型): 同型 ⇔ 根に繋がる部分木の集合 が一致 
- 直感的には: 子を並び替える操作を繰り返して、形を同じにできる

> 系: うまくハッシュを取ることによって、木のハッシュは全ての根に対して $O(N)$、同型判定は $O(\log N)$


<br>

## psp(maxflowで解ける)
- 必要な事
    - 2値の割り当て
    - 2要素の制約/ all要素がooの時... 
- いつ考える
    - 最適化・判定
    - 要素が絡み合っていて、dp出来なさそう
    - 2値の割り当て
        - 使用する・しないもこれに含むので、結構広い


## mcf
「使用回数」に制限がある要素があって、その要素の使用でスコアが得られ、そのスコアをmin(maximize)したい時

<br><br>

# マッチング
$E' \subset E$ であって、 $E'$ の誘導グラフの最大次数が $1$ であるもの
- 応用例: ペアにしてよい要素に辺を張った時のグラフにおいて、ペアにできる⇔マッチングが存在する
## 完全マッチング
$E' \subset E$ であって、 $E'$ の誘導グラフの頂点集合 $V'$ が $V' = V$ を満たすもの


これによって、例えば「全ての要素を、制約を満たしつつ何かとペアにする」と言った問題設定は、単に「制約を満たす完全マッチングを作る」の様なグラフ理論の言葉で表すことができる


## ホールの結婚定理
$2$ 部グラフ $G$ が完全マッチングを持つ必要十分条件が $1$ つ知られており、ホールの結婚定理と呼ばれる

> 系: 数列A, Bを並び替えて $\forall i$, A[i] $\le$ B[i] とできる ⇔　$\forall x$,  (Aのうちx以上の要素の個数) $\le$ (Bのうちx以上の要素の個数) 
- アルゴリズムとしてはsortして確かめれば良いが、考察の上では上の方が簡単

## 最適なマッチング
> 命題: 直ちにマッチングさせて良いものが $1$ つ以上ある時、それをマッチングすることを繰り返して最適なマッチングが得られる


- マッチングの貪欲の証明は、最適解をおいて相手をswapすることが多い


## 具体例
> 命題: 色 $i (1 \le i \le n)$ のボールが $a_i$ 個ある。ここで、違う色のボールをマッチングさせる時、マッチング成立数の最大値は以下で表される
> $$ \min (\sum a_i - \max a_i, \ \lfloor \frac{\sum a_i}{2} \rfloor) $$  
証明:   $\lfloor \frac{sum}{2} \rfloor$ を超えるやつがいなければ、そこからペアを1つとっても超えるやつがいないようにできることを言えば良い。ただし、 $sum = 3 \to 1$ の場合 のみこれは成立しない。 ($n \ge 3 \lfloor \frac{n}{2} \rfloor$ の成立条件を調べよ) 
<br><br>

# 木

## DAGと木は違う

1 -> 2 -> 3
---------------->
のように、擬似的なサイクルができる
- 到達可能頂点の数え上げでコレが効いてくる(重複する)

## 性質
> 命題: 木の誘導グラフは森
- 連結成分数 = 1なら再び木

> 命題: パス長 <= 2 * 深さ
- 木の高ささえ低ければパスクエリは高速に捌ける。しかし、木の高さを恣意的に変更する術は一般には無い
    - auuxiliary treeが一応それだが...

> 命題: 連結成分数 = |V| - |E|
- 木であれば、頂点の個数と辺の本数がそれぞれ分かれば連結成分数がわかる

- 部分木について、処理したり中身を固定したりした部分木を一つの頂点とみなす事で再帰的に残りの(頂点数が少なくなった)木について解法を適応できることが多い
## 木DP
- 木についての全探索
- 全ての頂点についての値を求めるのではなく、「全ての部分木についての結果」を求めている
    - 木全体の結果は手に入る
    - 頂点同士が互いに制約を与え合うという時、木全体についての制約の結果を求められる
        - 全ての頂点については求めることはできない
        - 全方位にすれば良い


> 命題: 部分木ごとに独立な問題になる場合、木dpで再帰的に値を求められる
- 部分木の値はどこでも良い
> 命題: 部分木ごとに関係性がある場合も、その関係性の決定に必要な情報を持ってdpすることで再帰的に求められる
- 関係性の近い列のdpのようなもの

## 木DPの設計

### よくある
![alt](<images/IMG_0056 .jpeg>)
根が常に2つ（高い根、低い根）しかなくて、これをよくやる
- 今までの部分木・新たにつける部分木の状態を場合分けして、dpテーブルを作る
    - 往々にして、「高い根の状態」と「新たにつける、低い根」の状態を全探索して、そこから次のテーブルを作る


## 2乗の木DP
木dpのテーブルのマージにおいて、サイズ $n$ と $m$ をマージする際
- $O(nm)$ ... $O(|V^2|)$
- $O((n + m)m)$ ... $O(|V^3|)$
である。
    - よって、下記の書き方をしてはいけない。特に、マージ後のテーブルのサイズが $n + m$ になると言う時、それ + テーブル $m$ を走査すると下記の計算量になる。
    - ほとんどの場合、 $n$ 通りの何かと $m$ 通りの何かを全探索すれば事足りる。よって、そのような書き方をする。
  

### 木に辺が増えていく時
mergeテク

### 木dpで、mergeの計算量が「小さい方の部分木のsiz」
mergeテク

#### dpで、mergeの計算量がsiz * siz
愚直にやってもN^2

### 木の頂点が色や値によって独立に分類されている時
圧縮木


### 部分木に対する操作・制約
- オイラーツアーすることによって、数列の連続部分列に対する制約に言い換え
- 他の事柄も言い換えられれば、あとは数列に対する問題に
    - 基本的に、楽になる

### パスの数え上げ
- 頂点vをlcaとするパス、で木dp
- 頂点vを通るパス、で重心分解
- 条件を言い換えて別に帰着


## root -> v の情報(for all v), 差分更新
- dfsするだけ
    - 差分更新的にできて、複雑なクエリもできる

## staticな木に対するクエリ
- 逆元があれば、 query(u, v) = query(root, u) + query(root, v) - 2 * query(root, lca(u, v))


## 列上のパス
> 命題: 始点と終点を固定すると、左移動の距離 - 右移動の距離 が定まる

<br><br>

# トーナメントグラフ
> 命題: ハルミントン路が存在

> 命題: 強連結　⇔ ハルミントン閉路が存在 

> 命題: 強連結成分分解するとパスになる

> 命題: 強連結成分数 = Gの片方が空でも良い頂点集合への分解 (A, B) であって、 AとBの間にある辺の向きは A -> B の向きであるものの数 - 1
- 強連結成分数を寄与に分解できる
    - グラフGと条件を満たす分割 A, B について、(G, A, B) を数え上げれば良い


<br><br>

# pruferコード
> 写像 $p : (n \ge 2) 頂点ラベル付き木 \to \{0, \dots, n-1\}^{n-2}$ であって、次の対応を取るものをprufer 写像と呼ぶ。また、木 $T$ に対し $p(T)$ を $T$ の prufer コード と呼ぶ。
> 1. S = {}
> 2. $n > 2$ である間3, 4を繰り返す
> 3. 次数 $1$ の頂点のうち、ラベルが最小のものを $v$ と置く
> 4. Sの末尾に $v$ と隣接する頂点のラベルを追加し、 $T$ から $v$ を削除する



> 補題: $S \in \{0, \dots, n-1\}^{n-2}$ に対し、$p^{-1}(S)$ に含まれる木の次数列は一意であり次の表示を持つ。
> $$d[v] = 1 + (S中にvが登場する回数)$$
証明: アルゴリズムを追うと明らか

> 命題: $S \in \{0, \dots, n-1\}^{n-2}$ に対し、 $|p^{-1}(S)| \le 1$  

証明: 次数列は補題により得られる。それを元に、次のアルゴリズムで元の木が一意に復元される(アルゴリズムが終了できなければ存在しない)。  
1. 2, 3を k = 0, ... , n-3 で 繰り返す
2. d[v] = 1であるvのうち、vが最小であるものをv'と置く
3. 木に (S[k], v) を追加し、 d[v] -= 1, d[S[k]] -= 1とする
4. d[v] = 1である v がちょうど 2 つ残っているので、それをu, vとおいて (u, v) を追加する




> 命題: $n (\ge 2)$ 頂点の木 と それらが生成するpruferコードの集合 に全単射が存在する 

> 命題: $p(n (\ge 2) \text{頂点の木が生成するpruferコードの集合})$ = $\{0, \dots, n-1\}^{n-2}$  



証明: 任意の $S \in \{0, \dots, n-1\}^{n-2}$ に対し、$|p^{-1}(S)| = 1$ を言えば良い。 $n$ に関する帰納方より示す。  

$n = 2$ で成立。

$S \in \{0, \dots, n-1\}^{n-2}$ を任意に固定する。この時、$\exists v \in \{0, \dots, n-1\}$、 $v \notin S$ 。
$v$ の中でラベルが最小のものを $v'$ と置く。  

 ここで、 $S' = Sの初項を無くしたもの$ と定義する。すると、帰納方の仮定より、 $p^{-1}(S')$ がただ1つ存在(ラベルがズレるけど良い感じに補正する)。この木について
 1. 頂点集合に += $v'$
 2. 辺集合に += $(v', S[0])$  

 をすると、新たな木が $S$ を生成する。

> 命題: $n(\ge 2)$ 頂点の木の集合と $\{0, \dots, n-1\}^{n-2}$ には全単射が存在する
 
> 定理: $n (\ge 2) $ 頂点のラベル付き木の個数 = $n ^ {n-2}$
- n = 1でも整理する。

> 定理: $n (\ge 2)$ 頂点のラベル付き木であって、次数列が $d$ であるものの個数は
> $$\
f(d) =
\begin{cases} 
\dfrac{(n-2)!}{\prod\limits_{v} (d[v] - 1)!} & \text{if } (\forall v, d[v] \neq 0) \text{ and } \sum\limits_v d[v] = 2(n-1) \\
0 & \text{otherwise}
\end{cases}
\
$$

証明: コードの方を数え上げれば良い。次数列がd ⇔ コードが dの分布列(ただし、回数-1する) になっている