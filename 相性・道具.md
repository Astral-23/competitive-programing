例題を書く時は
[何が嬉しくて解けるのか](link)
の形が良さそう
- 必要な事...その解法を使うのに必要な条件
- いつ使う...特にその解法を使うと良い場面

問題を解いて何かしら手応えがあったなら、「何が新しいのか」を考えた方が良さそう
(単に問題の性質の羅列だと、同じことばっか言ってて真に面白い部分を見逃しそう）


解法 名前だけ覚えてもカス
いつ（何が嬉しい）・どうやって（何が必要）
- いつ・何が嬉しいかがわかれば、そういう状況で解法を思い出す動機
    - かつ、その嬉しいが達成されてなければ、解法を採用できていないことに気づき、嬉しいを達成するよう修正に迎える
- 何が必要か・何を考えるべきかがわかればそれを揃えようと思う
例えば: 再帰的に構築する <- なにがひつようやねん
取り敢えず埋めていく解法なので、適切な条件と、1stepを定めれば回る
いつ...貪欲無理、あえて固定うまくいかない

## これは何
問題を解く際は、相性の良い道具を用いて考察することでより問題の良い性質を反映した・すっきりとした議論を行えるという事が多々ある。
よって本説では、 性質 : 道具　の対応を並べる。


<br><br>

**良くあるパターン:次元が落ちるような言い換えは非常に役に立ちやすい。**
         - 数列について、[l, r]が7の倍数、など
数式 https://hackmd.io/aQrfqrLIQxabjpiwcTLSIw

<br><br>

# 全探索

## 全探索の設計
いつ考える: 問題がよくわからず、とりあえず何かを固定したい・全探索で解きたい時
特に、数え上げにおいては、「わからないなら何か固定してみる」がかなり強い。どうせ全探索する。

- 1: 素直に、対象全てを（問題文に言われた通り）全探索する。あるいは、探索する対象の一部を全探索し、他の部分はまとめて計算することを狙う
    - -> まとめるdp

- 2: 対象する探索が必ず持つ特徴に注目し、その特徴の値で場合分けする。
    - 必要な事: 全ての探索対象がそれを持つ（そうで無いと全探索にならない）
    - いつ考える: 一部を全探索するという事。考察が進まないのでどうにかしてまともを全探索したいが、まともな対象がパッと思いつかない時にこれを考える
        - 特に、対象が持つ極端な部分に注目する
        - [どんな切られた木だって根を持つ<-根の高さで全探索](https://atcoder.jp/contests/abc290/tasks/abc290_g)

- 3: とりあえず初手の結果を全探索して、問題が小さくなってないか眺める
    - 小さくなっていたら -> 再帰的に解くdp


### 全探索できるものは全探索
固定してしまうということ。
- 最適化: 常に全探索を考える。O(1)で結果を出そうとしない。
- 特に、何も手がなくなったらとりあえず全探索を考える
    - [例題](https://atcoder.jp/contests/abc369/tasks/abc369_f)
        - 条件を違反⇔右上の関係がある
        - これをちゃんと判定しようとすると、 $O(N^2)$ の他、高さでsortして単調増加かを判定が出てくる
        - この判定を考えなかった場合
        - hを下りながらセグ木でシュミレーションできる

## マッチさせるような全探索
- 全て固定しては間に合わない -> 一部だけ固定して、その結果を突き合わせるような全探索
- このとき、「付き合わせられる条件」について、それぞれについて独立な方が良い
    - 特に幾何。図形の点を指定しては間に合わない -> 傾き一致でまず絞って、その中でやる
    - このとき、条件式が（それぞれについて独立な値） = (それぞれについて独立な値）　となるような特徴量で分類する。
    - [例題](https://atcoder.jp/contests/abc220/tasks/abc220_g)
    
## 条件を満たすものだけ探索 -> より広い集団を探索
- 必要: 条件を絞ったものだけを見る探索では無理そうで、より広い範囲を探索しても、間に合う
    - 特に、条件を満たすかの判定を今度はする必要がある。よって、その判定法に則って探索するとか。
- いつ考える: 「条件を満たすもの」が掴みづらい時
    - [Kの倍数だけ探索 -> 難しい 整数全てを探索することにして、桁ごとに埋めていく](より広い範囲を探索しても、間に合うなら求まる)
        -  桁dpすることにすると求まる


## 状態数絞った探索が厳しいなら、状態数を増やす
**究極: 上手く解く方法が思いつかないなら、計算量間に合わなそうでも全探索を考る**
- dpで遷移が上手くできないなら、状態全て持つ全探索を考える
    - 例えばinplace dpのように、テーブルとループが大きくても高速に計算できるケースはある。
    - [例題](https://atcoder.jp/contests/arc115/tasks/arc115_e)
    - このような場合、遷移をいつも以上に積極的に数式で表現すると良い

- **問題を解く上で注目している要素の計算が難しいなら、他の要素に注目する**
    - **特に、判定問題を綺麗に解けたとしても、その計算に必要な要素の管理が難しいなら、別の(もっと多くても良い)要素で判定問題を解き直せないか考える**
        - **最初の解でうまく出来なかったからと言って、判定問題を元に解くという姿勢を捨てない**
    - [dp[w] := 今w個では解けないので、情報を追加](https://www.facebook.com/codingcompetitions/hacker-cup/2024/round-1/problems/C)
        - 最小の要素によって、遷移が変わる
            - dp[w]で求めるはずもない
                - 本質情報をロストさせてはいけない
            - ちゃんとdpw[x] := wを最小として経験、xが今　から出発して、計算量削減を考える
    - [例題](https://atcoder.jp/contests/arc181/tasks/arc181_d)
        - 転倒数は、prefix maxを更新する要素の個数で表される
            - しかし、prefix maxを更新する要素の管理は難しい
        - そこで、他の（もっと多くても良い)要素を用いて、転倒数を表せないか考える
            - 各要素の持つ転倒数に注目(転倒数列)

## 探索範囲の絞り方
- 探索範囲の必要条件を考える

- 最適化:答えを固定したとき、それを改善する手法があるなら、改善できる限りするとすることで「改善ができない状態」だけを探索すれば良くなる
    - この時、改善の条件が緩いほど、改善できない状態が少なくなる
        - 例えば、1回の改善の幅が小さいと「その幅さえ残っていない」ものだけ調べれば良くなる
        - その条件がだせないと意味ないけどね
        - [ブロックをズラす"幅"を小さくする](https://atcoder.jp/contests/arc131/tasks/arc131_d)
            - 間隔Dで並んでいるとして良い
            - 距離ND単位で動かすことで改善できる
                - 右端の座標が 0<= x <= 2ND
                - まだデカすぎる
                - 絞りを強くしたい <- 小さい幅の改善を考えよう
            - 距離D単位で動かすことで改善できる場合がある
                - できない場合だけを考える
                - どういう時？
                - 左右の個数が同じある時
            - 左右の個数が同じの条件より、右端の動く範囲がDぐらいに収まる
### ooしてはいけないという制約の言い換え
ooしてはいけない⇔xxあるいはqq
等と言い換えられると、後者を用いて全探索ができる。
- [例題](https://atcoder.jp/contests/arc049/tasks/arc049_c)
    - タイプ2 を全探索して単純にしたい
    - しかし、制約は常に守られるものなので、選択の余地などない
    - [1]塗る頂点全探索(2^20)
    - [2]制約2を「uを塗らない or uを先に塗る」と言い換え、どちらにするか(2^10)

### 全探索の軸の工夫

- 大きい方から埋めたい && 位置も考えたい
    - 挿入dp
    - 区間dp


## 探索的に無理そうなら、必要条件を考える

### 答えを全列挙する実験

- 特徴がある→なぜその特徴が生まれるのか考える
    - それによって、一般にその"特徴"を拡張できたりする
        - grundy数の実験
        - 
- 特徴がある→その特長を全て含む様な探索ができるか？
    - できるなら、探索範囲をそれに絞って仕舞えば良い
        - [例題](https://atcoder.jp/contests/arc099/tasks/arc099_b)

### 計算量削減につながる必要条件
- 0/1列であって、1が2つ連続しないものの個数
    - [フィボナッチ数列](https://x.com/e869120/status/1386138990361726978/photo/4)
    - 2 ^ len から 1.5 ^ len ぐらいまで落ちる


## 高速化
[here](https://hackmd.io/xcx7zFLXQdGE4tdth5_5nQ)

## 他
- 数学的な考察が難しそうなら、dpを考えるのが有効
    - 全探索するということ

<br><br>

# 独立性とは
互いに関わらないこと。
独立とは: 複数の要素/操作について、一方が取れる状態・自由度が、他方の状態に全く関わらない・依存しない。あるいは、影響しない。
- もう少し具体: 複数の要素/操作について、その要素同士で絡み合うような制約がない/お互いに操作によって干渉することがない/その二つの操作の結果として条件が満たされる・違反される事が無いということ。

- 勘の部分: 絡み合うより、独立に考えられた方が良い
    - 例えば集合関数について考えるとき、F(S) = sum f(要素) で考えられたらとても嬉しい
- この時、互いが互いに全く依存しないので、「独立な物同士で別々に前計算してそれを掛け合わせる」ことで場合の和を、「maxを取る」事で最適化を...とうとう、全体を計算できる
    - 嬉しい: 全体をまとめて計算するより計算量が落ちる
        - dpで言えば、個別に計算して最後に合算するように設計することで、独立なパートそれぞれについて状態数が S, Tである時、持つべき状態数が S * T から S + Tに落ちる
        - これに限らず、非自明な高速化がたくさんある

        - [条件の式変形（固定では無い)により、独立を作る](https://atcoder.jp/contests/arc075/tasks/arc075_c)
            - S[r] - S[l-1] >= (r - l + 1)k
            - -> S[r] - kr >= S[l-1] - kl + k
            - 左右で独立になった（変数が独立)
            - 別々に計算して、組み合わせられる
        - [独立なものの中であり得る形を前計算しておいて、それを当てはめるとすることで、1つずつ要素を追加していきながら条件を判定より計算量が落ちる](https://atcoder.jp/contests/abc352/tasks/abc352_f)

- 複数ある操作、特に2次元の操作について、縦の操作と横の操作を独立に考えて良いというのは頻出である。
    - 必要な事: ある操作/要素が、ある制約については全く影響を及ぼさない事
        - 一つの操作が、それぞれの制約にどのように影響するかを考える必要がある
        - [グリッドの辺の塗り分け -> 塗り方が特殊なので、段ごとにの操作について、段が違う物同士で制約違反することがない。つまり、取れる状態について、弾が違う物の状態に依存しない。](https://atcoder.jp/contests/arc166/tasks/arc166_c)
            - 言い換えはあまり
            - 段が違う2つの操作の結果として制約が違反されることはない
            - 独立に計算して掛け合わせるので良い
        - [グリッドから出るという条件](https://atcoder.jp/contests/agc033/tasks/agc033_b/editorial)
            - 縦or横がはみ出ると言い換えられる
            - 縦移動・横移動では、それぞれ一方の制約に全く関わらない。つまり、独立になっている。
             
    - 他、関係のある物同士で分離して考える事で構造をよりわかりやすくする目的でも独立による分離が行われる(考察上の旨み)
        - 前計算に該当する
            - 嬉しさ: 「絡み合う状況がない」ということから、状況が固定化される
            - 嬉しさ: 「操作がどのような影響を及ぼすのかわからない状況」が、多少わかるようになる
        - 関係のある物を線で結んだ時、同じ連結成分に入る物の規則がわからなかったら、それも考える
            - 関係のある要素同士で考えるのが旨みなので、どういうのが入るのかわかっていなかったら意味がない
            - [そういう姿勢が必要な例題](https://atcoder.jp/contests/arc184/tasks/arc184_b)
                - 同時に同時に集合に追加されうる要素を辺で結ぶ
                - 同じ連結成分に入るのは？
                
        - [操作による制約への影響がなく、その制約を忘れてしまって良い](https://atcoder.jp/contests/abc277/tasks/abc277_f)
            - 行/列の操作と、行/列の制約がある
                - 行swapは、列の制約に全く関与しない。よって、行の制約を満たすことだけを考えて自由に行swapして良く、またそれだけを考えれば良い。
                - 同様に、列swapは、行の制約に全く関与しない。よって、列の制約を満たすことだけを考えて自由に列swapしてよく、またそれだけを考えれば良い。
                - よって、独立な2つの問題を解けば良い。

    - また、独立という事は相手の情報を持たなくて良いという事であり、コレがdpあるいは探索の高速化に用いられる
        - 特に期待値を求める場合に頻出
        - [順々に処理しながら、独立な成分毎に対処](https://atcoder.jp/contests/arc065/tasks/arc065_b)
            - 共に連結とは
            - Aで連結 / かつ Bでも連結と思う
            - まず、「Aで連結」を処理してしまって良い。つまり、Aで連結である物同士だけであとは判定すれば良い
            - Bでのグラフも作って、その中でAでの無向グラフ同士で見ていく。
            - 別解: 制約が「かつ」で結ばれているが、それぞれは独立に判定できる。よって、連結成分ごとに番号を振ることで、その番号をペアとして融合することでモイクラロワクラロワ知判定として処理できる。

        - [次元毎の加算操作は、次元が異なる毎に独立なので、純菜bんを入れ替えても良い](https://atcoder.jp/contests/arc151/tasks/arc151_d/editorial)
            - 次元毎の加算操作(各次元について、一つの次元の値が異なるもの同士での加算操作)は、注目する次元んが異なる操作について、独立に見て良い。つまり、互いの順番に関わらず結果は等しい。

        - [遠い要素間での繋がりが繋がりが薄い -> 隣接要素間の制約だけで状況を表す](https://atcoder.jp/contests/abc209/tasks/abc209_f)
            - 加算は隣り合う要素だけ
                - 全体的に順番が絡み合うものの、しかし、ある要素に注目した時、並び順がスコアに与える影響が直接隣り合う要素との順番にしか依存しない
                - 最適である条件を、「隣り合う要素が」だけの形で表せないか？
                    - それでも全体の順番の絡み合いは表せるし、かつこうした方が楽
                    - maxから取る等の貪欲で最適にできそうだが、数え上げなのでコレはあまり役に立たない
            - 削除で必ず費用が発生するので、それを先に取り除こう
            - 残りのキヨはどのような形で表せるだろうか？
            - iについて、iをi+1より先にやったら+H[i+1], そうでなければH[i]
            - 隣り合う要素感での順番が必要十分条件
                - 他、2つ要素を挟んだら、その両側での削除の順番は独立であることからも、最適を1つ取る->左右で、i,i+1より先にやるやつをallやる...とかでも証明ができる
            - 区間dpが無難ではあるが、今回「ラストをi番目に挿入できるか」がわかるので、「最後の要素がどこに行くか」で簡単に解ける
    - 影響範囲が狭いという意味での独立性もある
        - 近い範囲の情報しか持たなくてよく、dpが立てやすい
        - よくある問題の形

## 関わりがある要素に辺を張っておく
- すると、辺が無い要素間は「関わりがない」或いは「関わりが薄い」と言うことになる
    - よって、新たに「辺が無い要素間」について成立することがある場合がある
    - 特に、「辺がある要素同士」だけではなく、「辺が無い要素間」で成立することの考察をするべき

    - [辺が無い要素について、同時に3つ以上爆破は無理 -> 全探索可能](https://atcoder.jp/contests/kupc2024/tasks/kupc2024_b)
        - 1回の爆破で連鎖するやつを辺で貼る
        - すると、その要素同士では「x, y ともに素」になる
        - 新たに爆破したところで、3つを同時に壊すのは不可能
## 直接の関係が近くにしかない時
![alt text](<images/kankei.png>)
- 直接の関係は近くにしかなく、その関係によって全体が関わり合っていると言う状況

- dp[i][State] := [0, i]だけを考慮した。Stateには
    - その時の全体の答え
    - その結果に対応する $i$ 項目の状態
- を持つ。 dp[i] -> dp[i + 1]は、 $i + 1$ 項目の状態を固定しつつ、 $i$ 番目の状態から全体の答えを補正する
- と言う枠組みのdpが一般に使えそう
    - 特に、新たに考慮する要素 i + 1 と関係があるのが i　だけと言う状況が良い。i + 1 と i + 2の関係は保留し、Stateに残された「i + 1の状態」から計算する。


## 分けて・独立に計算して最後に集約する。
- パラメータpを動かしながら f(g(a1), g(a2), ... , g(an)) をそれぞれのpについて求めたいという状況は頻出
    - 答え決めうちながら判定、最適化など

- この時、pを最初に固定するのではなく、要素を固定したのち、その要素の振る舞いだけに注目することによって高速化がなされる事がある

- 必要な事: 1要素に注目する考察で答えに辿り着ける事。他を無視する事で高速にもとまる事・「似たような要素」についてまとめる事で高速に計算できる事・既に計算したものの再利用
    - 特に、全体としてはfの結果は複雑だが、個々の g(ai) のpの変化に対する振る舞いは単純・単調・区間になっている時

- いつ考える: パラメータを固定しつつ、n要素についての判定をする時。上記を満たしそうな計算をする時。
    - 各a1, ... ,anが独立に振る舞えると特にやりやすい。
    - max(pを動かす時の, max(a1, a2, ... ,an)) -> 要素を固定し、各aiについて、aiが最大になる時の値を求めて、最後にそれをmaxでたたむ

    - pを動かす（この時、a1, ... , anが全て条件を満たすか?) -> aiについて、条件を満たすpを列挙して、合算
<br><br>

# 何かを固定する考察
問題の整理・言い換え寄り

- 簡略化と似たようなことをする
    - 簡略化は制約を削るが、こっちは固定して増やす
    - 固定した上で、別々に問題を解くという事。

- 必要な事: 固定した問題がまず解ける事
    - 固定は解法の前提になったりする要素ではあるが、そもそも固定しても解けないならその固定の線はダメ
    - 
- 以下を踏まえ、**何かを固定したら、その固定による前計算や、新たに言えるようになった事、状況の変化を必ず考える事**
    - これが旨みの大部分
        - 高速化という一面が大きい時もあるだろうが
    - 例えば答えの固定

- **[旨み1]: 制約や自由度が絡み合っている時、固定した上で影響を前計算する/片方の自由度を貪欲により消滅させることによって、固定したものに関わる制約/自由度を前処理・無視できる・固定されてない方の自由度が消滅する場合がある**
    - 複雑になっている・多様性を産む要素について、その分岐を無くす・一意に決定づける
    - 固定すると一意になるのだから、固定した上では最適化を考える必要がない　ー> 実質的な問題の要素の消滅
    - 自由度と結果の距離を近づける

    
        - 結局は結果の自由度は残る。しかし、操作の自由度より、結果の自由度の方遙かにがマシなことが多い
        - **特に、結果に単調性がある時、二分探索は大したボトルネックにならないので初手で行うのが良い。**
            - 本当に単に問題から要素が一つ減るだけなので
                - 何も効かなかったら外しても良い
            - 操作は目的からの距離が遠い:結果は近い。近い距離で考えた方が遙かに楽。
            - **また、そもそも操作がDAGの構造をしておらず、「作れる集合は何か？」を先に解けないとdpすらできない場合もある**
        - 往々にして、"最適になるように操作をしろ"は、最適がなんなのかわからず、どう操作をしたら良いかわからない
    - また、良くあるものでは、結果の一部を固定することで、操作が一意になる/作れる結果の集合がわかる
        - **2段階あった自由度が1段階だけ考えればよくなる**
            - 問題の後半部分だけ解いたイメージ
        - 目標が定まった時の操作が簡単に表せるなら、結果を全探索することの方が簡単だったり

        - 固定した時の答えさえ求まれば、あとはその固定したパラメータを動かすだけの問題になる
            - 複雑性の消失
            - 特に、[1]固定した上で前計算したことにより、複雑性の消滅した議論 [2]パラメータの動かし方の議論で済んでいるように、**複雑性を一切無視し、独立に議論できている**ことに注目

    - **ooの制約さえなければ一気に求まるというときに、ooの制約を外す為に、ooの/制約が関わる部分を固定する**
        - ooの制約を前計算することによって、省ける場合がある
        - ooに関わる値を決定する
        - ooでないという形なら、値を固定してしまう
        - 前と同じように、ooの制約のせいで複雑になっている状況が、**ooを固定・前計算して省くことによって、全く無い時と同じ議論ができることに注目**
        - あとは、固定した部分の動かし方だけ
        - 特に、数え上げでよく出るシチュエーション
        - 無視した（簡略化した）問題なら解ける、という場合に、それに持ち込む手段でもある

    - **制約/処理であって、満たされ方に選択肢がある場合、どのように満たされるのかを固定する**
        - 答えが出れば、満たされ方を動かすだけ
        - あるいは、綺麗な形（数式等)で出れば、どの固定の仕方がbestかわかる
            - 例: 絶対値 |a - b|について
                - a > b ? a < b? の2通り
                - 大小関係を固定！
            - 例: a - b mod M について
                - a > b or a < b さえ固定すればmodが外れる
                    - modは外す 
        
    - **(各要素について)複数の選択肢があるという時に、片方の選択肢を取る方の集合を固定する**
        - どっちを取るべきかすらわからないという状況から、動かし方がわかればあとは片方の固定の仕方全探索に落とせる

- **[旨み2]: 絡み合っているものについて、絡み合っている原因を固定することで要素が独立になり、それぞれについて計算したのち合わせるといった方法で計算できるようになる**
        
- 独立とは、絡み合うような制約がないということ。
    - そのようにできない"中途半端な"固定/絡み合う制約が残る固定は旨みがなく、上手い固定ではない。
    - よって、もっと上手い固定をしなけらばならない。
    - 式を書いて、片方の係数を固定するなど。
    

- **固定に限らず、複雑さが生まれている時、その複雑さが消滅するような要素・ケースから注目すると良い場合がある**
    - 良い場合とは
        - 大抵、極端な要素
        - 複雑さを生まない・一意な要素を先に処理して、除外
        - 他の要素が新たな「複雑さを生まない要素」となって、繰り返し！
        - 処理できるケース・要素を処理する/解ける場合・わかる要素を先に解く、という典型かも

    - 複雑とは？
    - 一意でない、変化が未定、判定のために情報を大量に持たないとdpできない...


     - [切れ目を固定](https://atcoder.jp/contests/arc055/tasks/arc055_c)
         - 文字列の分割の数え上げ
         - 典型: 切れ目をどっか全探索する
         - 今回、Bは割と自由度が高く設定できる
         - よって、他さえ固定して仕舞えば計算できそう
         - ACを切り分けた時の場合の数を考えて、解ける

   - [1: 絶対値の制約の固定](https://atcoder.jp/contests/arc117/tasks/arc117_d)
        - 絶対値の制約...どちらが大きいか？で自由度がある
            - これがややこしい
            - この自由度を固定するには？
        - 値の大小関係を全てについて定める
            - その場合の答えは？
            - 貪欲にギリギリ
            - 定式化すると、距離を足す
            - 帰りの距離だけいらない
            - 直径

    - [2: 絶対値の制約の固定](https://atcoder.jp/contests/abc163/tasks/abc163_e)
        - 各要素について、絶対値の符号を実際の値にかかわらず決定してしまう
            - これで得する事はない
            - 絶対値が外れることによって、単なる数学になり貪欲になる
            - どっちの符号に振り分けるかを全探索
                - 持つ情報は少なく済む
    - [絶対値の制約の固定 (+差分列への言い換え)](https://atcoder.jp/contests/arc178/tasks/arc178_c)
        - 全ての2ペアの絶対値差
            - Bをsortedとして良い
            - 絶対値が外れた
        - 条件: 単調増加が増えた
            - 扱いづらい
                - 端から決めると未来に制約がかかる・独立じゃない
            - 差分列に言い換えたい
                - 未来の決定分を先に計算するモチベでもある
            - スコアを式変形で言い換えるのは難しい
            - 主客転倒: (B[i+1] - B[i])は何回足されるか？
                - スコアが綺麗にもとまった
                - ナップザック
                - なお、無理やり式にしなくても、頑張れば解ける
     
    - [1: 買う品物と順番の2つの自由度<-品物を固定した時に注目して、順番の自由度を消す](https://atcoder.jp/contests/abc288/tasks/abc288_e)
        - 品物固定したら順番解けないかな？
            - 今までに買った品物に対し、次買う品物を好きな位置に挿入することで、任意の購入順で買うことができる
            - つまり、自分より小さいやつをj個買うなら、おまけ金額は区間から選べる
        - これをdpにすると解ける
         
    - [3: 目標の固定(変更) <- 解けるようになる 単調性より目標に分探索](https://atcoder.jp/contests/abc246/tasks/abc246_g)
        - 最適にしろ
            - どうしよう
        - 目標決めて二分探索しよう
        - 問題の頂点が2値になる
        - これでもイマイチまだ->木dpしよう
            - ゲームでよくあるのは「ここから初めて勝てるか」だが、その成功体験に引っ張られてはいけない
            - 情報をロストしすぎ
            - 根の方から余裕がある時、下の方を削除できるため
        - 木DPなので、再帰的に解く感じ
            - 変にオリジナルを作らず、問題文に合わせて「vを根として青木くんから操作する時、？？？」にしよう
        - 必要な情報（特徴量)は？
        - 部分木への遷移で、部分木内の頂点を消せることを表したい
        - つまり、「前もって消された頂点の個数(特定まではしなくて良い)」を持たなければならないだろう
            - 全部状態にするとエグい
            - ここでも単調性
        - 部分木について、「vを根として青木くんから操作する時、x以下にするために前もって消す必要のある頂点の最小個数」を求めよう
        - ターン性のゲームについての注意: 正確にやる。特に、ターンの切れ目を意識する
        - 遷移する<->高橋が動く時、動いた直後に終了させられる
        
    - [3: 2つの良さのせいで貪欲が立たない <- 答えの方を固定(二分探索)](https://atcoder.jp/contests/agc029/tasks/agc029_c)
        - 自由度高くてやばそう
            - 部分から解いていこう
                - 自由度・制約をまず眺めておく
            - 長くなる時...1連打をpushで良さそう
            - この調子で貪欲が生えないか？
            - 種類数minはまず前提として、「後ろ使える文字列の集合」の極大化もしたい
                - これがないと貪欲が保証できない...
                - 2つの軸<-片方を固定しよう。ところで種類数は二分探索できる。
                - 綺麗な貪欲が生まれあとは区間を管理するmapでシュミレーションで解けた

    - [1: 順番の制約 -> 個数の制約 具体的な値の固定 -> 2値、大小の判定に具体的な値を用いない](https://atcoder.jp/contests/abc107/tasks/arc101_b)
        - 中央値の中央値がx以下かで、二分探索
                - 中央値がx未満になるような[l, r]...一般だとよくわからない
                    - xが固定<-各要素について、x未満/以上かの情報だけで、中央値のxとの大小は判定できる
    - [3: 未来に取るかもしれない値のせいで情報が多くなり、dpもまとめられない <-構造を決定づける情報を決め打つ](https://atcoder.jp/contests/abc227/tasks/abc227_f)
        - dpしかなさそう
        - 素直に状態をまとめることができない？
            - 将来的に入れ替わりが発生するかもしれないので、今持っているtopKの優位性の比較が難しい
        - minを固定すると、比較ができるようになる
        - 違法な状態も探索してしまうので、それを弾くために個数の情報もつける
        - 
    - [2: 制約の値の固定](https://atcoder.jp/contests/arc147/editorial/4746)
        - 複雑にしてくる制約を固定すると、場合の数が簡単に表せる
        - しかし、固定した物を全通り試すことはできない
        - 固定: 値の対応を元に、制約の動かし方を数える

    - [独立にする ⇔ 互いに関わる制約がなくなる にはどう固定？-> 係数を固定](https://atcoder.jp/contests/agc025/tasks/agc025_b)
        - 独立にしたい
        - A+Bの要素を固定すれば、一見独立になるように見える
            - しかし、Aa + Bb = k' の条件が残り、実は独立にならない
            - かつ一気に計算するようなことは難しいので、２重の固定が必要になってしまい間に合わない
        - Aa + Bb + (A + B)c = k の条件において、A, Bを独立にするには何を固定したら良いか？
        - ⇔(a + c)A + (b + c)B = k
        - a + cを固定すれば、b+cは一意に決まり、かつ「どこに置くか」は独立な問題
            - 先ほどの固定は中途半端な固定だった中途半端な固定だった

    - [結果の形の固定<-結果のdpによる全探索](https://atcoder.jp/contests/arc097/tasks/arc097_c)
        - 順番を固定すると
            - 左から合わせれば良い
            - つまり、転倒数が答え
        - 転倒数の計算には、「今すでに前に置いた要素であって、元々は後ろにあったもの」がわかれば良い
        - dpできる
        - dpで結果を全探索しながら、その中で「転倒数がminだったもの」を求めることで答えられる

    - [ゴール固定->1回目の操作でいけるマスからの距離/k ゴールを動かす-> 自明に最近ゴール](https://atcoder.jp/contests/agc014/tasks/agc014_c)
        - ゴールを固定すると、結果が綺麗に表せそう
        - するとできる
        - もう動き方見なくて良い

    - [より次元が小さいなら解ける -> 次元を1つ固定すれば次元が落ちて終わり](https://atcoder.jp/contests/abc240/submissions/60831760)
        - 2dをまず考える
        - 2dでは45度回転によって、独立に+1/-1を決定できる
            - 3dで回転？
            - 立方体の対角線ではダメで、よって少なくとも綺麗にはならなさそう
        - zを固定すると2dになって終わり

    - [例題](https://atcoder.jp/contests/arc170/tasks/arc170_d)
        - 明らかに勝敗が決まるケースがあるが、それ以外のケースがわからない
            - 適当にどちらか必勝と思って実験するのも良いが、早計

        - 複雑さの原因: 3回の選択があり、相手の選択によって選ぶべき手が変化する
            - よって、考察材料ぐらい一意にしたい
        - とりあえず2回分の選択を固定したら、3回目は一意に決まらないか？
        - その結果を元に、2回目の手も、1回目さえ固定すれば「3回目がooになるように」選ぶことで一意に決まらないか？...
        - つまり、2, 3回目の手が、1回目の手により一意に決まらないか？
    - [例題](https://atcoder.jp/contests/arc165/tasks/arc165_c)
        - 単調性がありそう、に分探索するか...
            - 答えをここで固定した <- 何が変わった？を考える
            - ｘ以上の辺は無視して良い
            - 他2部グラフ
    - [例題](https://atcoder.jp/contests/abc276/submissions/57421658)
        - 差分列に言い換える
        - mod3 != 0であって、和がM以下、0以上の n 項の数列の数え上げ
        - mod3 != 0の制約さえなければ、一気に求まる
        - ここで、mod3を固定してしまう
        - mod3を固定したら、和の制約から引く
        - すると、mod3の制約が全くない場合と同じ議論ができる
        - なお、差分列にする場合、d0 = a0, di = ai - ai-1 とすると良い
            - 先頭だけ扱いが異なる

     - [例題]((https://atcoder.jp/contests/arc115/tasks/arc115_d))
        - 木の場合を考える
        - 木DP...確かに解ける
            - しかし、解けるというだけ
        - 木の場合で結果を固定すると、一意になることがわかる
                - そこから一般につながる

    - [例題](https://www.codechef.com/START150A/problems/TREEREQ1)
        - 補部分木の制約さえなければ解ける
            - 部分木の制約に還元するには？
            - 全体の要素数を固定

  
    - [例題](https://atcoder.jp/contests/typical90/tasks/typical90_cl)
        - 条件の分解: $\forall$ x, x以上の値で占められた区間の長さが K / x 以下でないといけない
        - 探索的...持つべき情報が多すぎる
            - 判定:左から: 全てのxについて、左端を含むx以上の値で占められた区間の長さが今何か？を持たないといけない?
            - why?
                - 条件が、区間を伸ばすことによって変化し、かつ変化先が未定だから情報を持たないといけない
           
            - 数える対象を考える...必要条件が出るが...

        - 複雑さの・情報を持たないといけない原因: 条件が、区間を伸ばすことによって何回も変化する、かつ変化先が未定だから
        - -> 変化先が一意かつ、もう変化しないような何かを固定したい
            - 変化が一意/不変な時とは？
        - 数列に現れる0の位置だけを具体的に考える/固定する
            - 跨ぐような区間にかかる制約は、全て0が確定する!
                - 跨ぐような区間にかかる制約は、もはや長さしかない
            - よって、間の区間だけ考えれば良い
            - 間の区間については何も状況が変わっていないが、DAGになっていて逐次求められそう
            - どの0を取ってもこれが成立する
        - 固定するものを減らすために、最後の0の位置だけを固定する
        - 数列の最小値 = 1 の時の問題を解けば、本題が解ける状態
        - 最小値と長さについてDAGになっていて、解ける

    - [初項の固定(un solved)](https://codeforces.com/contest/2013/problem/E)
        - やばい
        - 初項を決めると、gcd = minになるように取っていくのが最適
        - 初項の候補を絞りたい

    - [例題(un solved)](https://atcoder.jp/contests/tenka1-2012-qualB/tasks/tenka1_2012_8)
        - dpは無理そう
        - 各blockについて、横から潰されるか縦から潰されるかの2通り
            - 横から潰される方決め打ってみる
            - 爆弾置く行を決め打つ
            - あとは、「残りの爆弾を消せるように置く問題」
  
- 制約・要素が互いに関わり合うような制約は、その関わりの結果を固定した時の問題を解く
    - 綺麗に解ければ、単に結果を動かした時の数え上げに落ちる
        -  [例題](https://atcoder.jp/contests/arc147/tasks/arc147_d)
        -  [例題](https://atcoder.jp/contests/arc115/tasks/arc115_d)

- ただし、固定したら綺麗な構造が生まれたからと言って、それが次の解法につながらないのならば、その線では解けない
    - 固定しまくったら貪欲が生まれるが、動かした時の答えの集計ができないなど

- **時には、固定するためには何を定めたら良いか？がはっきりしておらず、こちらを先に集中して考える必要が出てくる。**
    - パッと出ないからといって諦めない

## 場合分けの固定
- 独立性や絡み合いなどを考えずとも、単に、「状況が複雑だ」と言う時に、上手い場合分けをすると簡明になる場合がある  
    - そして、その固定を動かせれば、解ける
    - イメージ的には、どうせ全て探索する必要がある時、とりあえず固定した時の解法を考えるような
- よって、意味がわからなかったら、とりあえず場合分け、そして固定を考えると良い
- [等差数列からいつくか選んだ時の、sumの場合の和](https://atcoder.jp/contests/abc147/tasks/abc147_f)
    - 探索的では間に合わず、一般では無理
    - 等差数列であることを使いたいが...
        - sum mod 交差 は初項依存
        - sum mod 交差 で場合分けする?
            - 綺麗にならない
        - sum mod 交差 は選んだ項数依存
        - 選んだ項数で場合分け
        - 作れる数が区間になっていて、集合のmergeが簡単にできて解ける!
## 固定の順番
- 時々、固定するものは複数個になる
    - そういう時、固定する順番によって、オーダーが変化したりする

- 基本的に、普遍的なパラメータや制約程外側に持っていった方が良い
    - **旨みの原因が前計算による高速化だから**
    - **特に、答えを途中で決め打つという時、その決めうちは一番外側に持っていった方が良い**
        - 答えの形が決まれば、前計算できがち
        - [例題](https://atcoder.jp/contests/abc370/tasks/abc370_f)
            - 全ての切り目について、この切り目で必ず切る時のmin(wi)の最大値がわかれば解ける
                - しかし、 rep(i, 0, n) rep(答え二分探索) では上手くいかない！
                    - 高速化が無理
                - 答えの決めうちは、とにかく一番外側に持っていく！
                - 本問なら、本当に一番最初に持っていく
                    - rep(答えの形) rep(i, 0, n)
                    - すると、i毎の判定関数が似た形になる
                    - よって、高速化ができる
    
## 余裕がある時の"損するかもしれない"固定
綺麗な解決めうちとは少し違う
- 最適な動きを取らなくて良いので、ある程度で実現しろ・可能かどうかを判定しろと言う問題は多い
- そう言う時、敢えて自分の動きを制限するような・損をするような固定をすることで、状況が単純になり、却って問題が解きやすくなると言う場合が往々にしてある
- モチベは「考察を進められる程度に状況を簡単にすること」
    - [クエリ回数に余裕がある。前半とextraがあり、前半が複雑](https://atcoder.jp/contests/agc068/tasks/agc068_b)
        - 前半ではグループが指定されるが、後半ではグループは任意にとって良い
        - クエリ回数は多い 
        - 全部グループ任意で考えたら楽...?
        - 前を全く考えなくて良いような固定
        - 000000 /111111
        - 固定したら状況がどう変わったのか考える 


## 数学の問題を解いてみよう
- [座標をシフトしても答えが変わらない](https://atcoder.jp/contests/abc334/tasks/abc334_b)
    - 事を使うと問題を綺麗に解ける
(
- [シフトしても変わらない/少しずつ場合分けをするには/円の上での3点の順番](https://atcoder.jp/contests/abc376/submissions/58957786)
    - 円: 切り開こう
    - 境界線があるから単純じゃない
    - 境界線の位置を全探索したくないが、すっと出るものではない
        - どうしたら良い？
        - もっと軽い、固定できるものを探す
        - A, Bの順番は？(2通り)'
- [右回転と左回転 -> 座標を左右対称移動して2回解けばいい](https://atcoder.jp/contests/abc376/tasks/abc376_f)
    - 無駄な動きでない必要条件は？
    - 目標が定ってるやつ <- うねうねしなくて良い
    - 左回りと右回りの2通りだけ

- [上限付き・総和指定+1/-1列の数え上げ](https://atcoder.jp/contests/abc205/tasks/abc205_e)
    - Kを超える <-> K+1を通る と読む
    - 素直な余事象は難しい
        - 初めてK+1をi回目に通る...無理
        - i回目までにK+1を通る...無理
    - 余事象をうまく数えたい
    - 初めてK+1を通るラインで経路を折り返すような対応を取ると、素直なコンビネーションとの対応が取れる
        - そもそも経路が存在しない時、この対応が壊れるので注意

- こうしてんの数え上げ
    - ax+by = cの形にして一般解
    - floor sum
    - 条件を満たすような整数(x, y)の数え上げが帰着できる可能性
<br><br>

# 探索対象・その周辺・遷移の"構造"についての考察
- 状態を持って探索、ではどうにも上手くいかない場合がある
    - 探索対象の構造に注目することによって、方向性の違う解法ですっきり解ける場合がある
- **特に、「条件を満たすものだけ探索する」場合、「条件を満たす集合・その周辺が必ず満たす構造」を元に探索でき、その構造によっては考察がガラッと変わる場合が多い**
    - **考察の枕詞として「探索対象ならば・条件を満たすならば・最適解ならば」がつきやすい**
        - もう少し弱いが有用なものとして、**「条件を満たす物でOOなものが必ずある」の場合もある**
            - こちらも、数え上げでなければ考察の対象をOOに制限しても良く、同じぐらい有用
        - 最適化における、最適な可能性のあるやつだけ考察(貪欲法)
        - 何かしらの一意性が見つかった -> それを元に問題を読み直すと誘導される解法があったり
        - 独立性が見つかった:問題を独立なパートに分解 -> それぞれ掛け合わせて終了
        - 1対1対応...独立
        - 意味のない遷移・失敗するかもしれない遷移を省いた直接的な計算
        - 重複を省いた直接的な計算
        - 否定の方が簡単な構造なら「条件を満たさないならば」だが、まあ
- いつ考える: 状態を持って遷移、では上手くいかない時で、探索対象の構造を活かせてないと感じた時
    - 特に: 無駄な可能性のある遷移をしている場合
    - 最適化、最適なやつ以外も遷移
    - 数え上げ、将来的に条件を満たさないかもしれない / 遷移の度に、条件を満たすか判定
- 何を考える: 探索対象やその周辺、問題に関わる要素が満たす、探索に便利な構造/遷移の構造
    - **特定の対象に関する構造に固執せず、問題の解決に役立ちそう或いは単に綺麗そうな構造を満遍なく考察する。**
        - 何が考察の方向性を変えるかは事前にわかるものではない
        - 素直に言われた通りの対象に固着せず、周辺の構造（例えば否定とか）で綺麗そうな物があったら、それを元に問題が解けないか考える
    - 何かを考える時、一度にスッと言えないなら部分から積み上げる
        - 必要条件の列挙 & 整理
    - 言われた通りだと複雑 -> キヨに分解してみる
    - 典型的なものとして、 「探索候補を1つ固定した時、それが条件を満たしているか？」の考察は、帰結として
        - 判定が軽い -> そのままDP
        - 判定が綺麗な形 -> 条件を満たす探索対象の特徴づけ
    - が得られて特に有用である。
    - 他、極端なものは特別な構造を持っていやすい（後述)など...
- "構造"について、求めたいものとの距離が遠い形で得られた場合、近づけたい
    - 操作列 -> 結果 において、操作列に対して言えることがあるなら、それを結果に反映できないか・似た結論が結果にないか
- [順々に辺を作っていく方針では木を持たないと難しい](https://codeforces.com/gym/105633/problem/D)
    - 探索はわからない
    - 条件を満たす木だけ探索 -> その木の構造とは?
        - 辺を固定すると、両方の文字列で作られる必要
        - マージを表す木...全てのi, i + 1について、ちょうど1回そこが繋がる時がある
        - 木が同じ -> マージのgapが同じなら、同じ辺を張るが構造として言える
            - 逆は簡単
            - gapを固定すると辺の1:1対応
        - よって、それぞれのgapについて、同じ辺の本数をかければ終わり
            - 状態を持って探索などしてない

- [条件を満たす集合](https://atcoder.jp/contests/arc115/tasks/arc115_d)
    - 探索はわからない
    - 集合の構造と言われても
    - 遷移の構造...validな遷移の本数が簡単にわかる

- [等差数列の部分和問題](https://atcoder.jp/contests/abc147/tasks/abc147_f)
    - 状態を持って探索では厳しいし、あたいの重複もする
        - 数え上げ対象の条件は、作れることで、あんまりない
    - 構造に目を向ける -> 大体作れる -> 区間になっていると嬉しくて...
    - 個数を固定すると区間です なんと解ける
- [条件を満たす数列](https://atcoder.jp/contests/arc144/tasks/arc144_d)
    - 探索はわからない
    - 条件を変形すると、1bitだけ立ってるやつの値を決めれば良い
        - ここまで言っても探索はわからない
    - 条件を満たす集合が実は言い表せる
        - 「初項をcとする。1項使うと、最大値を好きなだけ増やす or 最小値を好きなだけ減らせる。最大値 <= K かつ 最小値 >= 0になるような数列」
            - 増やし幅・減らし幅がわかれば係数固定 -> 増やし幅・減らし幅を固定した時、okなcの個数もわかる
            - ここから上手い数え上げをすると解ける
- [操作で作れる数列](https://atcoder.jp/contests/agc036/tasks/agc036_c)
    - 状態を持って探索は無理そう
    - 構造を考えたい
        - 数列を与えられた時の判定...ちょっと複雑
    - 操作列を与えられた時条件を満たすか
        - 一番多いのがM回以下なら良い
        - 考えるべきだった: 操作と結果が遠いので、上の結論を結果に持っていくべき
    - 操作列違反は1回まで...否定の方が綺麗な構造をしていそう
    - 否定: $\exists$操作列、作れる -> $\forall$操作列、作れない の言い換えに注意
        - どうやっても作れないものをカウントする。考察が少し変化する。
    - 奇数の個数を固定すると考えやすい
        - しかし、結局、答えにより近いのがある
        - アリエル奇数の個数の方をまとめてやる（係数をまとめる感じ）


## 何か問題の1要素に注目・実際に固定して、良い構造を考察(固定する考察に近い?)
- 問題で考えることが複数ある時、そのうちの何かに注目する考察は有効なことが多い
    - 操作をして条件を満たす...操作にいくつか種類がある時、そのうちの1操作について内容を固定してみる
    - その時、問題がどう変わるか整理すると上手い構造が見つかることがある
    - 考察する上では、注目したい要素を固定すると捗りやすい
- その構造によって、また考察の方向性が根本的に変わることが多い
    - 全探索が間に合うようになる
    - 独立性が...
    - 一意性が...
- いつ考える: 問題で考慮することが複数ある時ならいつでも
- 何を考える: **問題に関わる要素ならなんでも。なんか良い構造がないか固定したりして考える!**
    - [条件の満たされ方が 1.他の要素によって 2.自分で、の2パターンある -> 2の要素を固定してみる](https://atcoder.jp/contests/agc049/tasks/agc049_c)
        - 自分で満たす集合を考えると、一番右の要素だけ操作をすれば良い
        - よって、自分で2のやつは1つ固定すれば良い -> パターンが少なくて、全探索できる
    - [ボールの振り分け...目的が「差分のsumのminimize」の上での数え上げ -> 人を忘れて、「minの集合/maxの集合」に目を向けると、なんと一意性がある -> その一意性があると分かれば、もうN!掛ければ問題が終わってしまう](https://atcoder.jp/contests/agc037/tasks/agc037_b)
        - 差分sumがminの集合の構造が知りたい    
            - 特に、OOなものがあるではなくて、min ならば OO が欲しい
        - 差分がminの上で、人を見るよりも「min/mid/maxの集合」の方が距離が近い
        - 一旦人の事を忘れて、「min/mid/maxの集合」に目を向ける
        - この集合の構造は？あり得る集合は？
        - （閉じた形で表すことこそできないが）貪欲なグルーピングによって、自由度こそあれ、min/maxの集合は一意？ -> 自由度 * 人への振り分け(N!)で答えが出る？
            - ACが帰ってくるので多分会っています
        - 証明にも、実際に割り当てを固定して構造を調べるのが役にたつ
            - a1, ... ,anを、昇順になるよう固定
            - aiより小さいやつは[1, i-1]人にのみ入る
            - つまり、aiより小さいやつは各色i-1個までしかない
            - ai <= ri, gi, bi
            - これにより、貪欲で得られるものが一意に最適なことが言える
- あるいは、問題の答えを1つ用意して、それを「改善する方向に変化」させることによって、結局答えはこの条件を満たすと言えたりする
    - 「条件を満たすものでOOなものが存在」を言うのに有用だし、必ず改善するなら、それは「満たすならばOO」の形にもなる


### 途中段階の集合の構造を考える
操作によってOOを作る時、そのOOの最適化/OOの数え上げなど
- 操作 -> 対象 -> 対象の最適化と、距離が遠くて考えづらいので、一旦途中段階までを整理したいというモチベ

必要なこと: 作れる・条件を満たす集合が考察に利用できる形で得られること。特に、条件が得られること  
いつ考える: 今考えているものと、最終的な目標の距離が遠い時
- 綺麗な操作を組み合わせることによって作れる集合が全て網羅できた、でも良い。
- 作れる集合がわかれば、複雑な操作をもう見なくてよく、格段に探索・考察がしやすくなる

- コレがわからないと作れるものを軸にした全探索ができないというわけではない
    - 操作を軸にした(操作しながら作っていくとう)全探索はできる
    - 別の構造を元にした、根本的に違う視点からみた非自明な解法もあるかも
        - 独立性とか、なんか言えることとか...

- [どういう操作が上手いかわからない<-作れる集合を出して、どういう集合が上手いのかを考える](https://atcoder.jp/contests/agc008/tasks/agc008_b)
    - 作れる集合: 最後に注目 大体おk
    - すると貪欲

- [構築できる条件がすぐには出ないので、必要条件を積んでいく](https://atcoder.jp/contests/arc103/tasks/arc103_c)
    - 作れる条件を求めたい
        - すぐにはわからない
        - 必要条件を積み重ねていこう
        - n...0, 1...1. n-1...1 の必要
        - s[x] == s[n-x]の必要
        - 必要条件を見つけたら、それを満たすと固定する
        - もう作れる？
        - 1が必ず1であることから、作れる
        
### 途中結果の集合・自由度がわかったら、もうそこに至る過程・構成要素は考えなくて良い。結果だけを用いて議論して良い。
- 固定でも記述したが、「自由度を決定することによって結果が定るという時、その結果の集合がわかったならば、もう元の自由度は考えずに結果のみを用いて議論できる。そして、結果を直接いじって考える方が考えやすい。
- 必要なこと: 途中結果の集合がわかること
    - 考察、xor基底...
- いつ: 自由度と、最終的な結果が離れていて考えづらい時。
    - 自由度を固定した時の結果を考え、それにより途中結果の集合を考察する等

- [貪欲・要素ごとに見ると厳しい...要素を選んだ結果としてのxorはわかる・相手のxorも一意に定まる -> もう要素は考えなくて良い。結果だけを用いて議論すれば良い。](https://atcoder.jp/contests/abc141/tasks/abc141_f)
    - 片方の集合を選べば、もう片方の集合のxorは一意というのは直ぐにわかる -> 片方の集合についてだけ考えれば良いはず
    - 片方の集合について、作れるxorの集合はxor基底を用いて分かる
    - 結果の集合がわかる -> もう要素を見なくて良い？
    - 実際、上から貪欲に結果を決定していけばよく、もう細かい要素は見なくて良い


## 手続きによって得られる物の構造考察
- 手続きによる特徴づけより、より簡素に条件を満たすものとしての特徴づけの方が使いやすい・役に立つ。
    - 後の考察だったり、最適性の証明だったり、一般に。
- 一旦手続きによる特徴づけが手に入ったら、全く別の問題として、「その手続きによって得られる集合はどのような特徴を持つか？」を考える。
    - 特に、ストレートに特徴を求めようとしないで、その手続きを考察の足がかりとすると良い。遥かに考えやすい筈。
    - [最適な集合を得るアルゴリズムがわかる -> そのアルゴリズムの動きを眺めると、その集合の1つは閉じた式で表せる](https://atcoder.jp/contests/agc037/tasks/agc037_b)
        - 今回は数え上げなので、別に1つが閉じた式で得られてもあんまり嬉しくない？
        - 最適化ならその「閉じた式」で表せる綺麗なやつだけ見れば良くなって嬉しい
<br><br>

# 考える要素の中でも、極端なものに注目して考察する
順々に決めていくという時、どうせなら極端なものから決定した方が上手くいきやすい。よって、常にそうした方が良い。
-  **必要な事: 何か極端なものに対して、言える事がある(のみ）**
    - 上手くいく良くあるパターン
        - 他の自由度と比べ一意性が強くて
            - いま決定できる -> その決定によって問題が変化する
            - 考えやすくてなんか良い事がある
        - 全体の形に影響するため、それを固定すると問題全体の一意性が上がる
-  いつ考える: 問題がぼんやりとしていて、（方向性は決まっていても）どこから考えれば良いかわからない時
    - 特に、**どんな問題であったとしても使える**
        - たとえ曖昧な・よくわからない事が残っていたとして、その状況下でも言える事があれば議論が進み、しまいには解けてしまう事が大いにある。必要な事は、"今の時点で一意に言える事がある/DAGになっている構造がある"事であり、特に極端な要素があるならば、そうである場合が多いという事。
        - **議論に曖昧な事を挟むのはよくないが、かと言ってわからない事を全て解き明かす必要はない。**
        - **また、問題を解くために行う考察の多くが状況を一意にするための考察であり、であらば初めから・今の時点で一意なものがあれば、それを先に処理するのが道理。**
        
- また、**極端な要素に注目する時は、必ず”全ての方向に対して"、極端なものをそれぞれ見ること**
    - min・maxの要素、最初・最後の要素
    - 1方向きで少し上手くいっても、それでは不十分なことがある
        - [最初の操作と最後の操作、両方に対し言えることがあり、それで初めて解法になる](https://atcoder.jp/contests/ttpc2024_1/tasks/ttpc2024_1_a)
        - [考慮する要素を減らしたい -> 小さい人、大きい要素それぞれについて一意に相手が決まり、考慮するものが減る](https://atcoder.jp/contests/abc226/tasks/abc226_g)

- 自由度を持った操作がいくつか与えられるので、自由度を決定して最適化せよという時
- 極端な選択肢にのみ貪欲が存在する場合がある
    - その要素にしかできない<-一意に決定
    - 状況が極端なので
    - かつその選択肢の影響を前計算してしまう事で、次の"極端な選択肢"が生まれる場合がある

- 極端な選択肢にのみ明らかな制約がある・状況が一意になっていて、そこから全体の構造を把握できる場合がある
    - 特に順々に操作をしていくタイプだと、中途半端な要素は今どうしたら良いか・これは可能なのかなどがわかりずらい。しかし、最初・最後に注目すると、大抵状況が一意になっている。
    - ここで代表的なもので言えば「最後の操作・最初の操作」に注目すると、その時は状況が固まっていて何か言える場合がある
        - かつ、最初・最後について何か言えて、それで問題サイズが小さくなれば、それで解ける
- こういう発想の時は、本当に端から考えた方が良い(dpの途中について遷移を考えるとかしないで、dp[0]から考える)

- [選択肢の中でもmin/maxのvalueは、結果の集合のmin/maxを定める -> そのindexの振り分けで場合分けしてみると自由度が減って貪欲になる](https://atcoder.jp/contests/arc073/tasks/arc073_c)
    - 注意: maxの要素はたくさんあるかも
        - maxの中で1つ任意にとって、それについて場合分けした、でも筋が通る

- [端から押す/notを考えると、DAGになっている、で終わる](https://atcoder.jp/contests/abc158/tasks/abc158_f)
    - 作れる条件とか、問題の構造とか、よくわからない...
        - 一番左について、消えるなら自分を押すしか無い
            - そこを場合分けするとDAGになっていて終わり
            
- [minを取る要素の位置は一意だし、しかもそこで制約が独立になる](https://atcoder.jp/contests/arc186/tasks/arc186_b)
    - そもそも順列が存在しないような制約について考えたくない
        - 「ooな制約はない」がわかるが、かと言ってそれが数え上げを与えてくれない
            - 全探索できほど単純な構造ではない
        - 大小関係の制約<-極端なものとして、max/minから位置を決定していくことを考える 

- [どんな集合が取れる？ <- 極端な要素...今回は中心の要素](https://atcoder.jp/contests/agc053/tasks/agc053_b)
    - どんな集合が取れるのか解ければ良い
    - 判定 <- 極端な要素...中心の要素に注目してみる
        - 本当にmidについて、左右のどちらかしか取れない
        - 外に広がる時も、左右のどっちか選んで取ることはできる
        - 内側の選択肢を外側に持っていくこともできる
        - これで十分?
        - 手続きの証明<-出来上がるものの特徴づけ: 「中心から広げて行った時、常に取る個数が半数以下」
            - できる事が示せる

<br><br>

# 数え上げ
- 数え上げは全探索なので、多くの手法が他の分野の問題に使える
    - 足し算の線形性を用いて分解とかの手法は使えない

## 否定・以上
基本: 否定の方が数えやすいなら、否定を数えよう
- 肯定ではふわっとしているもの <-> 否定なら固まってるかも
- たくさんのバリエーション <-> 否定なら少ないバリエーションかも
- 2以上  <-> 1
- とりあえず、「ooで**ない**」「oo**しない**」といったものは全て疑って良い

- 操作列 -> 結果 で、作れない結果を探索する時、
    - 作れる :$\exists$操作列
    - 作れない:$\forall$操作列
- となって、考察の方向性が変化することに注意(判定の貪欲が変わったりする)
- [式変形](https://hackmd.io/aQrfqrLIQxabjpiwcTLSIw)

- [例題](https://atcoder.jp/contests/arc090/tasks/arc090_c)
    - 2人が交わらない経路
        - よくわからない
        - 交わる点の距離は一意
        - 交わるような経路を数えた方が簡単？

- [例題](https://atcoder.jp/contests/abc355/tasks/abc355_d)
    - 区間について、交わるより交わらないの方が簡単な場合がある
    - 交わらない、は状況が一意で、交わる場合より却って少ないので
    - 右端昇順に見ていけば、交わらない⇔相手の右端が、こっちの左端より前

- 1つ以上OOである...余事象・包除原理を考えた方が楽
    - いつかんがえる: いつでも
    - 1つ以上は、ある自由度に対してさえ満たしていれば他はどうでも良いという構造をしていて、自由度ごとに独立ではない。
    - 全てOOではないは、自由度に対して独立。
    - 母集団引くの忘れがち、最初に書いておく
        - [1回以上通るパス <- 部分木に対して独立ではないので、木dpが破滅 補集合を考えて解決](https://atcoder.jp/contests/abc163/tasks/abc163_f)

## 探索の軸は基本自由
- 決めるものがたくさんある時、何から決めるかは自由である。
- いつ考える: always
- 何を考える: 楽になる決め順。高速に答えが出る決め順
    - 特に、あるきめ順を検討して上手くいかないなら、必ず逆向きの順を考える
        - 左から <-> 右から
        - 時系列前から <-> 後ろから
        - 小さい方から <-> 大きい方から
    - sortして良い -> とりあえずsortして考える
- [条件を満たす行列の数え上げ](https://atcoder.jp/contests/abc273/tasks/abc273_g)
    - 条件の独立性（row/colをそれぞれswapしても答え不変）より、制約をR, C事swapして良い
        - つまり、0, 1, 2の分布のみが重要で、それ以上の情報をロストして、後から係数をかければ良い
        - また、とりあえずsortしておく
    - 上の方の行から決めていく -> 何行目まで見たかで、Ri = 1 の個数と Ri = 2の個数が復元できる
        - 追加でCj = 1の個数を持ってけば Cj = 2の個数を復元できる
    - 今回の埋め方を全探索すると、できる(重複の扱い！)
    - 以下、重複の扱いについて
        - 1つずつおいていく...おく順番によって、同じものが2解カウントされる場合がある
        - 探索の仕方は自由で良いが、数え上げならば、同じものが（探索の順番の違いによって）2回カウントされてはならない。
            - 違いが発生しうるところは一気に遷移する...
            - 作り方を1に決めるルール...
        - 今回においては、 Ri = 2なら、2個同時に置くのが丸い。1個だと、----- -> --0--- -> --0---0  と ----- -> -----0 -> --0----0 で、同じものが探索順の違いによってダブルカウント


## 全探索できる物を見つけたら、とにかくそれを軸に全探索を考えてみる

-  [例題](https://atcoder.jp/contests/abc361/tasks/abc361_f)

## よくわからない -> 何かを固定した時の数え上げを考える
なにかを固定 -> 一意になったことによる影響を考え、真っ先に処理
- 固定したものを動かしながら総和を取れれば解ける。
    - 固定した時について考えた時、数え上げる上で固定すべき情報」がより少なく済むとわかれば、固定を緩和することで動かしての数え上げが簡単になる。固定したものを動かせるなら解けるし、固定の緩和によって動かせるようになっても解ける。
- また、固定する事で状況が単純になって、構造・数え上げるものにつく強力な必要条件がわかりやすくなる事がある
    
- いつ考える: 数え上げでよくわからないなら割といつでも。

- [横線の分布の固定 -> 横線の個数の固定](https://atcoder.jp/contests/arc157/tasks/arc157_d)
    - 横線の分布を固定すると、縦線はそれぞれ区間で表されて、掛け合わせて解ける  
        - しかし、分布について動かすのは、dpでも難しそう
    - 必要条件を考えると、横線の個数を決め打った時点で、分布はほとんど決まるはず。よって、横線の個数を決め打てば数え上げられる
    - 個数について動かす...単に全部試せば良い。


## 何かについて場合分け -> 問題のサイズの小さいのに帰着されていて、終わり
- 特に、その何かには極端なものを選ぶとうまくいきやすい。（集合の最小の要素とか、数列の左端とか）

- 必要なこと :場合分けすると、うまく問題のサイズが小さくなるような要素がある。高速化すれば間に合う
    - これさえ成立すれば、他がいくらわからない状況でも解ける
- いつ考える: 極端な要素がありそうな時。集合の数え上げ。他より際立って考えやすい要素がある時。

## iによらない遷移
- 高速化: 行列累乗など
- 考察: シミュレーションが行われると捉えずに、全体を俯瞰すると良さそう？

## 数学的な考察

### xの倍数である
- 1: kを自然数として、 xkで表して立式。ユークリッドの互助法など。
- 2: mod k で考え、 = 0とする(mod k以上の情報を捨てて、同一視。数え上げなど。)
    - Ai + Akがkの倍数 -> Ai + Ak = 0 ⇔ Ai = -Ak     
        - iとkで独立!
### パラメータをずらした・状況を一部変えただけ
- ずらす前・より簡単な状況で綺麗に表せる操作は、ずらした後・変えた後でもある程度綺麗に扱える場合が多い。かつ、それでも綺麗なので、その結果が使える事が多い。
    - 例: 線分上での対称移動    
        - 基準点をaとして x -> 2x - a
    - 例: 円環上での対称移動x
        - mod 円環の長さになるだけ
        
### 区別すべき物を区別せずに、後から係数を掛ける
- 嬉しい: dpにしやすい
    - dpは同じ状況を纏めるという側面があるので、状態の情報量が減ると当然高速化につながる
- 必要: そのような係数が求められる事
    - もとまるにするために、dpの設計をし直す場合すらある
    - 結構大変

- 疑惑: そのようにできる場合、そもそも人に対して制約が対称的であり、dpにおいて「具体的に残っているのは誰か」をロストさせられる
 
- [素直に区別した方が計算量/考察ともに軽い](https://atcoder.jp/contests/abc180/tasks/abc180_f)
    - 区別しないように言い換えると、サイズが同じグループをまとめて追加する処理が必要になる
        - 係数を求めるために
    - 集合を持つのは必要？
        - 人個人の制約がないので、多分まとめられる
        - 適当にやると重複するが、それはそもそものdpの設計の問題であって、「まとめる」高速化をしたからではない
        - dpの設計の話<-集合を切り取っていくふうに考えると、最後の結果に対し、切り取り順だけ重複する
        - 切り取り順を一意に<-minを含めると考える

- [人を区別せずに数え上げて、係数を途中と最後にかける](https://atcoder.jp/contests/arc067/tasks/arc067_c)
    - 組み合わせも考えられるが、単純ではないのでdpをしたい
    - 人を区別すると状態量が多すぎる
    - 一旦人を区別しない場合を考えると、解ける
    - 区別する場合？
    - N! / (グループ1のサイズ)!(グループ2のサイズ)!... から、サイズが同じグループの区別を無くした物
    - 分母はdpしながらかけて、最後にN!をまとめてかける
        - 途中でsumをとって、それに対しグループのサイズ!のinvをかけるので良いのか？
        - 全ての遷移がこれで正しく数えられているので、解ける
    - なお、区別するとしても、残り人数にしか興味がないので、その辺をまとめれば解ける

### 互いに素でない時
- gcd = gとする。
- 倍数関係について、割っても変化しない -> gで割って、互いにその場合に帰着
### 丁度 $k$ <-> $k$以上の言い換え
ちょうど $k$ より、 $k$ 以上の方が好ましいやつ
- 「各素因数について、次数が $k_i$ 以上」である整数であって、 $n$ 以下の個数 (from : 各素因数について、次数が丁度  $k_i$)
    - ⇔何かの倍数
- 集合に $x$ が $k$ 個以上含まれる (from : $x$ に丁度 $k$ 個含まれる)
    - $x$ を $k$ 個とって来たとして、残りの集合についても以前 $x$　を含んで良い
    - これによって分割統治がうまく行ったり
        - そもそもの条件が「$x$ が含まれて良い」の時に、 $x$ が $k$ こ含まれる場合...で場合分けした時

- a or b $\subset$ $k$ (from : a or b = $k$ )
    - 条件が「a と b が共に $k$ の部分集合」になる
        - 演算に逆元があれば、左から右を復元できる
            - メビウス変換
-min(a, b) $\ge$ k (from : min == k, max == k)
    - 全てがk以下、とk-1以下を解いて引く
        - 逆元が必要
    - 「どれかについて丁度kが存在」が消え、それぞれの要素が独立に動けるようになる
    - 期待値問題とか
    - 判定問題にも使えそう
    - min(A1, A2...)の期待値の求め方:
        - minがx以上である確率を足し合わせていけば良い
        - すると、全ての値がx以上の確率を求めれば良いことになる

### $\sum_{i=0}^{n-1} ai \le S の時の組み合わせ$
- $n$ 項目を追加して、そいつにも重みを負わせることにすれば、「sumがちょうどS」に帰着できる場合が結構ある
    - 何かの固定を動かす場合、動かしてsumを取らずとも求められたり
    
### 数列に対するスコアのsum <-> 数列の個数の数え上げ
- 数列のスコア $\ge a$ となるような数列の個数が、a全体にわたって求められれば良い
    - 上のテクと合わせる場合

## 約数包除
- 動機(いつ考える): gcd(a, b) = k は条件が独立じゃ無いせいで難しく、 gcd(a, b)がkの倍数は独立なので容易い。
    - lcm(a, b) = k -> a, b共にkの約数
    - （素因数の視点から見て）ちょうどx -> xの倍数
- ここで、この左右の値を結びつけるのが約数包除とか呼ばれるもの

### テーブル -> テーブル
- f(x)が与えられた時、 F(x) := $\sum_{xの約数であるようなy}f(y)$ とかを求める
- 簡単
- ライブラリにある

### （疎なテーブル) -> 変換後sum
例として、F(x) := $\sum_{xの約数であるようなy}f(y)$ を扱う
- F(1), F(2), F(3), F(6)が与えられ、他のF(x)は0だと言う時、$\sum f(x)$ を求めると言ったような
    - テーブルを変換する手法よりも計算量が落とせる(単に変換するよりはhard)
- $\sum f(x) = \sum A_iF(i)$となるような $A_i$ (つまり係数)を求め、それを用いて F(i) != 0の項を集計すれば良い
    - 係数の求め方1: 機械的に係数を求める
        - (1): 既知の配列{bn}と、求めたい配列{an}の関係を約数や倍数の言葉で書く
        - (2): 式変形して係数列を導く
        - (3): 求める
        - (4): n, mを丁寧に書く。入れ替わると全く変化する。
            - [そう言う問題](https://atcoder.jp/contests/arc185/tasks/arc185_e)
            - この手法では$\sum B_if(i) = \sum A_ig(i)$ のように、求めるものにも係数がかかっていても求められる
            - Bのうち特定の項だけ集計したいとかもok!
    - 係数の求め方2: 包除原理の考え
        - gcd(a, b) != 1 ⇔ a, bが共になんらかのpの倍数 ⇔ 素因数が1, 3, ... に+1, 2, 4... に-1, p^2に0(メビウス関数)
        - 素因数に関する包除原理は、一見（素数が多くて）計算量がやばいが、有効な値の範囲から見ると間に合っていることが自明な場合が多い
        - [係数を求めることで疎なテーブルについて変換後sumを高速化する](https://atcoder.jp/contests/abc230/tasks/abc230_g)

    
### 多項式復元
- 方程式
- なんか上手い方程式であって、値がそうなるもの
    - (x - ?)^? みたいなのを足し合わせる

### 数え上げ: 補集合/否定
否定や補集合を考えた方がわかりやすい場合は多い。
特に、OOでないという形の制約は考える対象が多い・漠然としていることが多く、保守業を考えた方が良い。
区間であって、交わりを持つようなペアは何個あるか？
→実は、交わらないという条件の方が数えやすい。

### 集合の数え上げ
- 数える集合の必要条件を考える

- "作り方"を決めて、それに沿ってdpする
    - 数列の左から使用・不使用を決めていく...
    - 一番小さい/大きい要素から個数を決めていく...
    - 常に総和の条件を満たすように一番大きい要素を突っ込んで、それを分割していく.../一番小さい要素を統合していく...
    - 重複してはいけない : 集合の作り方を一意にする・標準形を決めて、それを遂行する
    

- 順番を決めて、add or notを決めていく。1回notしたら復活しないルールにする
    - 0個含まれる場合
        - 次へ
        - ooが含まれないという条件から、再帰的に問題を言い換えられるかも
            - 要素全てから-1するような言い換えは、要素の値の範囲が変わるので注意
    - 1個以上含まれる場合
        - 1個の影響を処理
        - 
- 典型 :分割数数え上げ
    - 分割統治
    - 問題のサイズをキーとしたdpと見るか
    - dp[i][pre][S] := iまで決めた、最後の要素はlast,総和が S の集合の個数...を高速化する典型的な手段
        - 以降がlast以上という条件の時、「以降の要素にはすでにlastの下駄がある」と思えて、その下駄を総和に反映した上で問題サイズが小さくなる



## 纏めて数える数え上げ
何か、パラメータを共有するものを纏めて数え上げられないか？
- 探索の軸を変えるという事
    - しかし、軸を変える理由の全てがこれというわけではない
        - 他: 持つ情報を減らすとか
- 高速化に悩む時、これを考える事によって軸の変更を考えるのは有意義
    - 計算量が「元々の母集団」から「まとめた後の種類数」になる
        - 種類数のオーダーの方が小さければ高速化

- [例題](https://img.atcoder.jp/abc020/editorial.pdf?_gl=1*1eo4d7b*_ga*MTYwMzg3ODI3OS4xNjc4OTM4OTg1*_ga_RC512FD18N*MTcyNjA0NDIwNi4xNjk5LjEuMTcyNjA0NjEyNy4wLjAuMA..)
    - gcdが同じやつごとに纏めたい
    - gcdを固定せずに、x以上の形の方が...(以下略)
    
## 主客転倒・寄与の分解
全ての数列を動かす時...に強い
- 一般に、そのような状況でdpしようとすると情報量が大きくなるため

**計算するものが + で結合されるならば常に、それぞれを分割して計算して良い。**
- 必要な事: + で結合されているものを数える時に、注目するものを固定したら解ける&&それを全体に動かした答えがわかる時
- いつ考える: 基本分割した方が楽なので、方針の1つとして必ず考える
    - 特に、1つ1つが独立だと、その1つに注目した時に情報量が一気に減ってできやすい
- 何をする: 分割した1つに注目した時、それを求めるに当たって独立な（関係がなくなる）・無視しても答えが変化しない情報を全部ロストさせる
  - 何を計算するのか、立式すると良い
  - 要素を固定した時、状況の整理によって独立に動かせるようになって、それぞれを高速に求められるというケースは多い
    - 要素を固定した事によって状況が2値になる/対称性より1回計算すれば良い等で、劇的に簡単になる場合がある。
    - $\sum$ の $\sum$
        - $a_{i1} + a_{i2} + ... + a_{in}$ の総和
        - 個数の和・期待値


- 寄与を分解すると決めたら、寄与の種類についてのループは一番外側に行くべき
    - なぜ:状況の単純化や、それによる前計算の恩恵を受けるため。
        - 答えを固定する考察と似てる
- かつ、寄与に分解、つまり今注目する物を固定したら、できるだけ状況を単純化・2値化する
    - 例えば、もはや値の大小しか関係ない場合、一旦 0 / 1で考えて、最後に0/1内での並びの分階乗をかける
    - 変に一度に計算しようとすると、却って状況が単純にならず旨みがない場合
    - [例題](https://atcoder.jp/contests/arc114/tasks/arc114_c)
        - 小さい方から埋めていくdpで通そうとして大変苦労した
        - キヨに分解なので、考えるxを固定した上で全てを考える
        - 数列で持つべき状態が減って、dpできる
    - [マジックナンバー入り数列:隣接項で、異なっている場所の個数](https://atcoder.jp/contests/abc200/tasks/abc200_f)
        - 個数なんて基本+連結
        - 繰り返し...元の数列での位置を考えると良い。
            - 確率を途中で用いる
    
- 演算にbit演算が入る場合、bit毎に和を数え上げる主客転倒がうまくいく場合がある
    - $\sum \sum A[i] \oplus A[j]$
    - [例題](https://atcoder.jp/contests/arc092/tasks/arc092_b)

- Σの添字の範囲よりも、中身の値の種類数の方が少ない時、入れ替える高速化
    - [例題](https://atcoder.jp/contests/arc126/tasks/arc126_c)
    - dpの添字入れ替えと同じ。重要 
        - ナップザック問題



##  寄与への分解をする、と宣言したら解けるというものでもない/分解の上手い定義
- 寄与への分解の仕方についても、「うまい分解」の仕方を考える必要がある

- まず、**分解した対象には文脈がない方が良い**
    - 文脈あり: 「OOという手順でシュミレーションした時、この要素までやったら...」
        - これだと、結局シュミレーションを実際にやりたくなって、状態量が爆発してダメになりやすい
    - ない: 全部をし終わった時、結果としてこの要素は?
        - これなら、「全てを動かす <-> 今の選択がなんであろうが、他の要素は全体を独立に動く」という、"全ての変化"を考える時の独立性を活かしすい。
        - および、「関係のない情報を全部ロストさせる」という目的から見ても、関係のある情報は少ない方が良い。

    - よって、シュミレーション中にこのイベントが起こる回数を求めたい、などは、そこまでのしゅみレーションの結果に依存するところがあって求めにくいだろう

     - [グラフに辺を張っていく時の、連結成分数](https://atcoder.jp/contests/arc140/tasks/arc140_d)
        - まず、前処理をして、グラフを構築
            - 重みつきで、-1ばかりの時に帰着
        - dpするには、連結性の情報が必要になりそう
            - 必要な情報が多い
            - 数列が動くので、キヨに分解しよう
        - 文脈がないキヨ: 最終的なサイクルの個数をカウント
        - これは、サイクルの素性を固定したら解けて、固定をまとめてやれば解ける

- 寄与に分解したのちも、係数を求めなければならない
    - ここでさらに寄与に分解することもある
    - [分解し、係数を考える<-どうやって求める](https://atcoder.jp/contests/agc028/tasks/agc028_b)
        - 例によって、全体を動くのでdpは難しい
            - 時間・順番が関わってくるため、区間dpが相性が良いことがわかり、$O(N^3)$は書ける    
        - 答えがシグマなので、A[i]が何回たされるか、の係数がわかれば求まる
        - どうやって求めるか。
            - Pが与えられた時、A[i]が足される回数...累積minの更新回数になって、1回ならstackで求められるけど、Pが動く時にはもとまらなさそう
            - 求めるもの:「Pが全体を動く時のiの足される回数」
                - 依然Pが動く！
                - またまたキヨに分解し、「jが選択された時に、iが足される」ようなPの個数を考える
                    - 一度キヨに分解したら終わり、では無い
            - P[i]...P[j]でP[j]がmin
                - 条件が簡潔・立式難しい<-立式しない数え上げ
            - 簡潔に表せて、sumもわかって、終わる
            
- いつ寄与が発生するのかがわかれば、寄与を数え上げるdpにする事ができる
    - 必要な事: いつ寄与が発生するかの情報　という事
    - [固定した時の問題に対して、数値で答えは出ないが寄与はわかる->dpで数えよう](https://atcoder.jp/contests/arc114/tasks/arc114_c)
        - 固定した時
        - 前に自分以上だけを挟んで同じ値があるならキヨ0,else 1
        - 自分以上が気になる <- 値を決め打った寄与の分解
        - 注意: i番目に決め打った値xが来ないとしても、i+1番目の値によって数列が分裂すれば寄与の総和は変化する
        - 数列の総数と寄与の総和を持ってdpする


## 数列を動かす・変化する時のooの総和
- 寄与への分解が強い
    - 素直なdpだと、変化の自由度に応じて「前までの変化の結果はooだった」を持つ必要が出てきて、情報量爆発しやすい
    - そういう時に、シグマを分解する・順番を入れ替える事によって、まとめて数えやすくする

- 差分を計算、もok
    - 主に、変化の影響が小さい時

### 寄与の分解を用いた条件の分離・言い換え
- 条件A, Bに対し、「A かつ notB なら寄与2, A かつ B なら寄与1」のような時
    - AとBが絡み合って、数学やdpに起こし辛い
- **条件ごとの寄与を求める**
    - 言い換え: 「Aが成立なら寄与2 かつ B が成立なら寄与 - 1」
        - 条件を分離できた

        - 実際には、条件の成立関係(B ならば A等)が上手くなってないといけないので、確認する
        - [例題](https://atcoder.jp/contests/arc167/submissions/57188317)
            - 「距離k以内に1つ || 2つあって、その2つの距離がk以内なら寄与1、2つあって、距離がk以上なら寄与2」
            - 2つの距離がk以内になると減る
            - 距離k以内に1つ...寄与1
            - 左右の距離がkいない...寄与-1
            - とすると辻褄があう



## 差分更新をする数え上げ
- K = 1, 2, ... , nについて問題を解けと言う時
    - Kの変化であって、変化量が小さいような変化順があれば、その変化順に従って求まる
        - 最も典型には K = 1, 2, 3, ...


- 基本的に、なんらかのテーブルや値を維持・更新していく
    - 途中で、テーブルのある部分の値が意味なくなったりする
    - **ここで、意味のなくなった値について考察してはいけない/必要な値が正しいかだけ考える**
        - 何を考察すれば良いのか？
    - 及び、テーブルの値について、途中で意味がなくなった（必要が無くなった)かと思いきや、その後再び正しい値が必要になる場合がある
        - その時は、必要になったタイミングで、正しい値が格納されているか考える
            - 途中を考えない
                - どうなっていれば良いのかわからないため

- [例題](https://atcoder.jp/contests/arc174/tasks/arc174_e)
    - 典型:セグ木の1項が変化すると言う時、値の変化があるような区間の右端は一意
        - 特に、左端 = 0等で固定なら、区間は一意
   
        - よって、その区間の値を用いて計算する値だけ更新すれば良い
        - 　また、2項変化する場合であっても、その変化が打ち消すような変化であれば、変化の右端は一意
            - +1, -1と

    - 問題に戻る
        - t固定を考える
            - 桁dp?
            - tを含まない方を数えた方が良さそう
            - よく考えると、dpの各段階において、他のdpの値が必要ない
            - テーブル
            - 「ここで初めて小さくなる時の、場合の和」
    - tが変化した時の変化は小さい・ない時があるが、綺麗な対称性はわからない
    - tが1変化した・banの数字が1大きくなった時を考える
        - テーブルの各値について、変化するテーブルの値は一つだけ
            - 以下もカウントなので、テーブルに載ってない1がある場合に注意
            - 0-indexedと個数の関係に注意
        - また、テーブルの後半について、必要になったり必要にならなかったりする
            - 再び必要になった時を考えると、うまく更新できている
            - そのテーブルの値が必要という条件を入れることで、(選択肢) * (後ろの並び(定数))が格納されていれば良いとわかって、選択肢の数字は確かに正しくなっているため

### 全てのprefixについて求めよ
- 差分更新の考えを使うことが多い
    - 数列がほとんど変化しない -> 新たにaddした要素による変化を考える
## 敢えて立式しない方が簡単な数え上げ
- 代表: 組み合わせ的な数え上げ
- 入りそうなもの: 組み合わせ的な物、数え上げる対象の条件が簡潔に表せる物(特に、生成手順ではなく、満たすべき条件が与えられる物)
    - 対応を用いることもある
    
    - 順列であって、i, jに対し、「(i <= k <= j), P[k] >= P[j]」
        - 言い換え: P[j]がP[i]....,P[j]の中でminである
        - 数え上げ: 全ての順列に対し、P[i]...,P[j]を抜き取ったものを考えると、P[j]がその中でminであるものが1つあって、つまりN!/(j-i)+1 みたいな感じ


- 2つの要素のペア
    - N!通り
    - 行列のdetと近い式をしていて、実際利用できる場合がある


### 具体: 連結成分の数え上げ
- そのまま考えて出来そうならいいが、dpしたいとなった場合、連結性をどうやって持つのかが問題になる
    - 難しい場合が多い

- 別のものの言い換えにしよう
    - case1: 列上のグラフ o-o-o  o-o o-o-o
        - 切れ目ごとに、連結成分数に寄与 + 1
            - 切れ目ごとのキヨを数える問題になる

    - case2: 木、森
        - 辺ごとに、連結性分数に寄与 - 1
            - 辺の本数を数える問題
<br><br>

# 期待値/確率
## 「今までの」ではなく「これからの」を持つdp
- **期待値を求める問題では、多くの場合で「これからの」期待値を持たないと上手くいかない**
    - 今までの、で期待値を求める場合、条件付き期待値になってしまう。よって、前の状態の中でも「この状態から来た可能性が高い」と言った差が出来得る
    - よって、各状態ごとに確率も持たないといけない
    
- 期待値を求めるdpでは、1回の遷移で状態が変化しなくても良い場合が多い
    - 右辺と左辺に共に未知数が入ったとしても、式変形で消せる
    - よって、「1回の試行」をもとにdpの値を求めていくと楽で良い
    - [例題](https://atcoder.jp/contests/arc016/tasks/arc016_3)

## 初手の試行の結果で場合分けすると問題が小さくなって解ける
- 必要な事:　初手の試行で場合分けすると、問題が小さくなる事。および、全部計算できる程度に状態数が少ない事
- いつ考える: 線形性での分解とかよくわからない時・方針に困った時
    - 上の「これからの」に発想が近いと思う
    - [合計がX以上になる最小のiの期待値](https://atcoder.jp/contests/abc382/tasks/abc382_e)
        - これからの、で考えても解ける。状態は「これからX枚取る」
        - 初手で場合分けしても、問題のサイズが小さくなってる。上と全く同じ。
## 期待値の線形性・寄与の分解
$\sum$で表される(例:個数や回数)期待値について、それぞれの要素について、**独立に**期待値を求めた後和を取って良い。
- 使える必要条件
    - 分解したのちのそれぞれが求まる事
    - 分解したら計算するものが多くなるなら、全てについての和が高速に求まる事
- いつ考える: 期待値で、状態が多い時
    - ほぼ毎回考えて良いが、素直に定義に従って分解できる程度に単純なら、定義から求める（分解しない）方がよいこともある[区間転倒数がわかれば定義通り求まる。かつ、分解した時高速に求める術がよくわからない](https://atcoder.jp/contests/abc380/tasks/abc380_g)

- 基本的に、独立で分解したほうが解きやすい。
    - 独立性より
    - よって、求めるものを、できるだけ「要素ごとに+で結合されるような・要素ごとの重みの和で表される」式で表したい。
    - 表示が一意でないなら特に。
        - 例: 順位の期待値を求めるとき、 i * (i位の期待値) とするより、 $\sum$ 要素iが自分より前に来る確率 とした方が分解しやすい。

- dpと分解は独立なテクではない
    - 要素の個数の期待値について、要素毎に持っている確率を求めるとして良い...[例題](https://icpc2024.jag-icpc.org/icpcdomestic/contest/all_ja.html)
    - 操作の回数の期待値について、それぞれの操作毎に行われる確率を求めるとして良い...[例題](https://atcoder.jp/contests/awtf2024-open/tasks/awtf2024_b)
- また、本当にこの言い換えによって独立にしてしまって良いのかの保証は、期待値の線形性を用いて行えば良い

    - [E[X^2] <- 2要素の積](https://contest.ucup.ac/contest/1817/problem/9530)
        - [![スクリーンショット 2024-10-26 16.37.15](https://hackmd.io/_uploads/HyanE4qlJx.png)
        - ![スクリーンショット 2024-10-26 16.42.28](https://hackmd.io/_uploads/B1BAVN5xJl.png)


    - [グラフが消滅するまでの期待値<-頂点vが選ばれる確率の和](https://atcoder.jp/contests/agc049/tasks/agc049_a)
        - SCCにしてDAGにして良いが、そうしたとしてもdpはむずかしい
            - 状態が多いし、DAGというだけでは不十分
                - 状態が多い+期待値...?
            - 線形性による分解を考えよう
            - 頂点vが選ばれる確率...求まる！ 
    - [それぞれの飴が選ばれる確率への分解](https://atcoder.jp/contests/abc215/tasks/abc215_g)
        - 具体的な番号は本質ではなさそう:個数の分布にして良さそう
        - それでもdpは大変
        - 種類数も$\sum$なので、分解を考えよう
        - kこ選んだ時種類iが選ばれる確率の和として良いか？
            - 独立性とか怖い？
        - $\mathbb{E}[\sum (存在するか？)]$から出発して、そのsumを外に出せば良い
         
- [寄与の分解を目標にした条件の整理](https://atcoder.jp/contests/abc149/tasks/abc149_f)
        - 木DP?
        - 期待値を求めるに何が必要？
        - よくわからないので、キヨに分解できるかを考える
        - 個数のsum...分解できる
            - 計算できなければ意味がない
            - 頂点vが穴あきになる条件を考え、立式すると、求められることがわかる
独立なら、積についても分解して求めて後で掛けるとして良い。

## 状態の分解（定義より）
- $\mathbb{E}[試行で発生するスコア] = \sum_{試行が取りうる状態} \mathbb{P}(試行がその状態になる確率) \times \mathbb{E}[その状態から遷移する直前までで試行で発生するスコアの期待値]$
    - 嬉しい:状態 -> 状態の、細かい遷移を考える必要がない。状態を固定した時、その状態になる確率と、そこでの期待値がもとまれば良い。
        - 遷移を全て計算するには状態の情報が大量に必要だという時、dp[状態]:=そこからかかる期待値 というdpだと計算量が爆発する。
- 必要なこと: 状態の分解を固定した時、それに至る確率と、そこから遷移するまでに発生する期待値が計算できること
- いつ考える: 上記のようなdpを立ててしまい、困った時
    - 多くはシミュレーション的な試行でこの状況になる。
- [木におけるシミュレーション](https://atcoder.jp/contests/arc150/tasks/arc150_d)
    - まず、線形性より「各頂点が選ばれる回数」を求めれば良い
    - すると、他の頂点が選ばれるのは期待値に関係ないから、無視（起こらない）として良い
    - 列の問題になった（元が木なので列に制約が着くかも、ということは覚えておく）
    - dpしようとすると、遷移の計算にどうしても集合が欲しくなる
    - 状態で分割しよう -> 先頭の白の位置を固定すると状況が固まる
    - この時の期待値は1だし、確率も計算できる


### シャッフル
なんかすごいランダム  

シャッフルした要素の中から1つ選ぶ <-> シャッフル範囲内の要素からランダムに1つ選ぶ

### 分解典型1: $\mathbb{E}[試行の回数]$
- $\mathbb{E}[\sum X_i := i回目の試行をしたなら1, else 0]$ の形に落とす。すると、$期待値 = \sum i回目の試行をする確率$ になる。
    - 分解したところで、それぞれが関わり合っていて高速にもとまらないなら、あまり良くないかも

### 分解不可典型1: $\mathbb{E}[max(X1, X2...)]$
- 分解できない
    - かと言って、期待値の定義通り分解してももとまらない場合がある
    - そういうときは、E[max(X1, X2...)] = $\sum_i (P[max(X1, X2...)] >= i) $ を用いると良い
        - maxの条件が、要素ごとに独立になって、愚直に定義通り展開するよりおそらく考えやすい

### 分解不可?典型2: $\mathbb{E}[\sum X_i \ge K となる初めてのi]$
- 双六とかである
    - 初手で場合分けしても良いし、「これからのdp」（再帰的なdp）で求めても良い

## sum / 場合の和 の還元して、sumを求める
- 分解するよりも、こちらを考えたほうが楽なケースがある
    - 楽で無いケース <- [グラフの削除回数の期待値](https://atcoder.jp/contests/agc049/tasks/agc049_a)
    - 少なくとも、積の和典型を使おうと思うと、コレをすると格段に見やすい
    - 積の和典型は場合の和を経由する



## ループの解消
- 漸化式ではループを持つ時の解消法
    - 0: 移項する
    - 1: ループの1点を、漸化式とは別の方法で求める
        - 計算量を多くかけても良い場合が多い
        - 元々求まってる場合も多い
        - [連立式を、端の1点で解消する](https://www.facebook.com/codingcompetitions/hacker-cup/2024/round-1/problems/C)
            - dw[x] := minとしてwを経験して、今xもつ時の期待値
            - とすると、dw[x] = f(dw[x+1], dw[x-1])の式が立つ
            - ただし、dwについて、上から辿ることで dw[x]とdw[x+1]の関係を復元できる
            - 漸化式の要領でどんどん関係を下げていって、最後 dw[w] = f(dw[w+1]) の式を経て、そこからdw[w]とdw-1[w-1]の関係を立てる
            - 降っていくと、dg[g] = 0だから、そこからdw[w]を出す
    - 1-2: 1次式を持つdpでやって、だす
        - 巡回の解消がとても無理な場合
        - (1) : 1次式の形で全て表す
        - (2) : わかっている等号からxを導く
            - 期待値... ax + b = cx + dとか
                - 等号
            - 確率... a0x0 + a1x1 + ... + anxn = 1の連立方程式を解くとか
                - 確率sum = 1
                - 特に, ax = bx ならばx=0であり、これが出た場合勘違いしている可能性が高い
                    - ループの1箇所でだけうまくいかない漸化式を考えているとか
                - [そう言うことする](https://atcoder.jp/contests/abc271/submissions/61217870)
    - 3: 循環 -> 回数の情報をつけて、無限和にして、公式から計算
        - 考察重め、実装軽め、いつもできるかわかんない
            - [循環を無限和にする](https://atcoder.jp/contests/abc271/tasks/abc271_g)
            - まず、dpの遷移を「アクセス」にする事で、最後に押したのが誰かの情報がいらなくなる
            - dp[i][j] := jから判定始めた人が、次に判定始めるのがiであるような確率
            - 循環が発生 -> ループを回数で分けよう
            - 無限和になって楽。1次式を持つdpとかいらない。

## 条件付き確率が厳しい時、問題の言い換え/dpの言い換えで対応する
- dpの設計によっては、「この操作でooが起きる時の操作回数の期待値」& 「この操作でooが起こらなかったという条件のもと、操作回数の期待値は何か」が知りたくなる場合がある
- 難しい場合がある
- そのような時は、dpを言い換える事で、「ooが初めて起きるまでの期待値」だけを必要とする、というテクニックがある
    - case: 幾つか独立な要素があって、それぞれについて1回以上ooを達成したかが重要な時
         - ooを達成した場合と達成しなかった場合で分けると、どうしても達成しなかった場合の期待値が必要になる
         - どうしよう
         - ooが達成されることを1段階とすると、「達成した時にした場所が、ooをすでに達成してたかornotの確率がわかれば良くなる」
<br><br>

## 対称性
- 必要な条件: 2要素間に対称性がある・状況が全く同じである
- いつ使う: そういうのが起きる時。特に、点が移動していく問題では起きやすい。
    - 例: ランダムにワープ...最初にいた場所以外は等価
    - 例: 直線上を左右に動く...左右に動く確率が同じなら、それは対称
        - 特に、期待値ならばこれは打ち消しが起こる可能性


- 何かしらの値の重複・遷移の共通化による高速化
    - 小さい値でこれらを期待しながら実験する
    - 確率・期待値が同じ事に気づく
        - [どの要素についても値が同じなので、指定する](https://x.com/chokudai/status/779160353498279936)
            - 元の場所にいる確率は変わらない
            - 要素1について求めればよく、考えやすくなる
        - [どの要素についても場合の和が同じなので、総和を求める](https://atcoder.jp/contests/arc059/tasks/arc059_d)
            - 元のdp...[今の長さがi][j文字目まで一致]
            - どのSについても場合の和が同じ
            - 操作を求めることにすると、dpの情報が減る
        - [同じ値をもつ状態をまとめる](https://atcoder.jp/contests/abc360/tasks/abc360_e)
            - 2...N の位置に黒いボールがいる確率は変わらない
    - dpで持つ情報の削減につながり、全探索が通る

- 独立に動けるようになることによる高速化
    - 2重シグマについて、 $\sum_i \sum_{j < i}$ を $\sum_i \sum_j$ にする事による高速化
        - 重要な公式 : $\sum_i^n \sum_j^m A[i]A[j] = (\sum_i^n A[i]) (\sum_j^mA[j])$
            - $O(N^2) が O(N)$になる
            - 頻出
            - [対称性を利用した公式](https://atcoder.jp/contests/arc106/tasks/arc106_d)
                - Σの入れ替えも纏めよ
                - 2項定理と併用

- 数え上げの単純化
    - [例題](https://atcoder.jp/contests/arc167/tasks/arc167_c)
    - 寄与の分解を決めた
    - 以上、以下しか本質的に関わりがない
    - 以下、以上をそれぞれ同一視して、最後に並べ替えの通り数の階乗をかけることにする
    - さらに、ブロックとして「xoP」「oxP」 「oPx」 「xPo」 「Pxo」「Pox」とした時のそれぞれの場合の数を数えたい
    - 対称性より、全て同じ
    - ブロックの並べ替えの通り数をかければ良い

<br><br>

# 最適化
## ノイズとなる要素の排除
- 考察の上で、「明らかに無駄な要素」は邪魔になることが多い
    - これを考えるせいで綺麗な貪欲がないなど
- そう言うのは最初に排除した方が良い
- しかし、これは結構時間と労力が要る
- しかし、問題の見方を変える事でその作業が「明らか」の1声で済む場合があり、積極的にしようね

- 2パラメータ -> 平面プロット
    - 実数係数なら
    - 2要素の組み合わせ -> 線分
    - 3要素以上 -> 平面
    - 無駄を省く -> 凸包
    - に対応しがち
    - (こう言う都合で、inf・極限->実数に言い換えが良い)

## 判定問題に落とす
- 非自明な問題の簡略化の恩恵がデカすぎる
    - 目標が定まらないと、それに向かった貪欲も生まれない
- やっぱり辞めるかの判断は、直接求まりそうと言う前向きな動機がある時で良さげ


## 全探索できるものは全探索する
O(1)で答えを出そうとしない
- 最適解になるうる答えの構造として、特徴的なのがいくつかある
    - -> 最適解はどの形なのかを考えるのではなく、全ての形について最適解を出して最後に比べる

## 最適解の構築⇔全探索
- 最適解の構築→全探査
    - とても綺麗な構築が無理だと思った時
    - 貪欲や、「この解は無駄」という事実が見つかっていれば、探索に活かせる
        - [例題](https://atcoder.jp/contests/arc116/tasks/arc116_e)

## 判定/固定問題を解く
- 必要な事: 何か（特に: 答えを）固定した問題が（簡単になったことによって）解ける事・その固定を全体に動かせる事
    - 固定の旨みは上に書いた。
- いつ考える: 詰まったら常に。基本姿勢。貪欲やしなくて良いの利用・選択肢・条件を全て見ないは、探索空間を狭めてこの探索を高速化するためのテクニック。
    - 一意に定めて良い -> それを決定する、も考慮すべき対象を狭めていると考えて良いかも
    - 特に、「貪欲によって答えをすぐに求める」事はできないが、答えを固定した時の判定は簡単に解ける&&判定を（二分探索やそもそもの愚直で）回しても間に合うというコースは非常によくある。


- 結果を固定した時、その結果は実現可能か？を考える
    - これが解ければ、その結果を直接全探索したり、あるいは判定に必要な情報だけを全探索することができる
        - 特に、重複とかを考えなくて良くなる
    - **日本語で終わらせずに、ちゃんとアルゴリズムにすること**

- [最適化の貪欲はないが、固定した時の判定は簡潔に解ける](https://atcoder.jp/contests/abc143/tasks/abc143_f)
    - distinctなN人グループを作る。最大何グループ作れる？
        - 判定はすぐ。貪欲はない。
- このooが(例 : 連続部分列)条件を満たすことは可能か？
    - [例題](https://atcoder.jp/contests/arc132/tasks/arc132_d)

- 判定問題に単調性があれば、二分探索できる
    - 時には単調性を持たせるために、判定問題を少し変形する必要がある
    - 変形した判定が解けなくても、そもそも判定回数がそれなりに収まるなら、元の解きやすい(: 答えを**丁度**、あるいは何かしらの形で xにできるか) 判定問題を解けば良い
        - [例題](https://atcoder.jp/contests/arc126/tasks/arc126_c)

- [上界の利用]明らかにこれ以上は無理という結果が得られた時、逆にそれを達成することは可能か？
    - 自由度が高い状況では有効


- 最適化において、「取りうる値が複数種類ある時、値を選択する事による副作用がないと仮定すると、最高をとることを確定できるなら即座に確定して良い/ 逆に、今は最低しか選べないなら後回しにして良い」

## 上界・下界の利用
- まず、答えはOO以下。かつ、OOを達成できる。と言う論調
- 必要なこと: 上手い上界ができて、かつそれを達成できることを言える
- いつ考える: 
    - 探索の自由度や答えの形の自由度が高くて困った時
        - 自由度高いならいろんな結果が作れる -> 上界も作れそう
    - 特徴的な要素に注目した結果として
        - その要素が全体の結果を左右するなら、その要素のみによって結局決定される場合も多い
            - [木の次数列を固定した時の直径のmax -> 次数 = 1が支配的な制約]


- n個sum
    - [1, 2, ... , n]
    - [1, 2, ... , n-1, n+1]
    - [1, 2, ... , n-2, n + 1, n + 2] or [1, 2, .. ., n - 1, n + 2]
    - ...

## しなくて良いの利用・自由度の制限

最適を取らないような探索を省いて良い。そのために、「ooしなくて良い」「ooとして良い」のような貪欲が見つかりやすい
- 必要な事: 最適化の観点上、しなくて良い探索がある
    - 特に、全体の形に対するものでなくても、特定の部分に対して「OOは連続しなくて良い」等は多い
- いつ考える: 最適化で高速化に悩んだらいつでも


- 自由度が制限され一意になることにより、状況が簡潔になって考察し訳すなる・全探索ができるようになるのが旨み
- [変な動きを考えなくて良い](https://atcoder.jp/contests/arc064/tasks/arc064_c)
    - 最適化であり、バリアの中の動きはスコアに関与しないのでどうでも良い
    - また、バリア間の移動はmin距離でするとして良い
    - もう全探索できる


- [次元が異なるイベントについて、次元を跨ぐような(独立でないような)動きをしなくて良い->次元で分離](https://atcoder.jp/contests/arc044/tasks/arc044_c)
    - 無駄なこと:ビームを避けたのちに過剰に動く/ビームが来なかったのに動く
        - 動きが単純？何より、dpの更新が減らせそう
    - 無駄なこと:次元を跨ぐ動きを一度にする
    - これによって、貪欲かつ次元の削減
        - 計算の時は、dpとして「時刻tにiにいる」を持って、貪欲よりビームが来なかったら動かない、を元に更新を省く) 

### 同じ結果を2種類の操作で得られる -> 片方の操作の制限
- 片方の操作をしないとしてよい
    - [1項に-3と、3項に-1](https://atcoder.jp/contests/kupc2024/tasks/kupc2024_m)
        - 3項-1を3回すると、「その3項それぞれに-3を行った」と見ても良い
            - 同じ結果が得られる
        - よって、「3項-1は、同じ場所にはせいぜい2回しか行わなくて良い」として良い
            - つながりが弱くなって、両側からdp

### 目的関数を最大化するように並び替えろ
**何かしらの比較関数でsort**
  - 比較関数の作り方
  - [1]**隣接する**2つの要素について、どちらが前に来るべきかの判定関数を書く
      - swapした時の影響を数式で書くhttps://atcoder.jp/contests/npcapc_2024/tasks/npcapc_2024_h
- [2]その順序が、推移律を満たすことを確認する

さえすれば、その隣接要素の判定をそのまま比較関数に用いて、sortしたものが最適であることが言える。
- [参考](https://drken1215.hatenablog.com/entry/2022/12/16/194300)


 - 極端な物を見た時、「後ろに・前に持って行った方が良さそう」という感覚がある時に有用


- [例題](https://atcoder.jp/contests/arc088/tasks/arc088_c)
    - 最終的な対応のペアは一意に決まる
        - 予想:貪欲がありそう、並び替え-> sortに帰着？
        - 素直には、答えの順序を考える。
    - 回文は左を定めれば一意に決まるので、左の並びを決定することにする
        - 外側のを最終的な位置でも外側にする貪欲が良さそう...
    - 最終的な位置が隣り合うペアを考える
        - 示し方1 : 座標を置いて、計算
            - 直前の盤面からのコストを計算する
            - 時間がかかる
            - 隣接swapでは、外側から合わせるとして良いという貪欲を用いる
        - 示し方2 : 隣接swap_sortの自由度
            - 自由度: 端から合わせるなんてしなくても、転倒数が減少するようなペアを任意の順で隣接swapしていっても、最小回数で達成できる
                - ただ、選択肢が変化するかもしれない
            - そこで、最終的な位置のグループが分かれたことを利用して、大雑把sortの前処理をしてしまう
                - していいからね
            - すると、あとは同じグループ内での隣接swapだけを考えれば良い
            - Aの中でのswapはしなくて良い。

- [例題](https://atcoder.jp/contests/arc050/tasks/arc050_d)
    - 隣接文字列のは S + T < T + S が推移率を満たすことを示せる
    - よって、それを判定するだけ

### 関連: 順番を入れ替える: sortする考察
隣り合う2つについて、入れ替えても良いことを言えば良い
- [例題](https://atcoder.jp/contests/arc151/tasks/arc151_d)
    - 簡略化: Xiの値が不変の区間について、高速にできる
        - 入れ混じるのが大変
    - エスパー: Xiについて、クエリをsortしても良いのでは？
        - Xiが異なる隣り合うクエリについて、入れ替えてもok

## ある選択肢について、決定をのちに保留しても良い時
どの選択肢を取ろうが、後の選択肢が変化しない時
- この場合、必要になった時に初めて選択肢の中から決定できる
    - すると、「今保留している選択肢の中で最適をとる」という貪欲ができる
- 保留せずに一意に決めていいなら、今決めてしまった方が影響の前計算ができて速くなる事が多い

## ギリギリになったら、今までの選択肢の中から最善を選んで補給する
未来がわからないので、今貪欲に補給してはいけないかもしれない時


## 最短経路への言い換え
- 何が嬉しい: DAGでなくともO(|状態数+遷移数|log)或いはO(|状態数+遷移数|^2)ぐらいでテーブルが求まる
    - つまり、DPできなくても答えが求まる

- 必要なこと: (1)始点(すでにコストがわかっている点)があること (2)各状態間での遷移のコストがわかっていること (3)状態数+遷移数が間に合う程度に小さいこと

- [そのまま:最短経路への言い換えで解ける](https://atcoder.jp/contests/arc064/tasks/arc064_c)
    - それぞれのバリアに入るまでのコストがわかる
    - 始点もバリアだと思うと始点が生まれ、終点もバリアだと思うと所望の結果も得られる


## 時系列逆に言い換える
- 今の選択が、後の選択によって塗り替えられる時
    - 嬉しい:最終的に残す部分以外はなんでも良いことを反映できる
        - 最終的に残る要素から決めたい、を形にした一つ
        - 保留させてほしい
    - 数列の置き換え...
        - 後ろから見て、ワイルドカードを導入することによって、この命題を利用できる

- 選択肢を選ぶ条件が「選択肢を選ぶ直前において」では異なるが、直後においてでは一致する時
    - 直前においてC以上なら、-Cして良い
        - 直前の値に対して、状況の良さがが単調でない
            - 少し高い方がマイナスできて生き残れる,等...
        - よって、様々な状態を持たないと前からdpなどできそうもない...
        - 単純にするには、選択肢を全て固定するぐらいしかないが、ここまで固定すると同時にシュミレーション、ができない場合が多い
    - 逆から: +Cして良い。ただし、直後において、0以上でないといけない
        - 直前の値は大きいほど良い
            - 貪欲が生まれる


- また、「順方向にやると操作が無限に広がるが、逆にすると有限」という時、有限性から何か制約が発生 -> 一意の流れが出たりする
    - 例: 加算...+無限にいけるが、逆からにすると、最初が>0なので、 <0となるような減算はできない

- （時系列逆に限らず）言い換えは、「どちらも難しいが、一方はさらにとても難しい」という時、その一方を引いてしまうと厳しい
    - よって、難しいと思う度に反復横跳びしよう！
    - [https://atcoder.jp/contests/arc189/tasks/arc189_a]
        - 1001 -> 0000 か、 0000 -> 1001か
        - 結果的には、前者の方が簡単（0000 -> 1001 は前後で分裂してしまうが、 1001 -> 0000 は間の0を無視して良いため、状況が変化しない

- 期待値
- 要素が時間の経過によって変化していくタイプ
    - 終了の時刻がわかれば影響が決定できるというアイデア -> 二分探索
    - f(i) := 今、終了からi秒前とした時のOO と定義すると、今から終了までの時間がわかるので影響が計算できる。貪欲等すれば、上記に比べてlogが落ちる
## こちらに有利になる制約 -> 敢えて外すことによって、答えの自由度を上げる
- いつ考える:考察の過程で「結果を固定した時、実際にこれはあり得るか」を考える時、有利になるような制約のせいで、実際にあり得るのかの判定が複雑になる時
    - 最小化で min(ai, bi)を選ぶ -> ai, biから好きな方を選ぶとして良い。かつ、そうすると採用するai, biを決め打った時の実現判定が楽になる(biを使うと決めたが、実際はaiが小さい場合...の場合分けが減る)

# 最大値・最小値

## 判定問題
答えをxにできる・x以下にできるか？を解く
- 必要な事: 固定したら（解きやすくなっていてかつ）解ける事。また、その固定を全て動かしても間に合う事。
- 最初に、条件を与えられた数値 $x$ で書き直す
    - 最大値がx以下...全ての要素がx以下
    - [例題](https://atcoder.jp/contests/arc053/tasks/arc053_c)

- 目標によって（最低限）取るべき解の形が変わる時に特に有効
### 二分探索
単調性があれば、判定問題を解く回数を減らせる。
かつ、基本的に、最小値が存在するならば、「値をx**以下**にできるか？」は単調性を持つ。よって、この判定問題が解けるならば、その問題は解ける。
- 動機 : 愚直なら思いつくが、完全な愚直は間に合わないという時に、愚直を実行する回数を減らして間に合わせる

なお、常に単調性があるとはいえ、判定問題が解けなければ意味がない　例 : 無向グラフ　サイクルのサイズの最小値
問題例 : https://icpc-domestic.trap.show/contests/jag2018/　のE
- 最小値の最大化
  特にこの、「問題を二分探索によって変換する事で解ける」傾向が強いようだ。逆に、それ以外で解くには複雑な関係を処理しないといけないからかも。
  
## convex full trick
- 基本アイデア：傾きが大きい方から見ていって、なんとかする

- 直線...convex full trick 

- 折れ線: 始点が共通...始点バラバラに比べて綺麗な形をしていて、上側の変化の計算が楽
![alt text](<スクリーンショット 2024-12-16 23.20.01.jpeg>)
### 周りの値さえ定まれば貪欲できるという問題
- 最短距離への帰着

- 値を定める制約にDAGの構造→順々に決定
    - [例題](https://atcoder.jp/contests/abc368/tasks/abc368_e)
        - 辺iに制約を課すのは、T[j]<=S[i]を満たす辺jだけ
        - 制約の関係がDAG
        - 制約がかかってないから貪欲に決定していく



### maximize  x ⇔ minimize -x
- [例題](https://atcoder.jp/contests/abc368/tasks/abc368_e)
    - 牛げーの特殊版(制約がdag)
        - しかし、特殊版なので、上記の言い換えをすることで牛ゲーの枠組みでも解ける
        - $O(M^2)$の辺ができるので間に合わない


## 単調性/区間
- 単調性は嬉しい性質

- 単調性を持たないが、似たものがありそう <- 区間になっているケース



### 大きくなりうるスコアと上限が小さいスコアの加算
- 大きくなるうる方をB, 小さい方をSとすると、スコアが小さい方ではSの影響が大きいが、Bが大きくなってくるうちにSの割合が小さくなっていく
    - よって、Bの大小でスコアの大小が決まるようになる
        - 枝刈りになる
    - [大きい方はN^2,小さい方は高々N](https://atcoder.jp/contests/arc052/tasks/arc052_c)
        - 全探索したい
        - 情報が多い
            - 前もって処理とかも浮かばない
        - 小さい方は高々N
            - Bが大きくなったら、それより大きいBは無視できるはず
            - B' - B > N
            - これを元に、Bの範囲は√Nぐらいでok
            - 前よりスコアがデカかったら省く、をすればok 

### 複数のオプションと、それぞれにスコア
- ある選択肢であって、他の選択肢のスコアのsumより大きいのがあったら、それを貪欲にとって良い。
    - 2値...値がでかい方を貪欲にとって良い。


<br><br>

# 証明

## 貪欲
- 任意の最適解を持ってきた時、初めて貪欲から外れる点に注目して、そこを貪欲ベースで選ばれた選択肢に置き換えても解が悪化しないことを言う

- その選択をした後の状況に注目して、「今最善をとっても状況が悪化しないのでおk」をいう
    - のちの状況が単純で、良い・悪いが比べられる時

- 答えが存在するならば、その答えを変形して貪欲の形にできることを言う
    - 条件を満たすように構築せよ、系で有利そう

- ある操作について、「いつかしなければならず、かつそれをするまで、その操作に関わる部分の状況が変化しない（周りと独立？）」時、今すぐして良い
    - いつ考える: 操作ができるならば、今すぐして良いの証明

- （ある特徴量によって）上界が示せて、それにそうならその操作が最適
    - 操作の最適性を言いたくて、いい感じの上界がある時  
        - 操作によって動きが大体一様なもの/どんな操作でも一定量変化するものを選ぶと良い。特に、必ず+1 -> 操作回数の下界

- 特定のシュミレーションに従って得られる解が最適
    - そのシュミレーションの自由度の中に、最適解が存在する -> そのシュミレーションにおいては、指定の方法が最適である
    - 自由度のうち、1つ決定できる物がある -> 決定 -> 小さいのに帰着、の連続と見る

- 複数の自由度のうち、ある自由度について決定して良い
    - そうでない最適解を持ってきて、その部分だけswapしても悪化しない事を言う

- 最適解のうち、OOであるような最適解が存在する
    - OOを固定した上で、残りの部分について最適化すれば、それは最適解の1つ
        - 特に、「残りの部分」に再帰的に解法をapplyしたいので、前提条件は明記した方が良い。

- 2方向の自由度がある -> 全部を極端な物で初期化して、それを減らしていく一方向で考える（1方向の改善のみを考える）
    - 全体に総和制約 && 日毎に累積和で総和制約 最適化[例題](https://atcoder.jp/contests/abc250/tasks/abc250_g)
    - 全ての日を最適な選択肢で初期化 -> 日毎にこれまでの解を改悪する事で制約を満たすようにする
    - この時改悪の選択肢を貪欲に選ぶ
- 複数の要素がある状況で貪欲したい -> 考慮する要素を順々に減らしていく方針にする
    - 極端なやつについて決定 -> 無視できるならもうその要素は無視

- 困ったら
    - 場合分け
    - 特に、対象の個数が小さい時はできる
    - 前提条件はちゃんと明示する
        - 特に、再帰的にくり返す系

## 必要十分条件
- 最後の操作に注目 -> 最後の操作はそのまま残るので、それにつく必要条件が考察しやすい
    - 操作をしていく/置き換えていく系で、可能・不可能の必要十分条件を考えるならば、常に有効

## 同じと見做せる -> 制限
- 同じと見做せるものは、「条件を満たすか」「最適か」を考える上では、制限しても良い

- 特に単位元的なものは好きにadd/削除して良い
- 例
    - a + b or a ... a を a + 0とすれば、常にa + bの形で操作を表せる

### 2つの操作列から同じ結果
- 片方の操作列は発生しないとして良い
    - 操作1をx回 = 操作2をy回 -> 操作1はx回未満

## misc
- 手続き型の記述の証明 -> その手続きによって得られるものを条件の形に落として、そこから議論
    - 常に最適が示せない時に考える
    - 例えば: 作れるものの必要十分条件は、この手続きで得られるもの <- 距離が遠くて考えづらい>
        - この手続きで得られるものとは？を先に解く解く
<br><br>

# 状況が変わる部分で問題を区切って、変わらない部分は一気に求める様な計算
- 必要な事: 状況が変化しない範囲での答えが出せる
- いつ考える: 状況が変化する時・情報を持って探索するが、必要になる情報が途中から変化する為たくさんの情報を持つという時
    - 例えば、最初の方は初期HPを使い、途中から回復するという時、両方をまとめて処理しようとすると「今のHP、回復量」の2つのパラメータが必要になる
    - しかし、初期HP -> 回復ゾーンでそれぞれ分けて計算したのち、初期HPが切れるタイミングを全探索して状態を合わせる事ができれば、持つ情報が1次元に落ちる
    
<br><br>

# 選択肢を全て列挙しない・条件を全て確認しない
- 必要な事: 求めることが「全ての自由度の対してある値」なのでは無いこと。例えば「最適な値」であったり、「何かの判定に必要な値である」こと。
- いつ使う: 愚直に全ての選択肢を試してそれを集約しては間に合わないが、上記の条件を満たす時。
- よくある手法: 最適なものから「選択肢になりうるか」を試す。選択肢になりうるなら、そこの自由度は確定なので、その自由度を考慮から省く。

- $n \times n$ ペアの探索対象 -> 全ての $n$ に対して、理想な相手を探す

## 二分探索による高速化
判定の回数がlogになる。
## 並列二分探索
シュミレーションを完了するのはある程度まともな時間に収まる　かつ　独立な二分探索をたくさんしたい時に使える

### 各選択肢について、そこで取れる選択肢のうち最適なものだけを計算する
- 必要な事: 愚直に全ての選択肢を列挙している状況において、ある選択肢を取る事を固定したら、その自由度の中でも「これを取れば良い」という一意な選択肢が存在する事
    - 固定みたいな
        - 内側の選択肢を消す

    - 選択肢になりうる、未確定の自由度の検知が高速にできれば間に合う
        - [全ての開始位置を探索](https://atcoder.jp/contests/abc268/tasks/abc268_h)
            - 素直: 全ての文字列について、全ての開始位置について、そこから始めて含まれるかを計算すると間に合わない
                - 一つの開始位置について、そこから含まれるもののうち、長さが最短のものだけ考えれば良い。
                - これは貪欲より成立

### top2だけ持つ探索
- 必要な事: 「いくつかの選択肢から最適を選ぶ」という時に、例えばtop2の選択肢さえ求まっていれば良い(的する方を選ぶ等)なら、それだけを求める（ダイク小さい方から）探索をすることによって、全ての選択肢から全ての対象への値を求める事をしなくても解ける
    - 特に、全ての選択肢について最適な値を出さなくて良い事を使える
        - 最適な選択肢について、その値を求めるというのは頻出
    - 最適化ならば、小さい方から・最適な方から求めるというのはダイクストラ方
    - [人気者を始点に、国でまとめるとそう](https://atcoder.jp/contests/abc245/tasks/abc245_g/editorial)
    - 
<br><br>

# 構築
## どうなっても良い（決定を自由度として保留しておく）のは構築において便利そう
### 不変量の見つけ方
典型的な不変量を頭に浮かべながら実験する。

### 典型的な不変量
操作によって、全体として必ず減る・必ず増えるもの・常に不変なものを考える
 - 個別の要素間では増えたり減ったりするかも知れないが、全体では減る事がある

- **何かの偶奇**
    - 和の偶奇、差の偶奇、個数の偶奇...
        - 0にしろ...最終的には偶数
        - 操作できない状態...偶数・奇数・あるいは個数
            - ゲームを不変量で解析するときに頻出
- 大小が制約に関わる(sort, swapの条件)時、転倒数を見るのは良い
- 数列の和、mod M

- bit/ bit演算
- b進数表記した時の桁の数について...
    - [例題](https://atcoder.jp/contests/arc145/tasks/arc145_d)
- +1と-Nをする操作... mod(N+1)で、一様に+1 
    - [例題](https://atcoder.jp/contests/arc079/tasks/arc079_c)
         - 任意の順で操作しても答えが変化しない事の証明
             - 任意の順で最小A回→定められた順でもA回、を証明する...総和とmod(N+1)の一致より、数列一致

或いは、何かの証明をしたい時に、"これは不変なので、これ以上は操作できない・これ以上この遷移が走る事はない"の主張で使える
 - その時も、"その操作で"全体で不変・増加・減少しているものを見る

### 典型な必要条件
- 不変量に注目した必要条件

- 最初の操作による必要条件

- 最後の操作による必要条件
    - 途中は自由でも、最後だけはきっかりとした事が言える場合

### 典型的な"綺麗"な操作・事実
小さい操作
- 一致させよ
    - +1/-1できる...
    - swapできる...
        - 特に、隣接swapさえできれば任意の並べ替えを作れる
        - [例題](https://atcoder.jp/contests/arc183/tasks/arc183_b)
                - 最終的な位置に注目
                - 各要素の相対的な位置を隣接swapで合わせていけば大体できる
大きい操作
- 一致させよ
    - sortできる...
    - 種類の違うものを前後に分割できる...
- 最適な物を構築せよ
    - 上界が達成できる...
        - 上界を作ることだけを考えれば良く、目的が定まって嬉しい
- 数列SをTにせよ
    - 先頭から合わせる事で高々定数項を残して一致させられる...
        - 残った数項は不変量で評価

- **多方向から考える**
    - 片方で詰まったら切り替える
    - [例題](https://atcoder.jp/contests/agc067/tasks/agc067_a)
        - 大きいクリークがある || 補グラフで3角形なし

- サイズが大きくなるとだめ・常にok
    - ダメなものを貪欲に取ると、maxが指数オーダー
    


#### "できる事"は丁寧に集める・早とちりしない
- 時間の浪費
- 回数制限クエリ系、 $O(???)$でoooが求まりそう...本当にそのオーダー？
    - 丁寧に見る事で、応用にも繋がる
    - 誤った考察を元に考えるのは本当に時間の無駄

## 存在しないものを作ろうとしてはいけない/できない時がある
- 出来ない場合について「条件を満たす」手段を考えたって解けない
    - 特に条件が複雑な時、存在しない事が見え辛い
- まず、判定を先に解くべき(判定問題ならはなからこれ)
- すぐに解けないなら、必要条件を出して状況を整理するだけでも良い
    - 旨みが状況の固定化なので、これでも十分恩恵を得られる
  
- 必要条件から手が出ない場合もある
    - 「そのそも作れるものは何か・それに対応する条件の要素はどのような振る舞いをするか」というアプローチからも、必要条件を得られるし、これがクリティカルになることもある
        - 条件が複雑な時


- そういう時は、貪欲などによる「ooとして良い」を用いた状況の固定・考察が強い？


- [必要条件列挙 <- 必要条件のうち特に複雑なものについて、そもそもその「複雑なケース」は存在しない](https://atcoder.jp/contests/arc141/tasks/arc141_c)
    - まずPについてみよう
        - 必要十分条件:「正しい括弧列ならなんでも良い」区間と、「一意に決まる区間」に別れる
    - Qについても
        - 必要十分条件: 「逆向きに見て正しい括弧列ならなんでも良い」区間と、「一意に決まる区間」に別れる
    - マージしなければならない
    - 共に「正しい・逆向き正しいならok」のところをどうしよう？
        - 条件のマージの注意点: 必要条件の振る舞いは独立とも限らないし...
    - 重要な情報:作れるとは限らない！
        - 作れる条件を先に考えよう
    - P, Qを眺めていてもわからないので、括弧列である時のP, Qの振る舞いを見て、P, Qが満たすべき必要条件を探ろう
    - 括弧列をグラフにする (..+1  )..-1
    - Pのなんでも良いに対応するのは、上側の部分
    - Qにかかる条件である、「逆向きに見た」の状況は？
    - 下側の部分！
    - P, Q共になんでも良い、はあり得ない！
        - あったら即座に矛盾

- 数学の式に持ち込んで不変量を作るのが楽
    - [ドミノを置く、制約 -> 個数の式](https://atcoder.jp/contests/agc041/tasks/agc041_c)
        - 1個置く時、全体へのキヨは3
        - よって、 3 * (置く個数) = 2 * n * クオリティ
            - nが3の倍数ではない時、クオリティは3の倍数に限るとわかり、全部愚直にやるより高速に考えられる


## 判定 : 必要条件を積み重ねる
必要十分条件が直ちに出せない時に考える。
- 必要条件を足していって、十分にする
- 必要条件になりそうな要素を貪欲に取っていくことが大切
- 必要条件が増えるたびに、「これからはその必要条件を満たすものだけを考える」として、状況を再び整理する
    - ある条件が、必要条件が加わることによって別に言い換えられる場合もある
    - [非自明な必要条件 & 必要条件による条件の言い換え](https://atcoder.jp/contests/agc010/tasks/agc010_b)
        - 減る総和は一意
        - 総和がn(n+1)/2の倍数であるものだけ考える（必要）
        - 操作回数は総和 / (n(n+1)/2) に限って良い(必要からの固定)
            - 実はこの時点で、最終総和0は確定したので「全て0」が「全ての要素について、差分が0」に言い換えられる
        - これからわからないが、貪欲とかではない...
            - 必要条件方針で...
            - 他に良さそうなの...
        - 隣り合う要素の差分を見ると、-1 or +(n-1)
        - 最初に-1して、最後に選んで+nすると思う
        - この調整ができることが必要で、尚且つ上の言い換えよりこれが十分

## nが小さいケースに帰着
- n -= 1
    - 端や外周を埋めるパターン
    - 何かしらについて決められるパターン
- n -= (小さい時に可能な構築)
    - 構築を組み合わせてサイズが大きい構築が作れる時

- 帰納法的に n - 1 の時は存在すると仮定した上で、n番目を挿入する。
    - [例題](https://codeforces.com/contest/2013/problem/C)
        - p文字の部分文字列が得られたとする
        - 次の2通りを試せば、p+1文字が得られる
        - 得られない場合、端なので、逆に伸ばす

## nが小さい時の答えを利用して構築
- 割とある
- 基本要素みたいにして組み合わせる

### 利用の仕方がわからない制約・規則
- 機械で答えを列挙して、何か答えに良い性質が生まれないか実験する
    - [例題](https://codeforces.com/contest/1991/problem/D)
    - 答えを列挙が難しくても、何か列挙できるならそれを見る


### 一致・変形判定標準形の利用
一致判定に良く使う
最初の状態S,目標状態Tを共に綺麗な状態にする
- 01列...1だけの列
- この時、置き換え操作ならば、その操作の逆をできないか考えると良い
    - 逆ができるならば、もう2始点と思って良い
    - [例題](https://atcoder.jp/contests/arc071/tasks/arc071_c)

### 条件を満たす"部分"ができるように操作しろ
- [1]条件を満たす集合を選択 [2]その集合を、条件を満たすように操作 の 2段階に分けられる
    - 集合を固定した時の操作の仕方をまず判定問題として解いて、その結果を元に何を選ぶか考えたりdpする
        - [例題](https://atcoder.jp/contests/arc126/tasks/arc126_d)

## 似たようなものを複数用意する時
- サイズが大きいものを1つ用意し、それを部分的に利用するような構造にできれば、用意するものが減ってコストが減る。


## 掛け算 / 足し算
- 掛け算...「始点と終点が定まっているが、途中で分岐する」という時、その外側の経路に対して、今見ている分岐の数だけ掛け算になる
- 足し算...一つのブロックの分岐を増やすと、足し算（そこの係数に対して）になる

## 綺麗な形の利用
実はうまくいく場合が多い。
- 綺麗な形を試して上手くいかなかった時は、何故うまくいかなかったか？を考える
    - それを克服する綺麗な形はないか？
    - [例題](https://atcoder.jp/contests/arc117/tasks/arc117_d)
        - 帰りがけ順を試す
            - ダメ
            - 戻りの距離が考慮されてない？
            - in/out両方に時間を割く役をやる
            - 良さそう
            - AC

- 小さい時に「未来にも役にたつ解」ができたら、それを組み合わせる
    - [補正がたくさん聞く盤面がn=5で作れる](https://atcoder.jp/contests/kupc2024/tasks/kupc2024_b


## 存在するなら1つ見つけろ
- 鳩の巣原理
    - 嬉しい: 実質的な全探索が小さい計算量で行える
        - 存在する条件で絞れない・枝刈り全探索が無理とかの時
    - 必要: "適切な"巣
        - そもそも鳩の巣原理とは、「どのような要素もいずれかに該当する」という条件の集合を見繕った時、「いずれかの条件について、それを満たすものが2種類存在する」というものであった
        - よって、任意の重複 <-> 答えの発見 出なければならない
        - 式にすると、f(i) = f(j) のような式が一つ見つかるので、それを元に答えを構成できれば良い
    - あるいは、重複がある程度少ないなら、探索を進めることで巣を完全に埋める(:= 答えを見つける)ことができる

- 乱択
    - 必要な事: 1回の失敗確率が小さい
    - いつ考える: 条件を満たすものが（存在するならば）多い時

- 範囲を絞り込んでいく
    - 候補:= 全体集合とする。その集合を小さくしていく。 
        - 特に、候補を二分割して、「存在するならば少なくともこちらには含まれる」というのが分かれば、log回の深さでわかる
    - 必要な事/いつ考える: 集合に対するクエリが捌ける

### 集合から要素を1つ見つける: 条件を満たす要素が多い時
- 必要な事:　条件を満たす要素の個数が多い・全体からの割合で表されている事
    - これが満たされていれば、全ての選択肢を試さなくても、うまくサンプルすれば小さいオーダーで良くなる・乱択ですぐにみつかる
- いつ使う: 条件を満たすものが存在するなら1つ出力せよという時に、愚直に全ての選択肢を試していたら、その削減策(最適化の時みたいな)

- 例: 集合の部分集合であって、条件を満たす&&サイズがn / 2以上
    - そのような集合が存在するならば、適当に2要素のペアを取った時、そのペアが共に集合に含まれる確率は 1/4 <- 確定的にするなら $O(N)$通り試せば良い。
        - 特に、1つ選ぶ時は1/2 <- 確定的にするならどのみち $O(N)$通りであり、ペアを試してもオーダーが変化しない
## 埋め込み
- 無理に関数で実現しようとおもわず、視覚的に埋め込む（2次元配列とか）で、適宜コピー関数で埋め込むのが早い&&安全そう[参考](https://atcoder.jp/contests/agc041/tasks/agc041_c)
## examples 

- [マス目を01にする。個数の比を保ちつつ制約を満たせ](https://atcoder.jp/contests/kupc2024/tasks/kupc2024_b)
    - 解法1: ox, oox, ooox, oooox の基本要素を使ってA : B の列を1つ作る
    - 解法2: どっちでも良いますをたくさん作って、それを変更して作る
        - 小さい時の綺麗な解法を繋ぎ合わせる
<br><br>

### 他
- 初期状態を作っておいて変化させるという構築の場合、初期状態はシンプルなほど良い
    - デフォルトで1だけ重みを持つなどすると構造が少し複雑になって、そのせいで解けなくなる場合がある
        - [経路数を調製<-デフォで1作ると不都合](https://mofecoder.com/contests/itfpc2024/tasks/itfpc2024_j)


- 一致させよ・全てkにせよ
    - 差分がall0が必要(十分)
    - 差分での言い換えがしやすい
- 開始状態、終端状態が与えられた
    - 片方が特別単純な時 : 開始、終端をswapして考えると、dpで持つべき状態が減る...
    - 両方複雑な時 : 綺麗な"標準形"を作り、開始・終端を共に標準形にした上で、一致判定
        - sort..
- 簡単な操作を見つけた
    - 他のバリエーションは？
        - 似たようなことによって、数値が少し変わっただけのを作れるかも...
    - それによって解ける問題のケースはどのようなケース？

- 一部のケースが解けることがわかった
    - 解けない問題のケースは？
    - 何でそのケースで上手くいく？

- 複数制約がある時、後から辻褄を合わせやすい制約は後で合わせる
    - 総和とか
    - [例題](https://atcoder.jp/contests/arc145/tasks/arc145_d)

- 要素を選ぶ。隣り合わないように選べ
    - 要素の集合を2つ用意できれば、どっちサイドを使うかを適当に割り振ることで隣り合わなくできる

- 整数nの表示
    - 三角数(nC2)3つの和としてどんな整数でも表せる
        - 四角数（=平方数)だと4 [link](https://manabitimes.jp/math/926#5)
        - ただし、三角数の時、隣り合う数字を使うことが下の3つでのみ起こりうる。かつ、1については、2つ使うことがアリエル。


## 実験の仕方
- 一番解きやすそうなパラメータの時を考える
    - 順列: {1, 2, 3, 4, ... , n}の時
- 一部の制約を無視
- 小さいケースについて列挙

- **見比べる考察**
    - 必要条件を出したい時、「それが成立するもの」と「しないもの」を見比べる
    - 必要条件に対して、本質的な違いがあるはず
        - いきなり出せなくても、事実->理由->必要の順

- 状態にループがある時、単一始点なら解ける場合が多い
    - 一度探索した頂点は見ないとする
    - 有向グラフにおける、単一始点での到達可能頂点列挙
    - ただし、始点以外の結果は誤っている可能性がある



# 操作

## 移動させる操作
**最初の状態と最後の状態に注目する**
- 目標の数列に一致させる問題で頻出
- 隣接swapする時、最小の隣接swap回数
    - それぞれの要素の、最後の位置を固定すると...
        - 転倒数
    - よって、最後の位置を考える問題になる
- 最後の相対位置似注目 : ~を合わせる上で、実は操作OOは最初にやるとして良くて...
- 移動しないと決めた要素について注目 : 単調増加列の必要があって、LISを選べば良い...
- 最後の転倒数は0で、かつ操作ごとに転倒数は減る、転倒数を1だけ減らす操作が存在して最適...

**絶対的な位置ではなく、相対的な位置に注目する**
- [例題](https://atcoder.jp/contests/arc126/tasks/arc126_d)
    - 最終的に{1, 2, ..., K}を構成する要素を選んだ時、ゴミが間に入る
    - ゴミを効率よく出したい
    - 左と右の"近い方"に排出するのが良さそう？
    - それぞれのゴミに対し、「右/左にある選ばれた要素の"個数"(距離ではない)」を考える
    - 各swapにおいて、これは1つのゴミでしか変化しない && 1しか変化しない
#### 連続部分文字列をrotateする
言い換え: 要素と移動距離を選んで、選んだ要素を選んだ距離だけ移動する
こうすると、大きく移動する要素について、右rotateと左rotateを合わせる必要がない事がわかる・区間の操作が要素への操作となる・小さいrotateは大きいrotateにした方が良いことなど、色々良い性質がわかる

## 操作の単調性
- 単調性とは:一方向きにしか変化しない
    - 今min/maxである要素に特徴ができる
    - 貪欲ができる

- これを作るために、部分的に逆操作を考えて、操作を1方向にする
    - 増やすて減らす->増やすときはゴールを下げる

- いつ考える: 逆操作を導入したら操作に単調性が作れそうな時
# 逆から見た方が良い状況
## 置き換える操作
- 典型: 操作を逆向きに言い換える
    - 最後の操作によってなされるものは何か？
    - ワイルドカードを登場させる / マス目を確定させる（以降操作しても変化しない)
    - 嬉しい: 置き換えについて、置き換え元はなんでも良い・何に置き換えたかは必要になった時に初めて決定して良いという構造をうまく使える
        - また、最終的に残るものから決めたいという気持ちもある
    - [最終指定<-塗ったら元はどうでも良い(ワイルドカード)](https://atcoder.jp/contests/arc183/tasks/arc183_b)
    - [一度塗ったら不変](https://atcoder.jp/contests/agc008/tasks/agc008_b)
        - 終点が未定
        - 未定をワイルドカードと思う
        - 塗ったらそこが確定
        - どんなのが作れるか
- また、直接的な置き換えに限らず、「前やった操作の影響を上塗りするような操作」は、逆向きに言い換えると良い。

一般: 最初にやる操作より、最後にやる操作の方が条件が厳しそうな場合
- 最後の方が制約が強く、今何やったらいいかわからない・必要条件がなくても、最後には必要条件がつくということはある
    - [値をどんどん大きくしていく...最初の方はわからないけど、最後の方は目標の値の大小が必要条件として絡んでくる](https://atcoder.jp/contests/agc037/tasks/agc037_c)

## 操作をしていく際、最初に比べ最後の形が定まっている時
- 最初の方は自由度が高いのに比べ、最後の状況が定まっている場合、「最後の操作」にかかる制約がわかりやすくなる場合があり、そこから考察を進められる場合がある

- また、「制約がどんどんキツくなっていく」タイプでは、「最後でもok -> 最後に決定 -> 最後のは前に影響を及ぼさないので、無視する」という流れにより、最後さえわかれば問題が解けるという場合もある


## 2種類の/複数種類の操作が行われていく
- そのまま見ていては、何ができるのか・最適にするにはどうしたら良いかがわからない場合が多い
    - そもそも、それぞれの操作について、整理が終わっているか？
- 考察: まず操作が一つだけの時に注目して、その中に他方の操作を1回だけ挟んだ時にどう影響するかを見る事で、操作の関わりが見やすくなる
    - 嬉しい: 操作を1回に絞る事で、1回の影響が見やすくなる
    - [追加と削除](https://atcoder.jp/contests/agc050/tasks/agc050_b)
        - 何が作れるのかわからない
            - 整理しないといけない
        - addだけの場合を見る
        - あんまり...
        - delを入れてみる
            - 3ずらす、ができる
            - mod3だけ見れば良い
        - delによって、挿入もできるようになった
        - 実はコレで十分
            - mod3で見た時、delは意味がない
            - 隣接するaddとdelをswap or delを削除　できる事から   
    - [例題](https://atcoder.jp/contests/arc122/tasks/arc122_c)
        - fib数的なことをすると大きくなるが、大雑把
            - +1 も使わないといけない
            - 交わった時にどのような振る舞いをするか
            - fibを作る中で、一回だけaddした時の様子を見る
            - 綺麗な形している

    - [例題] : 累積和を取る操作 + add1する操作 最終的に数字は？
        - +1を1回だけした時、連結成分にどのような影響があるか
        - じつは経路数だけ寄与する

## 2種類の操作・カンタンになる整理
成立したら嬉しい、たまに成立する(単純なら特に)、よって考えると良い系
- 独立になる系
    - 「操作Aの後に操作Bをすることはない」
        - BBBBBAAAAの形に限定
    - 「操作Aをした対象に、操作Bをすることはない」
        - 操作Aをする要素を決め打ったら、残りの要素にだけBを考慮すれば良い

- [削除してからrot、として良い](https://atcoder.jp/contests/abc262/tasks/abc262_f)
    - 注: rot -> 削除は損するからダメ
    - または、rotしたのは削除しないとしても良い
        - こっちの方が実は楽
    - 保留して考えて良い -> rotしたやつについて、「実は消していた」とコスト0で置き換えても良い
        - よって、rot -> 削除の順にして良い
    - 初項を決めると形が大体定まるので、貪欲に

    
## 可逆な操作・打ち消す操作
逆操作が存在する場合に言えることがいくつかある。
- 操作回数を最小化しなくて良いならば: 標準形を使ってよい
    - とりあえず考察がしやすそうな形にしてから考えるということ。
    

- A -> Bにできるか？の場合、 A -> 標準形、 B -> 標準形 （標準形は一意に定まるもの) で判定しても良い
    - 考察のstepが減りやすい
    - 「作れる集合の中で」一意なものにすると良い
        - A <-> Bにできるなら集合が同じ、できないなら違う
        - 作れる集合の中で辞書順最小等

### 可逆な操作を両方行える時
- 操作A -> 操作-A のようなものは意味がない
    - これを禁止して仕舞えば、結果的に (-A)(-A)(-A)AAAA のような操作しか存在しない
        - (-A)の回数全探索等、随分考えやすい状態になる
            - [石を乗せる・排除<-可逆](https://atcoder.jp/contests/abc313/tasks/abc313_g)

### 打ち消す操作をするとして良い
- 片方しかしてはいけないという時、両方しても答えが変化しない。よって、独立にそれぞれ考慮するとして良い
    - 最適化で考えやすくなるかも
        - 株の問題 売る・買う

## 1回しかしなくて良い
操作を何回でもやって良いという時、何らかの貪欲に依って「操作は高々1回まで」と制限をつけられると、探索がやりやすくなる。特に、順番を考えるも何もなくなる。

## 良くわからない操作
複雑な操作は、考える上で大きな枷となりうる。
- 本質は「自分が良くわかっていないこと」

- そういう時、「操作を組み合わせて出来る扱いやすい操作」を作って、その上で考えることで考察が進みやすくなる
    - ただ、往々にして操作全体から一部の操作に制限した場合、を考えていることになり、答えが変わる場合がある。
        - 最適化では危険だし、そうでなくても、解けないならその制限を排除する事になるかもしれない
        - 進まないよりはマシ...?
### 操作回数に上限がある
#### 操作回数が精々1回
- 操作をしない状態についての前計算をした上で、操作の仕方を全探索
    - ある操作をした時の結果を、そのテーブルから計算する
- 前から、操作をした・してないを状態に持ったdp
    - 操作の仕方に自由度がある場合、結果の状態も多岐に渡り、dpの更新が間に合わない場合がある
        - 実はooな操作しかしなくてよくて...(貪欲)
#### 操作回数がk回
- 前から、操作をした・回数を状態に持ったdp

<br><br>

## 転倒数
寄与の分解の仕方が複数ある。
- 数列の転倒数
- 全ての2要素単位での分解
- 全ての要素について、その要素が持つ転倒数を考える（転倒数列)
    - [例題](https://atcoder.jp/contests/arc181/tasks/arc181_d)


- 転倒数と順列は1:1対応しない
    - N! vs N^2ぐらい

- かつ、転倒数は距離のように扱えない
    - d(A, B) = d(A, C) + d(C, B)が一般には成立しない
    - [例題](https://atcoder.jp/contests/arc043/tasks/arc043_c)
        - A, Bがあるので、 d(A, C) == d(B, C)を可能なら作って
        - Aを{0, 1, 2,....}にしてしまって構わない（言い換え）
        - あとはそれっぽいのがok
        - 数列の変化を実際にせずに趣味レーションする方法を考える
<br><br>

# 判定/証明
基本的に、後述の"自由度が高い状況の整理"を踏襲すれば良い。

## 背理法
- 自明に解けるケース: 成立するケース
    - 成立しないとした時、何が言えるか?
    - [特殊なグラフ上でのマッチング](https://atcoder.jp/contests/arc045/tasks/arc045_d)
        - 連結成分でnがevenならできる？
            - 言い換え無理
                - 次数1はすぐやって良い...それ以外？ 

        - 
<br><br>

# 自由度が高い状況の整理・苦しい考察
**複雑なものを、扱える程度に単純にする**
**全体についての答えが無理なら、部分についての答えから攻める**
- そうして初めて考察が進む
    - 成立する事柄を探す系: 問題の一部分について解く、ということ
        - 全体を解くのは無理でも、一部分ずつ切っていけば解ける
        - それすら無理でも解けることはある
            - 数学的帰納法風味（全探索)
            - 敢えて損するかも知れない固定
            
- **部分について切り崩していくパターンはいくつかあるが、概ね問題の整理・言い換え -> 必要な情報だけ残す(特徴量) -> 極端な・特徴的な物に注目する事から始める**
## 問題文中のよくわからない言葉・よくわからない条件について考える
そういうのが残っていると議論が進めるのがむずい
- 実は、よく分からない部分を全く含めない議論ができれば、よく分からない部分を放置しても解ける
- しかし、全く触れずに議論できなさそうなら、向き合わなければならない

- 特に、日本語の条件は数式に直す！

- 集合に"含まれる"という日本語
    - 何を意味するのかが分かりづらい
    - 集合に含まれる事が何を意味するのか、で考えよう
    - [最短路にある辺が含まれうる <-> その辺を用いるような最短路が存在する](https://atcoder.jp/contests/abc375/tasks/abc375_g)
        - とりあえず、必要条件として1 -> any の最短路に含まれうる = その辺を用いるような最短路が存在する　物を省く
        - 残った物を考えよう
        - その辺が消えた時の、1 -> Nの最短路の影響を調べたい
        - 1 -> N の最短路に含まれうる = その辺を用いるような最短路が存在する　のさらにきつい必要条件が出る
        - そのような辺が消えた時？
        - 連結なら適当に辿れば変わらない、不連結になったら無理

## 問題の状況を元に、簡潔になるような言い換えをする
- 問題が示す操作自体は複雑でも、その操作をもっと簡単に言える場合は多々ある
    - 答えが変化しない範囲でいくらでも言い換えて良い
        - また、一部分について考えるときは、その部分の中でロストしても構わない情報をロストさせて良かったり
    - そういうのを削ぎ落とすことで、議論がしやすくなる
        - 嬉しい: 状況が簡単になる　これだけで進む議論が多々ある

    - [操作の判定では、要素の偶奇しか関係ない](https://atcoder.jp/contests/arc155/tasks/arc155_c)
        - 操作の条件を見る
            - 要素の値はどうでも良くて、偶奇にしか関係ない
        - 操作の振る舞いを見る上では、01列に対して観察すれば十分！
        - 01列のsortみたいな話になる
        - 複雑な話をしたくない -> 0001111みたいな並びを考えて...

- 不変量を積極的に作る
    - 数列に加算する操作...加算の和 = 0となると、必要条件が浮かび上がって良いので、そうなるように言い換える


## 視点を変える・問題を言い換える
- 必要な事: 言い換えた問題の先で議論できる事。
    - 奇抜な言い換えである必要は必ずしもない。差分列や累積和列、転倒数列への言い換えが頻出。
    - タイミングが奇抜、ということはある。
- いつ考える: 元の問題の考察が進まない時。複雑すぎてどうしようかという時。
    - 特に: 数列への区間への操作が来た時は、勘が働かずとも、差分列や累積和列にすると圧倒的に簡単になることがある。

    - [座標で考えると複雑すぎる](https://atcoder.jp/contests/arc189/tasks/arc189_b)
        - 貪欲も、できる操作も、成立する綺麗な操作も思いつかない
        - 数列への区間操作 -> 言い換えてみよう
        - 差分列にすると、操作はただのswapであり、終わり
    - [1だけ変化させる -> グリッド上で隣り合うますに移動する](https://atcoder.jp/contests/arc118/tasks/arc118_d)
## 問題の自由度を把握する
- 何が固定
- 何が固定でない
- こちらは何を決める
- 最適化しろと言われているが、まず何なら作れる
- 条件を満たすのを数えろと言われているが、まず何なら作れる

- [例題](https://atcoder.jp/contests/arc010/tasks/arc010_4)
    - 人の集合を選んで、距離を決める
    - ここまで言えば、距離は貪欲で良くないかとなる
    - yes
    - 伝達の関係を有向グラフに

## 先に処理して良いもの（一意なもの・決定したもの）を処理する/解けるケースを先に解いて、状況を再定義する

- 一意に確定した物
    - 確実に発生する物
- 自分で固定したことによって上記のいずれかになった物
- 解けるケースを除いても、その旨みがわからない時もある
    - そういう時もわざわざその制約を捨てずに残した方が良い
    - 黒魔術的なdpに走ってはいけない

- また、何か「もう処理した」部分が発生したら、その部分を全く考えなくてなるように(情報を)整理することも大切
    - 余計なものがあると、貪欲や再帰的な状況に気付きづらい
    - また単に、情報のロストによりdpの計算量改善
- [どうしたって結果が変化しないbit <- 全部0にして無視する　と、そうではないbitを貪欲に採用する貪欲がわかる](https://atcoder.jp/contests/abc141/tasks/abc141_f)

### 最初から存在しなかったとして考えても良い/一旦忘れても良い
- もう自由度を決定して、その影響も処理した
- 他の要素によって、代用されうるもの
    - 考察では「でも迂回されるかも...」といったわずらわしい婆位訳として登場するが、実はそういうのは「毎回replace先を使えばよい」となったりする
        - [老人2人 -> 大人+赤ちゃん](https://atcoder.jp/contests/abc006/tasks/abc006_3)
            - よって、老人は2人以下として良い
-　明かに損なもの 
    
    
- ものすごく自由に動かせる物
    - あとから都合が良いように決めればよく、一旦考慮から外して良い
        - 決定を保留する解法？
- 今決めなくても良いもの
    - どれかから選ぶ <- 後でどれから選んだが決めれば良い
    - 必要な事: 保留しても次の状況が変化しない(選択肢によって分岐しない)・保留してるものは、全ての選択肢にとって等価でないといけない
    - **特に、今一意に決めて良いものは、保留せずに決定して処理をするべき**
        - [等価でない場合](https://contest.ucup.ac/contest/1817/problem/9528)
            - 保留が10あったとして、エンジン0が5を占めていたことにしよう
                - すると、残りの5は、エンジン0が占めていた事にしてはいけない
                - つまり、保留したものが等価ではないので、別に管理しなければならない
                    - 情報量が多い
                - 今回、貪欲でどのエンジンを使うべきか決定できる 


## 場合分け・状況の整理を徹底する
常に、「これで結論づけられないのはどういうケースだ」を考える必要がある
- **今の結論が使えない・直ちに結論づけられないケースがありそうと思った時に、そういう時どうするかの前に、そういうのはどういう時を考えるということ**
    - **コレが込み入った考察の最後に登場すると、その場合分けを忘れて「結局ダメじゃん」で終わらせてしまいがちになる**
    - **あるいは、初手に発生する(存在しないということが良い条件となる場合)、それを忘れがちになる**
    - 解法を考える前に状況の整理
- 今これで結論づけられないケースは何か？から状況を絞る
- そもそも"自明に解けない"という状況にすら特徴がある場合、それの利用
    
- 証明 <- 不成立と仮定し、状況を考え、そこからの改善をいう
    - [操作が必要な場合、ただちに操作してはいけないのはどういう状況か](https://atcoder.jp/contests/agc037/tasks/agc037_c)
        - 今を見てもわからない/最後の操作の方が強そうので、逆順に見てみる
        - A[i] < B[i]のところはいずれ操作しないといけない
        - 今操作をするとしてはいけない・直ちに操作をしてはいけない状況は？
            - 両隣の和を引くとA[i]より小さくなる場合
                - B[i-1]+B[i+1] > B[i] - A[i]
            - では、 B[i-1]+B[i+1] < B[i] - A[i]とする
            - 両隣の値が変わってから操作した方が良い場合
                - 問題はこれ
                - これがどういう条件で来るか考える
                - 操作をするという仮定より、両隣に操作が来るはず
                - B[i-1] < B[i] - A[i] - B[i+1] < B[i]
                - B[i-1]マイナスになっちゃう
                - あり得ない
            - よって、値的に操作できるなら直ちにして良い
            - 1つへの操作を一気にやることで高速に
            - indexを見つける作業を頑張ろう
    - [特定の操作でいいところまで行ける（最後の項以外ok)が、それだけでは最後の項が合わない <- 単純な操作によって最後の項がおkになるなら良い。ならない場合は？](https://atcoder.jp/contests/arc187/tasks/arc187_a)
        - このように、「綺麗な操作によっていいところまでいけるが、それだけでは最後までいけない」というのはよくある
            - そういう時、「単純な操作・与えられた操作を素直に適応する」だけで条件を満たせるなら、それで良い。逆に満たせないという時、その「満たせない」ことから条件がついたり、あるいは「綺麗な操作」でその条件を補正することができたら答えを求められる
    - [n is evenなら可能の証明](https://atcoder.jp/contests/arc045/tasks/arc045_d)
        - 貪欲・ルール・再帰とうどれもピンとこない
        - 整理・部分的に解くことを考える
        - 適当にやって解けるケース<-ok
        - 解けてないケースを考える
        - 不成立を仮定
        - マッチングしていない点が2つ以上の偶数個ある
        - 適当に2つとって、マッチングしていない点の個数を減らせることをいう
        - 連結の仮定を用いて、パスを取って、なんかできる

    - [クロスがないものを構築せよ -> 適当にやって、クロスがある時](https://atcoder.jp/contests/abc373/tasks/abc373_g)
        - 適当にやってないならおk、ある場合
        - クロスがあることが言える
        - 適当にswapすると、距離の総和が減る
        - 総和がminならok

    - [迂回によって解法が破綻するのあhどういう状況か](https://atcoder.jp/contests/agc027/tasks/agc027_c)
        - A/Bどちらかに繋がっていない頂点を考える
        - その頂点を踏む時、繋がっていない文字をADDすることで破綻?
            - 別の頂点使われたらおしまい
            - 別の頂点使われるのはどういう状況？
            - その頂点がなくても良い状況・その頂点を使わないと作れない文字列が存在しない状況
            - 最初から無いとして良い

### 問題の一部を無視する
- 条件をつければ、問題の一部が無視できる事はある
    - 場合分け的な
- そこから問題の発想（勘の部分）が浮かんでくる事がある


## 独立性・自由度等の構造を整理する
グラフ上で考察しても良いし、そうでなくても独立なものは別々にして考える。
考察の上での利点:
- 考えるケースが減る
    - 絡み合うケースも考えるべきかと思っていたが、実際には起こらない
- 本質的な影響が見やすくなる
    - 情報のロストをしやすくなる
- [例題](https://atcoder.jp/contests/arc008/tasks/arc008_3)
    - とりあえず、何ができるのか把握する

- [要素にするべき操作の種類で分ける](https://atcoder.jp/contests/agc048/tasks/agc048_c)
    - それぞれの要素について、右の操作 or 左の操作を共にすることはない
    - 操作の種類を全て求めて、その操作が一様な区間でみると、最小回数がわかる


## 重要な情報だけに注目し、他をlostさせる・無視するよう言い換える・言い換える・特徴量を見る
- 問題を解く上で、状態の変化をそのまま受け取る必要はなく、欲しい情報・条件・制約に係る情報だけを注目すれば良い。
- そのため、それらに関わらない情報は捨ててしまってよい.
    - 何をすれば良い:必要な情報とは上記のもの。確認には、その言い換えによって答えが変化しないことを確かめれば良い。
    - 嬉しい: 問題が言い換えのごとに簡潔になる
        - こう言い変えても答えが変化しない...
        - こう決め打っても答えが変化しない...
        - この値は操作によって不変・一意に変化/任意の操作で同じ変化をする...
            - それに沿わない場合を考察から排除
        - この値はある程度自由に動かせる <- その「ある程度」を定める数値だけを考えれば良い
            - 今値は何という細かい値は重要では無い
        - 全く同じ制約<-何回も考慮しなくて良い、独立な制約はどのような制約か? 
    - 嬉しい:条件について、不要な情報をロストさせる事で適応範囲を広げられる場合がある
        - ooな時解けるな... <- 条件的に、もっとooはゆるくて良い(ooから情報をロストさせて良い)

- また、それらの重要な情報を見つけられれば、それのみに注目した議論ができる
    - 嬉しい:もはや多様な操作を見なくて良く、その特徴量の変化についてだけ見れば良い。これは元の問題よりはるかに単純である
        - また、「ざっと見るだけではかなり複雑だが、良い特徴量さえ見つければ「それから見て無理なのは無理・おkなのは何でも作れる」と言ったように見えることが多い
        - 変な操作ができるが、結局はgrandy数だけ見れば良いので...
        - 如何なる操作もOOを一定量変化させるので...

- 必要なこと: 上手い特徴量・答えを求める上で必要な情報が存在する
- いつ考える: 存在すると思った時常に。また、必要十分条件を考えたい時。

    - [操作の良いかえ -> 特徴量に注目](https://atcoder.jp/contests/agc033/tasks/agc033_c)
        - 元の問題は操作がアクロバティック・状態も多過ぎて手がつけられない
        - 必要な情報とは？
            - 操作ができるのかの判定: コインがあるか
            - 勝ち負けの判定: 操作ができるか
        - 言い換え1: コインの枚数はもうどうでも良い
            - コインのある無しだけみよう
        - まだ操作がたくさんある
        - 動きを見ると、葉が消滅していく問題に見える
        - 操作 :「基本的に葉を全滅させる。端、選んだ頂点は保護される」 
        - 基本と例外が絡み合う感じなので、その関係性を考えよう
        - 基本的な動きのみ（例外を省いた場合）を考えると、直径が-2
        - 例外を含めると、それを-1にできる
        - done!


- 等しい...実際の値はどうでもよくて、差分 = 0が重要 差分に注目しよう　など
### 特に重要な特徴量:偶奇
- 使える必要条件: 数値が登場すること
    - ほとんど全ての状況で考慮することができる
        - 特に、「ペアにする」が出てくる状況では、ペアは偶数なので偶奇が効きやすい
            - 括弧列
    - かつ、コレが必要十分となる場合も多い
        - ゲームの勝敗
        - 構築可能性
        - [良い括弧列を作れるような\(と\[の振り分け](https://atcoder.jp/contests/agc048/tasks/agc048_b)
            - 丸と四角の割り振りであって、良い括弧列にできる振り分けは？
                - 極端なものを見るという思想で実験しても、かなりきつい
                - 貪欲より形を絞っても、ぱっと見で綺麗な条件が出せない
                - 偶奇は数値が登場すればいつでも使える
                    - 括弧列は「ペアにしていく」もの
                    - 必ず長さが偶数
                    - よって、丸に注目した時、ペアになるやつと偶奇は異なる
                    - つまり、偶数マスと奇数マスの個数は一致が必要条件
                - コレが十分

## 何かが特定のケース・要素について、成立する事実が見つかった
やること
- 事実の成立する必要条件の拡張
- 解くべき問題の再整理

- どうして成立したのかを考える
    - 証明できるか？
        - 証明に必要になった条件こそが、その「上手くいく」要素である条件
            - 具体例 -> 理由 -> 適用条件　の順で遡れる
        - 観察で1発で見抜けなくても、ここで成立する要素の漏れを確認できる
    - 理由を述べられれば、(1)自由度 (2)その定理の適応条件　がわかる
- それを上手く行かせる中で、自由度はどれ具合あるか考える
    - その自由度の中で、他の都合を合わせる
        - [例題](https://atcoder.jp/contests/arc131/tasks/arc131_e)
            - 頂点に色を固めれば、上手くいきそう
            - 上手くいく
            - その中で、頂点それぞれに振る色が自由
                - 色の総数が合うように、ブロックを割り振っていく

- 問題の全体がわからなくても、一部ケースが解ける事がわかったら
    - その部分を無視する -> 解くべき問題として残っているものは何かを整理する
    - ここで、残った問題を見たら考えやすくなっていて解けるという事が多々ある
        - 「わかる部分」が「わからない部分」の部分的な解法になっていて、残った「わからない部分」はすでに解ける範疇に収まっていたなど
        

### 自由度のうち、どんな初期状態を与えられても、1つ決定して良い物が存在する/得られる
- マッチング問題のように複数の自由度がある問題で、「どんな初期状態でも自由度の中で決定して良い自由度が存在する」ならば、それを決定 -> サイズを下げる　事で解ける。
    - 特に、1つについてだけ議論すれば良い。
    - 時系列に沿って行う試行であっても、「初手・最後の自由度として最適なもの」が得られれば、それを選択 -> 影響を反映 -> 問題のサイズを小さくする　と言った手順で、問題全体が解けてしまう。


- 必要な事: どんな状況であっても、初期状態が与えられた時、自由度の中に1つ決定して良い物がある
- いつ考える: 貪欲がありそうな時、定式化として。また、これが成立しやすい問題。
    - 自由度が複数あって、それぞれについて決定していく問題
    - マッチング
    - 時系列に沿って行うシュミレーション。特に、条件がどんどん厳しくなっていく・初手が一番厳しいようなシュミレーション

- [マッチング: 1つ決定して良い物が存在](https://atcoder.jp/contests/abc383/tasks/abc383_f)
    - 重みが小さい方からくっつけていく
    - 最初に連結になった $a \in A, b \in B$ について、(a, b)でマッチングさせてしまって良い
    - マッチングさせたらリストから消す -> 同じ問題
    - 実際にはシュミレーションをすることになる

## 簡略化した問題を解く
- 問題の、一部にまず集中する
- そっちの事実を流用できる場合がある。また、そもそもそっちを解かないと無理な場合も
- [ややこしいルールを無視して解くと、導入しても無視して考えて良いことがわかる](https://atcoder.jp/contests/arc008/tasks/arc008_3)
    - 1秒ルールを無視すると..

- また、必要条件的に問題の整理が進む場合がある/無視した要素の決定に使える情報が手に入る場合もある
    - 一部の条件を無視した場合 <- 他の条件を満たすために、とりあえず状況としてこうでなければいけない...
        - [ワイルドカードをどうするべきかを一旦無視](https://atcoder.jp/contests/abc277/tasks/abc277_f)
            - ワイルドカードをどうするべきかまで考えると頭がパンクする
                - 無しで考察しよう
            - 結果を考えると、ワイルドカードは本当に自由にできることから、既に決まっている値の制約さえ満たせばあとはどうとでもできることがわかった
                - つまり、問題を解く上で無視して良かった 

- [操作がDAGの構造をしていない最適化は、作れる集合が何かを先に解かないとDPを立てることすらできない](https://atcoder.jp/contests/agc050/tasks/agc050_b)
    - 操作は順番によりそう
        - 区間dpか？
        - 独立にもらなら無い <- そのままではdpすら立たない
    - 列を決め打った時、そこにコインがおけるかを考えよう
        - mod3だけが重要
        - mod3に還元して初めて、削除操作をしなくてよいことが言えて、ウニャウニャ 
    - 区間DPであって、テーブルの情報をフルで使うものをする
        - 区間から3つの要素を選ぶのだが、「端を使わない場合」はすでに計算してあるので、両端を使う場合のみ考えればよい！





## 必要条件から攻める/必要条件を積み重ねる
- 条件を求めたいが、いきなり出すことは無理という状況は頻出
    - そこで絞り込みを諦めてしまうと進めない
- そういう時は、比較的見つけやすい必要条件を積み重ねていく事によって、必要十分条件を浮かび上がらせていく
- 必要条件の見つけ方としては、何か特徴的な物・極端なものから、それによって一意に定まることを探すと良い
    - 極端なものは情報量が多い
    - 例: 極端なものについては、それを生み出す方法が一意だったり、何かしら一意に定まるという情報が出やすい


    - A : B を対応づけた上で、Bが与えられた時(最適な)Aを求めよ、という形は多い
        - 結果 -> それをもたらす物であって、最適な...
        - BをもたらさないAを除去する必要がある
        - しかし、いきなり「BをもたらすAの条件は？」を出すのは難しいかもしれない
        - いきなり条件を導くのが難しいなら、必要条件から考えよう 
            - 往々にして、"特徴的な/極端なもの"に注目する事で何かが得られる
    - [結果が与えられるので、その過程のシュミレーションとしてその結果になる物であって最適なものを出せ](https://atcoder.jp/contests/agc009/tasks/agc009_b)
        - シュミレーション列の条件(必要条件)を考えよう
        - 二分木ではある
           - ここから進めるのが少し難しい
        - 固定された情報のうち、極端なものを探す
            - 初戦に負ける奴は
            - 相手も一意で、二分木の形が（貪欲によって)一意に決まる
            - 処理してしまおう！
        - 処理してしまったなら、状況から除外しよう
        - 「残った中で初戦に負けるやつ」がまた出てくる！
        - 順番は一意でない（次負ける、という奴が何人いたって良い）ので、そこの自由度を後は考慮

- BからAの必要条件を求めるのは定番だが、同時に、BからA(つまり、原因の構造から結果の構造)についての必要条件が発生する場合がある
    - シュミレ: 結果なら、与えられた結果よりシュミレに必要条件が科されるのはもちろん、シュミレの制約から結果に必要条件が出る
    - Aの必要条件の絞り方として、A->Bの方向とB->Aの方向の両方あるということ
- [括弧列: 順列 　順列が得られる為の必要条件 と 括弧列である為の必要条件](https://atcoder.jp/contests/arc141/editorial/4024)
    - 順列が得られる為にはを考えると、P, QそれぞれからSの条件が出る
        - まだよくわからない
    - Sが括弧列であることから、P, Qの必要条件を求める
        - P, Qから得られる制約はそこまで複雑で無いことがわかる
        - というか、一意であるべきということがわかる


## 十分条件から攻める
- OOならok
    - 他の手法/OOの改善によって、xxもok
    - ...を、必要十分になるまで続ける
- OOなケースなら解けるということがわかった場合、OOでないケースに問題を帰着させるということ
- 必要な事: 明らかに解ける・できるケースがある
- いつ考える: そういうケースがある時積極的に
- 考察を進められるような必要条件が見つからなくても、十分条件から問題を部分部分で解いていける事は多い
    - [必要条件<-あまり良いのがない  では、明らかに可能な場合(十分条件)を考える](https://atcoder.jp/contests/agc027/tasks/agc027_c)
        -  十分条件...部分グラフであって、全ての頂点がA/B共に接続しているようなものがある
            -  そうでない時？  
            -  条件を否定すると「部分グラフであって、全ての頂点がA/B共に接続しているものが存在しない」
            -  「任意の部分グラフについて、頂点が存在して、A/Bどちらかに接続していない」
            -  こうした方が扱いやすい（否定は中に入れよう！）
            -  A/Bどちらかに接続していない頂点が明らかに重要な要素だろう...


## 役に立つ事実:状況を固定するような事実/他の状況に応用できる事実 等を探す
**動機：考察できる程度に状況を簡単にするような事実を探す/ 簡単なケースの答えであって、応用できるものを探す**
- 一意に決定して良いことがある
- ooができる(操作の組み合わせであって、扱いやすいもの)
- 自由度が高い -> 作れる集合はoo、以降操作を直接見ずにooだけみて考えれば良い...

- アプローチ1 : 今までの知識・わかった事を元に、似た結論を探す
    - [解けるケースを元に、他のケースをそれに帰着する](https://www.codechef.com/problems/TREECUTXOR)
        - nが偶数なら0。奇数の時...?
            - 偶数に帰着したい
            - できる（nが小さい時は場合分け)
    - [解けるケースがなぜ解けるかを元に、他のケースにその手法を応用する](https://atcoder.jp/contests/agc013/tasks/agc013_b)
        - とりあえずdfs木 <- 役に立たない
        - 次数=1が2個あればok
        - 1個の時は？
            - 終点を、ずっと伸ばす事で可能
            - 始点と終点は対称...
            - 同じ事を始点にやればいつでもおk
- アプローチ2 : 問題設定ができることから探す・本当に素直な形の解を試してみる・言える事を探す
    - 実際にテストケースを解く、いわゆる実験が必要になる
    - 必要条件から探す
    - {Aがとった, Bがとった}でペアを作っていく...
        - マッチングをBが選べる
        - [例題](https://atcoder.jp/contests/arc122/tasks/arc122_d)
    - A, Bが交互に取る...
        - 先手が大きいやつを取っていく
            - [例題](https://atcoder.jp/contests/arc105/tasks/arc105_d)

    - グリッドに数字を埋めていく...
        - 階段状・螺旋状...
            -　[例題](https://atcoder.jp/contests/arc181/tasks/arc181_c)

    - [設定からできる事を探す](https://atcoder.jp/contests/agc006/tasks/agc006_b)
        - できる事1 : [1, 2, 3, ..., 2n - 1]と並べる
            - 特に役に立たない
        - もう少し具体的なケースを探すと、2連続する部分が作れれば良さそう
        - できる
        - ok
    - [自由度が高い時に、作れる集合を特定して、もう操作を見ない(判定問題)](https://atcoder.jp/contests/agc004/tasks/agc004_b)
        - 操作は時間軸が絡み合ってdpに向かない
        - 判定問題: 移動形なので、最後の由来を指定した時できるかを判定する
    - [自由に動けるが、最適化・判定問題なので、変な動きはしない](https://atcoder.jp/contests/agc048/tasks/agc048_c)
        - 自由に動けて、やばい！
        - まず整理・言い換え: 動く系、隣り合う座標-> x'i = xi - i
        - できる・x'iを隣の座標の値に代入 目標x'i -> g'i
        - 自明な必要条件として、元あった座標になきゃダメ
            - 実はこれが十分
            - どうやって示そう？
        - 状況的には、ある要素が左右に動いて良い
        - 必要？
        - 片方の方向にしか動かなくて良い（制限)
        - これで議論が終わりまでいく

    - [任意の2要素に操作ができるが、隣り合うものに制限して考えても良い](https://atcoder.jp/contests/arc185/tasks/arc185_b)
        - 任意の2に操作できるらしい
        - 構築 <- 回数の最小化はいらない
        - 隣り合う要素への操作だけで、任意の操作を表せる
        - 隣り合う2要素への操作に制限して、状況を少し楽にしよう



## 一意に決定して良い事・「ooとして良い」を探し、そのように固定する(貪欲)
極端な要素に注目しよう
- 与えられた自由度の中で、「これは決定して良い」というものがあった場合
    - その影響を処理する
    - 問題を整理する
    - 新たな自由度・状況において再帰的に「これは決定して良い」を探す
- 決定して良いのは確かだが、同時に制約が増えるという事もある
    - 残した制約を忘れた考察をしてはいけない/制約として認識しなければならない
    - プレイヤーは貪欲でooするので、結果はxxとして良い <-以後、プレイヤーはooしなければならない
- これに気づくためには、自由度の中から一つ取り出して、その自由度の振る舞いについてみるような姿勢が必要
    - そこだけを変更してみるということ

- また、正しい貪欲を作るためには
    - その貪欲が使える条件は何か
    - 貪欲を使う時、その条件が毎回満たされているか
        - を確認すべき
            - 1回操作したら状況が変わるので...といった場合は多い
    - [Ai > Ai+1 となっているところに注目し、操作した場合を考える](https://codeforces.com/contest/2013/problem/E)
        - 固定しても答えにつながる結果が得られない
        - 再帰的に(:= 左から最適に...)がよくわからない
        - 貪欲、つまり「するとして良い」操作を探そう
            - max, min...?
            - A[i] > A[i + 1] となっているiを取り出すと
            - あとはこれを高速化
    - [改善する操作を繰り返す](https://atcoder.jp/contests/abc163/tasks/abc163_e)
        - 隣接swapを考えると、大きい要素は外側に行くべきです
    - [選択肢被覆型の貪欲](https://atcoder.jp/contests/agc008/tasks/agc008_d)
        - oo番目の制約は扱いづらいので、個数の制約に直す
            - すると、区間に対してそれぞれがooこの制約
        - いつ存在しないとか考えたいことはあるが、制約を図示すると明らかに極端な奴がある
        - はっしこのほう
        - そしてよく見ると、制約はそれぞれよりでかいのに覆われる形になっている
        - 小さい方から貪欲して良い(大きい方は、反対側のに被ることがあるのでダメ)
    - [使う/使わないを決めるうち、一つの要素に注目し、両方の場合を比べる](https://atcoder.jp/contests/agc045/tasks/agc045_a)
        - B目線、あるAiに注目
        - Aiの使用・不使用を比べる
        - 相手が後ろで作れるなら意味ない
        - そういう要素はどうでも良い -> 最初から無かったとして良い
        - 逆に相手が作れないならそいつでとどめをさせる
    - 使わなくて良い・ooに使うとして良い
        - もう考えたくない
        - 影響を今処理・そして、最初からなかったものとできないか？
    - [色々自由度がある<-極端な要素、今回は集合のmaxにちゅモク](https://atcoder.jp/contests/abc140/tasks/abc140_f)
        - 操作は値を小さくしていく方向なので、maxは最初に入れないといけない
            - その後もまだ高い自由度が残る
            - でも、貪欲で良く無い？
                - 必要な条件:任意の集合に対して
                - 操作: 大きい方から、自分が作れるうちのmaxを作る
                    - コレで良いか？
                    - 他の選択肢をとった時と差分を見る
                    - 「その要素が将来作れる要素」の集合に注目すると、選択肢の個数について上位互換になっている
                        - 良さそうだろう


- 「ooとして良い」の方向性はいくつかある
    - 良いとは: 答えが変化しないこと
    - スコアが悪化するような操作はしなくて良い->探索範囲削減
    - 多数種類の操作を複雑に組み合わせるような操作はしなくて良い -> 独立に考える
        - 1回のイベントにつき、1種だけで良い
        - 操作を並べ替えて, 1 -> 1 -> 1 -> 2 -> 2 -> 2...のように、それぞれごとにまとめてやっても良い
- あるいは、答えについて「上界はooだが、実はこれが達成できる」という形で自由度を減らすことも多々ある
    - [上界を達成できる、これで議論が終わる。貪欲も再帰的な構築もない](https://atcoder.jp/contests/abc139/tasks/abc139_d)
        - sum[1...n-1]が達成できる
        - 実は上界になっていると言えれば終わり
        - x1 mod 1 + x2 mod 2 + ... + xn mod n のsumはsum[1...n-1]で抑えれるので実際に終わり




## 無駄な事をして良い時(操作列・何かを構築しろ・可能・不可能を判定せよ）という時、シンプルになるよう敢えて固定して状況を簡単にする/綺麗な形の操作を探す・綺麗な形の解が条件を満たさないか考える
- 必要な事: クエリ回数や構築長の制限にある程度余裕がある/回数や長さの方面に損を被せる余裕がある
    - 特に、「最適になるように」と言う言葉がついていない時はいつでも該当する。
        - とはいえ、最初から余裕があるかなどわからないので、手詰まりになったら試すと良いだろう
        - 回数の方に損を被せる事で考察が進むなら

- 必要な事: 考えやすい形があって、かつその形に絞っても、その上で構築できる
    - 実は、これが当てはまることはかなり多い。ので、結構いつもやって良い。
- いつ考える: 最適なものを構築ではないなら毎回。「与えられた操作を繰り返して構築」など。汎用性が高く、常に使える・考える必要のあるテクニック。

- 簡単な操作...必要なこと: 与えられた操作を組み合わせて単純な操作が作れて、かつその操作が問題に対して有効な事
    - 当てはまる事が多い。
- 簡単な操作...いつ考える: 操作を与えられて何かをせよという時で、与えられた操作が複雑なのに、可能不可能を判定する/ 無駄なことして良さそうで、操作列を構築せよという時
    - 綺麗な操作があると、判定/構築しやすいので積極的に
    - 複雑な操作はどうしたら良いかわからず、役に立ちづらい
        - 特に、「複雑なくせに、いろいろな事ができる」という時そのままだと考えづらいが、実は綺麗な操作がその色々にふくまれていたりする

- 状況を簡単にするために、「最適」を求めるのではない時に
    - 条件の判定が複雑
        - 操作まで複雑だと手に追えないので簡潔なのに絞る
        - 嬉しい:全く考察できない状況が、少しは進む
    - 無駄なクエリをして良いかも <- 前半のクエリを「状況を簡単にするため」だけに使ったり...


    - [操作をして、数列の要素を一致させよ <- 操作回数に制限がないので、とりあえず「簡単な操作」を考えるのがとても有効](https://atcoder.jp/contests/arc159/tasks/arc159_c)
        - 気合いを入れると、+1, -1をできる <- fin!

    - [木であるという条件が複雑なので、振る舞いがシンプルな辺addだけ考える](https://atcoder.jp/contests/arc152/tasks/arc152_d)
        - 複雑な辺addをすると条件が手に追えない
        - 1直線な辺addだけに絞る
        - なんか別れるが、独立なやつごとに表にして睨むとできる
    - [構築の形を制限する](https://atcoder.jp/contests/agc007/tasks/agc007_b)
        - 差分列への言い換えがうまくいかない
        - 厳しい
        - B ={n*n, (n-1)*n, (n-2)*n, .... }としてみる
            - Bが単調減少を守りつつ、ある程度変化の余地を残した
        - 都合の良いAを探すと、見つかる

    - [構築の初期状態として「それなりによさそう」かつシンプルな物を選ぶ -> 再帰的に改善していく](https://atcoder.jp/contests/agc051/tasks/agc051_b)
        - ルールベースでは厳しい
            - 上手いルールが見つからない
            - 構築で非常に陥りやすい状況！
        - /の形
        - -> /  / の形
        -  / /
        -    / /
        -    これを繰り返すと良い
        -    最適でなくても良い！
        
    - また、「綺麗な形の構築を考える」「ルールベースの構築で頑張る」もこれになる
    - **当然、これらでは上手くいかない場合もある。かつ、この方針は時間を食いやすい。ある程度時間をかけて無理な時は貪欲に定めたり、帰納法的に順々に埋めていく事を考えなければならない。特に、諦めてはならない。**
    
      - [一致させよ <- 操作をこねると、ある条件の時swapができる](https://atcoder.jp/contests/arc183/tasks/arc183_b)

      - [ルールベースは厳しい。貪欲も厳しい。端から帰納法。1stepをどう選ぶか。](https://atcoder.jp/contests/abc178/tasks/abc178_f)
            - 必要: Aでの登場 + Bでの登場 > n が存在しない
                - 十分そう
                - 2部グラフマッチングより、ホールの結婚定理より言える
            - 問題はどう構築するか
                - 必要による固定の以下仕方がわからない
                - ルールベースではいけそうでいけなさそうで...
                - 貪欲？どの要素について言えば良い？
            - 上2つが無理な時、帰納的に考えよう
            - 1stepをどうするか考える必要がある
            - 値ごと...はルールベースで上手くいかなかったので、一つずつ、でやってみよう
            - すごいめんどくさい実装ののちにできる
        

### 言い換えが問題を難しくする場合もあり、後戻りも必要
- 言い換えを忘れて、もう一度考え直す姿勢が必要な場合もある
    - 条件は簡潔になっても、操作が複雑になってしまう...
    - ただしある程度の模索は必要で、やることがなくなったぐらいで戻ると良い(15分は長いだろう)
    - [単調増加->差分列...操作が複雑になってしまった](https://atcoder.jp/contests/arc185/tasks/arc185_b)
        - 差分列に言い換えると、 +1 -2 +1 して all >= 0 にしろ
        - この問題に集中しよう
        - 必要条件、端から、貪欲...
            - 解けない
        - 戻ろう
        - 元の問題に集中しよう
        - 貪欲(左端から)とかどう？


## 再帰的に・帰納法的に決定していく / nを小さくする
状況を改善しつつ、全体的には今までと似たにする事でどんどん問題を時進めていく。
この"似た"については、改善前と同じだったり、或いは解けている別のケースだったり、ともかく解法が判明している物なら良い。

- 特に、条件が後から補正が効きやすいものだとうまくいきやすい
    - 偶奇とか総和とか
- 帰納法的にとりあえず埋めていくパターン
    - この時、今までは条件を満たしていたという過程をもとに、条件を満たすように（例: 最適である、構築の条件を満たす)埋めていく。という考え方
    - いわゆる「端から貪欲・合わせていく解法」
    - 嬉しい: 仮定により状況が固定、目標も固定(仮定を守れば良い)
        - 自由度が高い時に、「今までの結果」が殆ど一意に固定された上で、次の1手ができるか？さえ考えればよくなって嬉しい
            - 構築なら、もう条件を守ることだけ考えれば良い
    
    - あえて固定や貪欲が思い浮かばない時に使う
        - 最初に何を埋めるか、を決めなければならない点では貪欲と似ている
        - 特徴的な物であって、必ず存在する物を埋める
            - 数列の端...
            - 全域木を取った時の葉...
        - ある程度悪い結果が出ようが、後から修正できるという時に強い
            - 総和の偶奇とか: 自分の全てが決定されていなければ、今までの結果を元に自分の選択肢を決めれば良い
    
    - 考える事: 帰納法の1stepはどうするか？
        - うまい1stepを選ばないといけない
        - 1要素ずつが多い
            - 条件に違反しない事さえ満たせば良いので、小さい動きの方が好ましい？
            - 同じ要素をまとめてやることもあるかも
                    - 結局は、仮定に合わせなければならない
            - 両方ある。試す。条件に沿ってそうな方を第一選択。

- 一部の問題なら解けているという時に、解けていないケースを上手く操作する事で、そのケースに帰着する
    - 例えば：偶数のケースなら解けているという時に、奇数のケースを偶数に帰着する
    - 帰納法と似たような事をやっている
    - 小さいのが解ける、ということがわかってる時に、下に合わせる
    - 一部だけ条件をかなえる、みたいなのができる時も

- 状況を改善するような操作がある時、その操作をしつつ、した後の状況がする前の状況と似た(: 改善ができる)状況になるようにする
    - 必要なこと: 初期状態 & 操作後も同じ状況
    - 初期状態はなる別簡潔な方がよい
        - 満たすべき条件が減る

- 再帰的に同じ操作を繰り返してく解法は、1回の操作ののちその解法が成立するために必要な条件がまた成立している必要がある
    - 貪欲等、1回目の操作では良かったが、2回目からは1回目の操作による影響を加味して別のことを言わなければなら無い事は多い
        - コレを忘れると複雑な議論の末に誤りを吐きやすい

- nが小さいやつに帰着する問題について、綺麗に「これでn-1の問題になった」としなくても、「n-1の時の答えを持ってきて、それを改造するとnの答えになる」とした方が対応力高そう


- [シンプルかつ良さそうな初期状態 -> 再帰的改善の連打](https://atcoder.jp/contests/agc051/tasks/agc051_b)

- [要素を1つずつ埋めていく](https://atcoder.jp/contests/abc178/tasks/abc178_f)
    - 同じ要素をまとめて...が上手くいかない
        - 条件が (要素の登場回数) <= n
        - 1つずつ埋めていく方が帰納法周りそう
        - 実際回る。
        - 考えること:1stepは何か。結論:1要素
- [数列の左から合わせていく](https://www.codechef.com/problems/AOPS)
    - 取り敢えず、操作を眺める
        - 問題の言い換えは思いつかない...
        - dp（全探索)もきつい...
        - どうやんの...

    - 実験してみる
        - 殆ど1にできそう？

    - 再帰的な解法: 左から1にしていく事にする
    - 単位:1マスずつ
        - i番目が0の場合
            - i + 1番目さえ決め打てば議論ができる
                - 不必要に場合分けを増やさない
        - すると、ラス3項以外が1にできる事がわかった
            - あとは手で解く・機械で全探索する

- [全域木の葉から決めていく](https://atcoder.jp/contests/agc035/tasks/agc035_b)
    - 辺の本数は偶数の必要
    - 連結成分ごとに独立
    - これで必要十分か？
        - 仮定から言える事があまりない
        - 辺に向きをつけるより、頂点にポイント加算の方が嬉しそう
        - いくらか解ける・言えることはあるが、それで詰めきれない...
        - 貪欲・ルールベースは一旦落ち着こう！
    - 必要十分の仮定が立った時 -> 帰納法を回してみよう
    - どうやって埋める? -> グラフなので、全域木を取った時の葉から
    - 日和見的に親の辺を含める・目ないを決める事で、構築できる
        - 偶奇のみが重要という性質がいかせている


- [modが小さい時は解けるので、そのケースから大きいケースに伸ばす](https://atcoder.jp/contests/arc172/tasks/arc172_e)
    - n ^ n の挙動なんて知らない...
    - キモい制約ある...
    - 実験しよう
        - 1 : 1対応しそう
        - always Yesだろう
        - では、どうやって...
    - 弱めた条件: mod 10 ^ i (i <= 9)で一致する
        - mod 10^iで一致するやつが作れたとして、mod 10 ^ (i + 1)で一致するやつが作れるか？
            - mod 10 ^ iの同値類で考える。 mod 10 ^ i では一意なので、そこからmod 10 ^ (i + 1)を復元できるか？
                - mod 10 ^ (i + 1)での同値類を活用する事で、できる
                - 一般に、 a = b (mod m)でも a ^ a = b ^ b (mod m) とは限らない(7, 17, 10)が、今回、m = 100, 1000, ... では成立する(m = 10では成立しない！))

- [木の構築 <- 木dpで葉 or 根から再帰的に構築](https://atcoder.jp/contests/arc175/tasks/arc175_d)
    - 色々疑問はあるが、すっと答えられない
        - 賢い議論が難しそう
        - 全探索風味のことをしたい
        - 木DP
    - とりあえず、作れるfの値を集合で持つ
    - 実験すると範囲になる
    - 判定ができる
    - 構築もできる
## 貪欲による決定 -> 綺麗な形の解を試す
- 貪欲によって、ある程度は一意に決定して良いことは多い
    - しかし、それで最後まで行けない場合もある
- そう言う時は、得られた上界をもとに、「この上界を達成するような構築はあるか？」を解くことを目的に、綺麗な形の解を試して見る
    - 往々にして強い・最適の一つである解が得られる

## 全ての状況で上手くいく構築・条件を探す <- 極端な状況から必要条件を得る
- [全ての状況で上手くいく構築を考えよう](https://atcoder.jp/contests/agc052/tasks/agc052_a)
    - 入力のSに依存せずに上手くいくアルゴリズムが必要 
    - S = 00000111111を考える
    - Sから2N-1削ったところで、変化点は高々4
    - このケースでは変化点<=4のものを作らないといけない
    - 1111000001はどう？
    - ok
    - 他の入力でもokで、終わり


## 全探索する
必要な事: 探索する状態数が少ない事
- もはや整理は無理だと思った時、全探索をする・全探索ができる事を疑う
    - [貪欲による操作の制限 -> 全探索](https://atcoder.jp/contests/agc044/tasks/agc044_a)
        - 言い換えを考えるが、難しい
        - 全探索を目標に問題を眺めてみよう
        - 最初と最後に+1をたくさんするのは良いとして、途中で+1/-1をたくさんされると困る
        - 実は貪欲により、途中の+1/-1はせいぜい5回までで良いとわかる
            - 超過するなら、次の*2とかの後にaddすれば良いため
        - よって、全探索ができる
    - [複雑だが、そもそも答えが0or1or2より、場合分け](https://www.codechef.com/START154A/problems/GCDXOR)
        - 区間gcdとxorができる
            - gcdとxorの関係などわからず、最適を考えるのが難しい...
                - 実は答えは小さくて、場合分けで付くせる...

### 可能性/自由度を全部持って探索し、必要な時に決定する探索
- できるならば解けるのはほぼ当たり前
    - 全探索するということなので
        - 一つずつ試すのとは違い、保持して全探索する
    - 旨み: できるなら解けること
    - 必要なこと: 状態をもって遷移することが計算量的に間に合うこと
        - なお、今一意に決定して良いなら、もう影響を処理してしまうべきである
    - 普段は難しいが、特に可能性が区間で表される時に使える可能性が高い
- [あり得る操作の結果は区間なので、持つ](https://atcoder.jp/contests/agc057/tasks/agc057_b)
    - 要素の結果としてあり得るのは区間になる
    - よって、探索の途中はその区間を持つことにする
        - 1: 答えで二分探索
            - 幅 <= x、具体的には p であって p - x/2 <= Ai <= p + x/2 に全てが収まるようなpが存在するものの最小値
            - 値xが取りうる値は区間、okなpも区間
            - 区間の和とか共通を取ると解ける
            - 操作の結果は10 ^ 18を超えないと祈って提出するとAC
        - 2: 正当
            - 何回も操作をすることで、値の上限が無いことが厄介
            - 固定1: 操作をしない要素がある場合
            - 明らかに上限がつく
            - その要素は固定して良い。つまり、目標期が定まる
            - 区間を全列挙することで、解ける
            - 固定2: 全ての要素に操作をする場合
            - 1回の操作の影響を前計算、みたいな事をしたい
            - 1回の操作で、差が広がる場合と広がらない場合がある
            - 場合分けすると想定解になる

- [取って良い値の範囲は区間になるので、持って木dpする](https://atcoder.jp/contests/arc063/tasks/arc063_c)
    
    

### クエリで情報を復元する問題
- 一部の情報がわかったら、その情報をクエリに盛り込むことで、今までよりも強力な情報を引き出せることがある
    - 特に、最小値や最大値がわかったときなど

- 必要な事: クエリ系問題/何かが明らかになったとき
- いつ考える: 常に
    - [1が分かる -> 単純な大小比較ができるようになる](https://atcoder.jp/contests/arc154/tasks/arc154_d)


## 何かがうまく行かなかった時
- ある解法で上手くいかなかったのなら、それは何故か考え、それを補完する方法を考える
    - その解法がうまくいく理由が満たされていない、が端的な理由
        - では、どうしたら良いか？
           - そういう状況にあった解法や構築を考える
            - 難しい所を固定してしまったり
            - 全探索の状態数を多くしたり
          

## 実際に手で解く/機械で列挙する
- 上で書いた事が見えやすく
    - ある程度進むと状況が急に簡潔に...
        - そこまでを固定すれば綺麗な解が生まれるということ

    - 実際に判定をする事で必要条件が見えるかも...
    - 何かできる綺麗な事実が見えるかも...

- [例題](https://atcoder.jp/contests/arc170/tasks/arc170_d)
    - ぱっと見よくわからない
    - 手で解くと、最後は貪欲
    - その前も貪欲

- [例題](https://atcoder.jp/contests/arc131/tasks/arc131_e)
    - 辺の必要条件は出せる
    - 他、よくわからないので、書いてみる

## 一旦制約の一部を忘れる
- それぞれについて整理 -> merge
- 必要な事: 一部を忘れた問題がまあまあ綺麗なこと。考察がmergeできる事。  
    - 制約が合わさったら、全く無駄になったら意味がない。例えば、実は片方の制約を無視して最適化できる等が、「まず純粋に最適化するには」の方法・自由度を把握したことによって判明するなどは好ましい。
- いつ考える: 考えることがいっぱいあって困った時。2つ以上の考える要素がある時。ある条件を満たすように最適化、が典型。また、一部を忘れたら綺麗な問題ができると思った時。
    - [(1) 最小の本数を (2)実際に操作手順が存在するように　切る](https://atcoder.jp/contests/abc290/tasks/abc290_g)
        - (1)と(2)を共に考えると難しい。特に、（2）がふんわりとしていて難しい。一旦(1)のみを考えて、実はそれが(2)のもとで実行可能、が成立したら解ける
        - 実際できる。 


### 一旦存在しないとして良い
問題のサイズを小さくしたり、本質だけ抜き取ったりできる。

- もう今後の考察に登場しない系
    - 使い方を決めている・使わないと決めているため、影響を処理できる

- 自由にできるから一旦抜き出す系
    - 自由に移動させられる・一致 <- 一旦抜き取って考えて、最後に挿入と考えると、一旦存在しないとできる

## 今までの似た問題の発想に頼る

## 上のどれも当てはまらなそう
- 確実にわかっていることを整理して、それで行けないか考える
    - 一般について言いたかったけど言えない感じの時、とりあえず言えることを整理したら、実は一般に言えなくてもokじゃん、みたいな

- 使ってない制約
    - で何かできないかな

- 勘を頑張って働かせる
    - 勘はあなたのperfを400上げる
    - 論理的に帰結できないことにも手が届く


- 問題の言い換えを機械的に試す
    - 視点を変えたら問題が綺麗になって自明になる・かつ、その言い換え自体は不自然に感じることはいくらでもある

- 実験する
    - 綺麗な事実であれば、結果を眺めれば分かる
    - この時、勝手に問題から情報をロストさせないこと。（ロストさせた情報が重要だったらどうする）

- 数列Aに対しA + A
    - Aのcyclic shiftをその連続部分列として全て含む
<br><br>

# 問題の言い換え
## 答えが変化しない範囲で自由度を増やす
- 不利になりうる方向に言い換える
    - $\sum min(a, b)$ の最小化 -> $a, b$のうち、好きな方を選ぶとして良い
    - 答えは変化しない上、考察が軽くなる場合がある
        - 特に、「結果を固定した時、実際にあり得るか（もっと有利になってしまうのでは）」と言う時、上の言い換えをすればそのようなややこしい議論を消せる
## 解けるケースへの帰着
- あるケースなら解けるという時、答えが変化しない範囲で他のケースを言い換えることによって帰着できる
    - 単位元的なものをaddすると良い

## 文字を数字で言い換える
数学の上で扱える
- 一般に、文字より数学の方が扱いやすい
    - 式変形
    - 貪欲
    - 寄与の分解
    - [文字を数字に-> シュミレーションの遷移を数式に -> キヨに分解で高速化](https://atcoder.jp/contests/arc117/tasks/arc117_c)
        - 上の説明のままをすると、解ける

## 例
- 隣に移動 -> x'i ＝ xi - i　の変換によって、同じ場所に移動
- 言い換えた後の問題の対応がわからない時: 元の座標で考えた後、結果だけを座標変換で移せばわかりやすい
    - [問題の考察・セグ木で持つべきデータが共に軽くなる](https://atcoder.jp/contests/abc371/submissions/58548762)
        - xi = g, xi+1 = g+1, xi+2 = g+2...に移す
        - ⇔ x'i = g - i, x'i+1 = g - i, x'i+2 = g - i...に移す
        - 階差数列の移動から、単に集合クエリになった
        - 考察軽い

    - [問題の考察・実装が軽くなる2](https://atcoder.jp/contests/agc048/tasks/agc048_c)
        - 同じ座標まで移動
        - 変換後で 目的...x' -> g'
        - できること...x'において、隣あうx'に移動
        - 元々ある座標しかありえない！
            - 元の問題では、元の座標+1, +2, ... などがありえた
        - 必要条件: $B \subset A$ でないとダメ
            - これが十分
            - 途中で十分性を判定するコード・考察より軽い
            - 証明は: 動く方向で場合分け
        - 移動の方向で分けてみると、それで良いことがわかるし、最小回数も予想がつく
<br><br>

# エスパー
- 仮説を立てる
- 否定されないならfin
- 否定されたら、なんでダメなのか考える
- 仮説2を立てる...


実験コードを早い段階で・丁寧に書く！
<br><br>

# 数列への値の振り分け

## 最適化
振り分けのコストが単調増加なら、安い方から貪欲で良い
- それで、安い方からk個取るを達成できる

## 数え上げ

### 素因数の振り分け
数列の総積を考える時、約数ではなく素因数まで分解すると、素因数を振り分ける問題になる（かつ、素因数ごとに独立になる)

### 組み合わせ的な振り分け
- 振り分ける対象に対称性があるなら、コンビネーションに落とせるかも
    - dp[iまで][cこ振り分けた]からオーダーが2つ落ちる
    - [例題](https://atcoder.jp/contests/arc102/tasks/arc102_c)


<br><br>

# グラフ
### https://hackmd.io/rLxLpW94TBOsPhy2XDdGtA

扱うのが得意な構造:
[1]2要素の関係
 - 2項方程式についても、グラフで表現することができる。
 - 2部グラフに出来ない⇔奇数長閉路が存在する

[2]状態の遷移
ともに、独立性を顕にし、かつ操作や遷移を辺として表現できる。
- 操作の最小回数

### 独立性を感じた時 : グラフでの図示

### 一般の木
根をつけて良い。
根付き木に関する概念を持ち込める。(先祖、部分木)

### DAGと木は違う

1 -> 2 -> 3
---------------->
のように、擬似的なサイクルができる
- 到達可能頂点の数え上げでコレが効いてくる(重複する)
### 木におけるまとまった頂点集合
根をつけて、部分木に対応させる。
自分の知っている知識を使える。他、木DP。

## 連結なら成立する、という状況の時
そのような状況について考えるとき、一般のグラフ上で考えるよりも、全域木を(損になる場合もあえて)取ってその上で考察した方が楽な場合が多々ある
- グラフに対する全探索は難しい
- 木DP!
    - 必要に応じて元の辺を復活させる
    - 全域木の取り方は任意。特に、定理の成立するものとしてdfs木がある。

## 取り敢えず全域木を取る
- 1: 端（葉）から順々に考える(構築していく)のでも上手くいくという時、全域木をとってから考えると上手く構築できる。
    - 特に、制約が「後から修正できるタイプ」の物（総和とかmodとか）だと、「部分木の結果を見て、根を調整する」のような手順で解ける場合がある

- 2: グラフの全てのパスの長さについて考察する時、あるいは、頂点を塗り分けるという時、全域木をとったのち各頂点について深さを求めておくと、その深さの値を用いて議論ができる場合がある
    - 例: 2部グラフ判定　深さ mod 2が異なる頂点を結んでいるかどうか？
    - 特に、ある頂点vを始点とするパスについて調べたい時、vを根として取る
        - [gcd(vを含む全てのサイクルの、それぞれのサイクル長)](https://atcoder.jp/contests/abc306/tasks/abc306_g)
            - 全てのパスを列挙することはもちろん出来ず、上手くやろうとしてもわからない
            - パスの長さについての考察 <- 全域木をとって、深さを埋める
                - 木に含まれていない辺が結んでいる2頂点の深さに注目すると、「全てのパス長がaのパイ数 <-> (判定できる条件)」がわかって、なんと解けてしまう


## 木における2頂点u, v
u, vを引っ張って両端に持っていく。u-vパス上 or notに分かれる。
パスが一意であるという性質から発生する諸々を理解しやすい。
- 例: 頂点 i, j, kがこの順で並んでいるか？
    - ⇔パス(i, k)上にjがあるか？
    - ⇔ dist(i, k) == dist(i, j) + dist(j, k) (ここで、辺を引っ張る考察を用いた)
### 頂点を陽に持たないグラフ
https://atcoder.jp/contests/abc361/tasks/abc361_g

### 到達できるか
多始点1終点ならば、1始点多終点にした方が良い。
- 無向グラフにおいて、到達可能性は同値関係である。そして、1始点多終点は計算量が良い。

#### 頂点に値が付与されている。ある辺uvについて、max(a[u], a[v]) = k
a[u] <= k, a[v] <= k かつ a[u] == k または a[v] == k
とすると扱いやすい事があった。特に、どちらもkを上回ってはいけないという事がより自明に。

## 同じ属性を持つ任意の2点への辺
- 属性を頂点にすることで、へんの本数を減らせる場合がある
    - 頂点と辺が入れ替わることもある

- 頻出: y座標を表す頂点とx座標を表す頂点で2部グラフ
    - [そうすると辺が減る](https://atcoder.jp/contests/arc045/tasks/arc045_d)
        - 頂点の削除->へんの削除になって、解きやすくすらなる
        - グラフの削除の問題は頂点削除するよりも辺を削除する方が解きやすい

### 橋
- サイクルに含まれる⇔橋では無い
- 同じ辺を使えないパスを考えるとき
    - パスが端を含む⇔辺素なパスは1種

## 複雑なsort/トポロジカルsort
全順序ではないが、「aよりbは前」のような制約がたくさんある状態で制約に違反しないように並べ替えたい時はトポロジカルsortする
- 閉路があるとダメ
- なお、トポロジカルsortの数え上げは、一般には難しい
- 隣接項にしか制約が無いとかだと2乗時間

## フロー
psp(頂点2つの選択肢、最適化)
辺cut, 頂点cut

- 特定の要素をなるべく使わないflowを流したい時
    - s -> その要素　の辺を外したflowと付けたflowで2回やると良い？

- [他とペアにしても良いし、自分でペアにしても良い](https://atcoder.jp/contests/abc263/tasks/abc263_g)
    - 貪欲...「異なる種同士のみでのペアを考えた時、ペアの個数が同じなら、自分でもペアにできる奴が最大個数残った方が良い」
        - 1をなるべく使わないflowを上の方法で得るとなんか通る
        - 凸だから3分探索に落ちるらしい(yet AC)

## max/mincost flowで解ける問題と、解き方
[別ページに](<max・mincost flowのグラフの作り方.md>)
## フローがあるなら貪欲がある
- らしい
- グラフを構築 -> そこから発想
    - 特に, maxflowならグラフが改善していく様子を、わざわざ探索せずにやる
        - maxflowなら頂点増やして再度流す、が許される    
## グラフアルゴリズム・頂点/辺の削減
ベースアイデア: 2要素間に辺を愚直に貼らずに、代表的を表す頂点を作って、 (辺を出す側の集合) -> (代表頂点) -> (辺が入る側の集合)
とすることで、辺の本数を(要素)^2から(要素)ぐらいにする。

- 必要なこと: 変形したグラフを用いても答えが変わらない事
    - もとの問題でその辺が表すべきだった状況が、変更後のグラフでも表せていれば良い
        - [前後関係: sからtに向かうパスを表せば良い](https://atcoder.jp/contests/abc277/tasks/abc277_f)
            - 1,2,2,2,2,3,3,3,3,4,4,4,4,4,5,5...のような数列を、数の大小に基づいてトポロジカルソートすることを考える
                - 普通のsortでは問題が解けない(並列に条件を追加するので)
            - 大きさが隣り合う数字にだけ貼るとしても、^2本の辺ができる
            - (値2) -> (代表) -> (値3)のようにすることを考える
            - 元の辺で表したかった状況がコレでも表されているので、この通りに貼れば良い
                - 答えが変わらないことの確認: 存在するなら、代表をそのまま2と3の間の任意の位置に置けば良い。
                - 代表の頂点を値ごとに使い回したりすると正当性が怪しくなるので注意
### 行、列を表す頂点+s, tだけを作って、flow問題をその上で表すやつ
計算量が落ちる
- [同じ行・列なら移動できる <-> 行hの頂点と列wの頂点を無向辺で結ぶ](https://atcoder.jp/contests/arc074/tasks/arc074_d)
### クリーク⇔補グラフ典型
くりーくである　⇔補グラフで独立集合
及び、
2部グラフ:= 独立集合2つに分離できるか
より、問題を二部グラフに落とせたりする
- [例題](https://atcoder.jp/contests/arc099/tasks/arc099_c)
- [例題](https://atcoder.jp/contests/agc067/tasks/agc067_a)

<br>

## psp(maxflowで解ける)
- 必要な事
    - 2値の割り当て
    - 2要素の制約/ all要素がooの時... 
- いつ考える
    - 最適化・判定
    - 要素が絡み合っていて、dp出来なさそう
    - 2値の割り当て
        - 使用する・しないもこれに含むので、結構広い

- [カメラのon/off](https://atcoder.jp/contests/abc274/tasks/abc274_g)
    - カメラはみぎor下として良い
    - ますごとに見ていくdpだと、「実は前もって埋められていた」がきつい
        - 独立性もなくて、横を前に決めるとしても結局同じ事
    - 全てのますについて、一番近いカメラ2つ組のon/offで制約を表せる
        - そのままだと「全て0/1なら失う」になって解けないが、横向き同士・縦向きどうしには辺がない(=二部グラフなので),横向きを反転するととける
- [黒or白。pspを使うために、二部グラフで01を反転](https://atcoder.jp/contests/abc193/tasks/abc193_f)

## mcf
「使用回数」に制限がある要素があって、その要素の使用でスコアが得られ、そのスコアをmin(maximize)したい時
- [同じ属性の人は被ってはいけない/同じ得意科目の人は被ってはないけない](https://atcoder.jp/contests/abc247/tasks/abc247_g)
    - 辺のコストをマイナスにする事でminimizeで問題に対応する
<br><br>


# 木
## 木DP
- 木についての全探索
- 全ての頂点についての値を求めるのではなく、「全ての部分木についての結果」を求めている
    - 木全体の結果は手に入る
    - 頂点同士が互いに制約を与え合うという時、木全体についての制約の結果を求められる
        - 全ての頂点については求めることはできない
        - 全方位にすれば良い
        - [頂点同士が制約を及ぼしあう時、木全体として満たす構築があるかを木dpで判定](https://atcoder.jp/contests/arc063/tasks/arc063_c)
            - 頂点について、取って良い値は区間になる
            - 隣り合う頂点同士が影響し合あう
            - 全体として満たすものはあるか？
            - 木DPすればわかる
            - わかったら、根からやっていくことで、それぞれの部分木についてもさっき求めた情報+追加の情報から求められる

- 必要な事: dpテーブルがそれで回る事。
    - 往々にして、「状況が部分木間である程度独立」であると、マージが簡潔に書けてできやすい。
- いつ考える: 木で全探索を考える時。つまり、積極的に・いつも。

## 木DPの設計
### 部分森を管理する
https://atcoder.jp/contests/abc351/editorial/9868
辺に重みがある時にやりやすいと思う
しかし、根がたくさん発生するので、普通考えづらいと思う

### よくある
![alt](<images/IMG_0056 .jpeg>)
根が常に2つ（高い根、低い根）しかなくて、これをよくやる
- 今までの部分木・新たにつける部分木の状態を場合分けして、dpテーブルを作る
    - 往々にして、「高い根の状態」と「新たにつける、低い根」の状態を全探索して、そこから次のテーブルを作る


## 2乗の木DP
木dpのテーブルのマージにおいて、サイズ $n$ と $m$ をマージする際
- $O(nm)$ ... $O(|V^2|)$
- $O((n + m)m)$ ... $O(|V^3|)$
である。
    - よって、下記の書き方をしてはいけない。特に、マージ後のテーブルのサイズが $n + m$ になると言う時、それ + テーブル $m$ を走査すると下記の計算量になる。
    - ほとんどの場合、 $n$ 通りの何かと $m$ 通りの何かを全探索すれば事足りる。よって、そのような書き方をする。
        - [結果を固定しなくても、マージ前でそれぞれ固定すれば結果が固定される](https://atcoder.jp/contests/arc130/tasks/arc130_d)

### 木に辺が増えていく時
mergeテク

### 木dpで、mergeの計算量が「小さい方の部分木のsiz」
mergeテク

#### dpで、mergeの計算量がsiz * siz
愚直にやってもN^2

### 木の頂点が色や値によって独立に分類されている時
圧縮木
https://atcoder.jp/contests/abc359/tasks/abc359_g
https://atcoder.jp/contests/abc340/tasks/abc340_g


### 部分木に対する操作・制約
- オイラーツアーすることによって、数列の連続部分列に対する制約に言い換え
- 他の事柄も言い換えられれば、あとは数列に対する問題に
    - 基本的に、楽になる
    - [例題](https://atcoder.jp/contests/kupc2018/tasks/kupc2018_m)

    - 楽にならない場合もある
        - [例題](https://www.codechef.com/START150A)
            - 列に還元した問題すら解けない
            - 木に戻る
            - 部分木制約だけなら解けるので...補部分木の制約を、何かを固定することで無視したい

### パスの数え上げ
- 頂点vをlcaとするパス、で木dp
- 頂点vを通るパス、で重心分解
- 条件を言い換えて別に帰着


- [例題](https://atcoder.jp/contests/arc045/tasks/arc045_c)
    - 頂点vをlcaとするパス、で良い
        - ｖから伸びるパスを記録する
        - マージに時間がかかりそう-> マージテクで良い

## 2頂点を端に引っ張る考察
見やすくなる

- [直径を端に引っ張った時のグラフの形の制約](https://atcoder.jp/contests/agc005/tasks/agc005_c)
    - maxは2つあるとして良い
    - 直径を端に引っ張ったグラフをみよう
    - 存在して良い距離の範囲と、そのほとんどがいくらでもあって良いことがわかる

## root -> v の情報(for all v), 差分更新
- dfsするだけ
    - 差分更新的にできて、複雑なクエリもできる

## staticな木に対するクエリ
- 逆元があれば、 query(u, v) = query(root, u) + query(root, v) - 2 * query(root, lca(u, v))
<br><br>






# 数列の連続部分列
積極的に累積和/差分列の問題へ言い換える
- 一様ならば: 2要素への何かになる
    - 一般に、n要素より計算量が落ちやすい
            - [例題](https://atcoder.jp/contests/abc365/tasks/abc365_e)
        - 2要素への操作はグラフに言い換える典型
    - 言い換える時は、ちゃんと問題が丸ごと言い変えられる必要がある

- 生で見るより、言い換えた方が見通しが良くなる問題は確実にある
    - [例題](https://atcoder.jp/contests/arc129/tasks/arc129_d)


### 連続部分列に関する制約
- 左から決めていくdp
    - [0, r]に収まる制約を全て満たすような...
        - 違反する可能性があるのが、[?, r]しかないような場合
        -
- 区間dp
    - [l, r]に収まる制約を全て満たすような...
        - ある特徴的な要素の位置を決めると、そこを跨ぐ制約が全て無視できる場合
### 連続部分列へのクエリ
分割統治的な解法で解くことで、セグ木に乗せられる場合がある。
l = 1, r = nを分割統治で解くと良いだろう

### 数列の区間

#### 「区間が交わる」条件より、「区間が交わらない」条件の方が簡潔
 - 特に、関係は一意なので、右側 or 左側のどちらかに注目すれば良い
 - https://atcoder.jp/contests/abc355/tasks/abc355_d
### 区間 ⇔ 2d平面の言い換え
データ構造の利用・平面操作の利用を期待できる。
理由 : 区間(に限らず2値で大小関係が重要なもの)を、2次元平面上の問題に落とすことで、次元が増える代わりに問題が簡略化される。

#### 全ての区間についての計算
dp[r] := 右端 = rの区間についての答え (注 : [1, r]に収まる、でも良いが、単にこちらの方が制約が増える)
とするdpが成立しやすい
    - 理由 : 区間の計算について、どこかで"切って"考えて良い場合は、昔の結果を利用するという意味で上のdpが成立することが多い https://atcoder.jp/contests/arc169
    
<br><br>

# 順番に寄らない
好きな順番で決定できる。よって、dpと相性が良い。疑うべき。

   - 違反するような部分が無くなるように数列に操作...左から、「これより左に違反部分はなくて、かつ末尾の状態がSTATEのうち、操作回数が最小」等 P329
   - 交わる部分が無いように、数列を分割...前から分割を決めていく
   - 集合に0/1を割り振る ... 前の要素から0/1を決めていく

# 順番が一意にさだまる
sortして、前の方から決めていくdpができる。
- 影響が数式で簡潔に書けそうな時

- [例題](https://atcoder.jp/contests/abc366/tasks/abc366_f)
- [例題](https://atcoder.jp/contests/arc053/tasks/arc053_c)
    - Ai - Biの符号と Aj - Bjの符号で、議論が変化する
    - よって、混じったsortは無理そう
    - しかし、Ai - Biについて、符号が違うやつは混ざらないことが言える
<br><br>

#### 操作によって要素が独立になる
どんどん問題を小さく&&独立にしていける。dpと相性が良い。
また、独立性という観点から、グラフとも相性が良い。

#### 操作をすること自体にもコストが発生する
言い換え : [1]どの要素に操作をするか [2]どれだけ操作をするか
の2つを決めると思う。すると、構造がすっきりする。

<br><br>


### 単調増加
- 扱いづらい
- 差分列を取ると、条件が"要素が0以上"に言い換えられる
    - 他の条件も言い換えられるなら、問題が単純になる場合が多い
        - [例題](https://atcoder.jp/contests/arc023/tasks/arc023_3)

### 等差数列
- 同様に扱いづらい
- 差分列を取ると、条件が"全ての要素が等しい"になる
- 及び、3項の場合
    - $x \le y \le z$について、 $z - y = y - x$
    - を
    - $2y = x + z$
    - や
    - $2y - x - z = 0$
    - のように、$y$が片方にしか登場しない形にした方が良い場合がある
    - 一般に、条件に含まれる = が一つなら、両辺に同じ文字が登場するよりまとめた方が単純？
    - [例題](https://atcoder.jp/contests/arc145/tasks/arc145_d/editorial)
        - 任意のx, y, zについて 2y != x + z
            - x < y< zを課さない方が考えやすい&&課さなくても良い
        - 2倍したやつが一致しない...
        - 3進数で0/1のみ

<br><br>


# 辞書順最小
- 採用できる母集合を求める
- その中で最小のものを求める
    - 採用できる母集合を厳密に求めるのが難しい時: より広い集合をとって、小さい方から「採用できるか？」の判定問題を解く
- 値としてそれを採用する
- 値としてそれを採用する中で、まだ残っている自由度・それを採用する上での操作の自由度を整理する
- 制約にその自由度を加算した上で、次に進む

- よくある勘違い: なんらかの制約によって、ある桁について見る時、あり得える母集団のうち最小値がとれない時
    - 最小値が取れないからといって、その桁を無視して良いわけでは無い。取れる値のうち最小値を取らなければならない
    - つまり、あり得る母集団のうちminする事が叶わないなら、2番目にする、3番目にする...としなければならない
    - 一般に、ある桁について、一意で無いならば、"無視して良い"と言える状況は少ないだろう

- [難し目の例題](https://atcoder.jp/contests/arc175/submissions/58106705)
    - 最小化 -> 辞書順最小の順
        - 最小にするにはどうしたら？
            - 固定しても上手くいかない
            - 方針: 貪欲を取ろう
                - ついでに、「前から最適に作っていく」という方針戻る
                - 最小値ok の範囲を更新していく事でもとまりそう
            - 最小化についてひと段落ついた
            - **では、最小値を取るような初項の範囲を考えよう**
            - 先ほどの貪欲を考えると、逆からやる事で初項の範囲がわかる
            - 初項を決めると、貪欲を元に後ろもできる

- [初項を決めると、それによる制限から問題がガラっと変わる時もある -> 固定を増やしたら要整理](https://atcoder.jp/contests/abc262/tasks/abc262_f)
    - 初項を決めると、その調整のために操作の概形が決まる

<br><br>

### 操作の復元・構築
 - 結果のうち、極端な物を見る
     - そこに関与する部分の操作が一意に決まり、それによってまた"極端な物"が生まれる可能性
     - グリッドなら左上等
     
     
## sortする
言い換え :転倒数を0にする

<br><br>

# k番目の値を求める
- 言い換え: 自分以下の値の個数がk個以上である要素のうち、最小のものを答える。
    - 二分探索を挟む事で、「自分以下の値はいくつあるか？」を数える問題になる。
    - 何番目？の制約より直接的で、求めやすい
    - [例題](https://atcoder.jp/contests/abc155/submissions/57393722)

- dpしながら: topKを保持しつつ、配るdpではなく貰うdpで計算することでオーダーレベルで高速に計算できる
    - $O(KV\log K + V ^ 2)$

- shortest kth path(not DAG) : https://qiita.com/nariaki3551/items/821dc6ffdc552d3d5f22
    - $O(KV((E + V)logV)) or V^2ダイクストラで O(KV^3)らしい$

- kth takoyaki : 今順位が決定している集合と、それを一段回だけ悪化させたものを持って貪欲に決定していく。https://atcoder.jp/contests/abc297/tasks/abc297_e 


- 桁dp : 上の方の桁から決めていく

### 辞書順k番目
- 先頭から数字を決めていく。
    - 必要なこと:「prefixがoooである様な要素は何個存在するか？」を解くことになる。後ろが空文字列、つまり打ち切りという遷移が常にあり得ることに注意。
    - よって、これがすぐにはもとまらない場合、別途dpして求める等の必要性が出てくる
    

### k番目までの総和を求める
条件: x <= (k番目以下) の和
具体的に「k番目は何か？」を求める
- 条件が単なる数式となって、扱いやすくなる
- **先ほどと同じく、順番の制約を、順番の項に値を代入することで値の大小の制約に落とすのが大事**
    - **一般に、式に未知の定数が混じっていたら、それをまず求める**
        - それによって単なる数字になるから
    - [例題](https://atcoder.jp/contests/arc021/tasks/arc021_3)
- k番めまでの和は、一様な集合に対しては、要素のadd/delを $O(\log n)$ で取得できる
    - 種類の違う集合についても、種類で分けて集合を持てば管理できる
    - [例題](https://atcoder.jp/contests/codequeen2024-final-N9tn8QqD/tasks/codequeen2024_final_h)
    - xがk番目⇔x以下の個数がk以上になる初めての数
    - k個以下になる最大の数、ではない
<br><br>

# 重複

### 重複に気づく為に
思い出す: dpが満たすべき条件
-  (重複を許さないならば)1つの探索対象が、dp重複して探索されないこと
    - ⇔任意の探索対象について、探索の任意の段階において、2つ以上の状態へと分かれて遷移することがない
        - 気づき方: 重複しやすそうな探索対象を一つとって、手でdpしてみる
            - ポイント: 具体例を持ってきて、実際に判定する姿勢
            - 例: (1, 2)を、要素数1の集合に分解した集合族の個数は？
            - dpで一つずつ集合に分解すると、 ((1), (2)) において、 $\emptyset$ -> (1)/(2) となり、最初の遷移で2つに分かれるためダメ


- 同じ数え上げ対象が、2つ以上の状態を持たないか
    - dpで持つ状態を増やすとなりがち
    - 特に、操作列の数え上げでは無く、数列の数え上げですという時
    - [例題](https://atcoder.jp/contests/arc180/tasks/arc180_c)
        - 採用する集合を選ぶ
        - prefix sumも必要
        - 持たせると重複！

### 数え上げ: 重複なく数え上げる
これら全て、重複を省く: 1回だけ数えるというモチベの元の案である

- 重複がない <-> 全ての探索対象が、探索の各段階においてちょうど1つの状態に当てはまる
           <-> 全ての探索対象が、1回も分岐せずに最後まで探索される
    - 2つめを意識すると照明が楽なことが多い

- 考察 : **数え上げる対象 or notはどうやって判定するか？**
dpを考える時に基本的な考え方。基本的に、判定の過程で同じものが分岐することによって、重複は起こる.
    - つまり、分岐さえなくせれば良い
    - 分岐がないような判定方法をdpとする...
        - 部分文字列: 先頭から貪欲に採用する
    - 可能性を全て情報とするdpをする...
        - NFA -> DFAみたいな
        - 状態の集合を状態とする
            - [例題](https://atcoder.jp/contests/arc058/tasks/arc058_c)
            
- 一旦全てを区別するものとして数え上げながら、要所要所で掛けて区別しない場合に還元する
    - 集合の数え上げなど
    - 係数をかけられる必要がある
            
- 考察 : どういう時に異なるか?/どういう時に重複が発生してしまうか？
重複特有の考え方
    - **"異なる操作"を1stepとするdpを立てる**
        - 例: 選んでいくdpなら、
        - dp[i][State]...iまでみて...から
        - dp[i][State]...最後にiを選んで変化させた。State
        - にして、次に変化させるまで飛ばす（間で変化しない選択を何回なするかもしれない)
        - この時、遷移では"遷移で0回/2回以上変化する"遷移を許してはいけない。**数え上げるdpは常に最小単位で遷移しなければならない**。
            - 最適化は重複しても良いので、2回以上遷移しても良い(しかし、最小単位に満たないやつは事故りやすい)
        
    - 重複の方を数える
        - 部分文字列の種類数...SA + LCA
    
- **重複が発生しないようなルールを作る**
    - 数え上げる対象を具体的に一つとって、それが一意に・1回だけ数えられるようにdpの遷移を制限する
    - 必要な事: 各数え上げ対象が、dpの遷移のそれぞれの段階においてちょうど1回含まれる事
        - 逆に、これが満たされていれば他に懸念することはない
    - いつ考える: これも重複を省くスタンダードな方法の1つ
        - [作れるかの判定 -> 最後の項の前までは貪欲できる -> 最後の項の前までを数え上げるdp](https://atcoder.jp/contests/abc230/tasks/abc230_f)
            - dp[r]:=rまで使って分割を消めた。distinct'
                - これだと、結果が同じになる数列が2つ以上の状態に入ってしまう
            - 分割のラストに、累積和 = 0の区間を含めないとすると、作り方が1意になる
            - そこまでをdpする事にして、末尾に累積和＝0の区間を含めないとするとぶんきしない
        - [集合への分割 -> 残っている中でminの要素を、次の集合へと必ず含める]
            - 集合に分割していこう
                - 残り要素数しか係数にかかわらなそう？
                - しかし、残り要素を集合にもつdpの時点で、重複が発生している
                    - 原因は、{2, 3}{4, 5}のような分割で、どっちを先に作るかで分かれてしまうこと
                    - minが含まれる方を先に作る事にしよう
                    - 任意の分割で、分岐しないことがわかる.
        - [適当にやると重複する -> 今回決める頂点のうち、番号が小さい方から辺の貼り方を決める、とする](https://atcoder.jp/contests/abc281/tasks/abc281_g)
            - 頂点の集合を割り振る、ここまではok。これから、グラフに重複が起きないようにどうすれば良い？
            - 決定の時、今回割り振られた集合のうち、番号が小さい方から辺の貼り方を決めるとする
- 考察 : **数え上げの対象になるのは何か(視線を数え上げ対象に移す)
    - 判定問題になり、重複は最早関係ない
    - 数え上げの一般的なテクでもある
        - [重複・対象を見る](https://atcoder.jp/contests/arc014/editorial/446)
            - 行ごとに見ると、重複が入る
            - 各行の間について、数えるのはどれだけか？
                - 2種: full, not full
                - fullは合計を、not fullはx + yの寄与
                - 境目を二分探索で求まる
- 2つの集合から重複を省く : 母集団が大きい方を含め、小さい方から排除する方が楽
https://atcoder.jp/contests/abc361/tasks/abc361_f

### 否定と重複の関係
- 1箇所以上でooを満たす、を数え上げる際に「全く満たさない」を数え上げても良い
    - 1箇所以上の判定では、複数箇所満たす場所があった際に、素直なdpでは分岐してしまう恐れ
    - 全く満たさないならば、満たしたらoutを守るだけでおk


- tips:集合二分割していくdp
- 終わりを見ればわかる通り、集合の数だけ「切り出し方」に自由度があって重複しやすい
- 係数を途中でかけて調整も難しい
    - 個数ごとに切り分けるとしても調和級数logがかかる
    - 個数に制限ない時、最後に修正も無理
- 一意に分割するルールを決めた方が無難
<br><br>

### 操作: 同じ操作を2回しては行けない
- 集合を決めるdp

#### 同じ位置に2回操作をしてはいけない
- 極端な場所からやる
    - 区間について、左からやる事で lについて独立が保証される

### [0, r]を全て作れ
n進数(特に、2進数)
発展 : [0, r]を一意... 簡略化: rが2冪 - 1をまず考える。 解法例 : 表せない分は下駄を履かせた上で[0, r2]に帰着
発展 : [l, r]を作れ...[0, r - l]に簡略化


## 集合の数え上げ⇔数列の数え上げ
- 集合の数え上げをする時,
    -  並べ替えを全て数える
        - 並べ替えで条件の違反の可否が変化するものでもなければ、普通全て数えられる
    -  後から並べ替えの通りで割る
- という条件さえ守れば、数列を数え上げるとして良い
- 探索的に解くと集合に重複が発生してしまうという時、それを解消出来る
- 特に、集合の数え上げだからといって、小さい要素からadd/notを決めていくという事をしなくても良くなったりする
- [例題](https://atcoder.jp/contests/arc146/tasks/arc146_c)

<br><br>

# 小さい・極端な値の制約
- 小さいサイズの例では、小さい値の働きが良くわからない
    - 高速化も見え辛い
    - 小さい制約が出た時は、大きなサイズの例で考える
## その値についての全探索により、情報を得る
- 答えのあり得る値が少ない時、あり得るか？を全探索...
- プレイヤーについて直接確率を求めるのが難しい時、盤面についてbitdpで確率を求めてから人について確率を求める...
- グラフのマスの個数が少ない時、それ、あるいは頂点のペアをkeyにして何かを計算する...

## keyとvalueのswap
- dpの値として入れる要素について、keyと比べてかなり大きくても良い。
- よって、小さい値をkeyに持ってきて、残りをvalueに入れると高速化になる

- [pre削除ではなく、本削除をkeyにもつ](https://atcoder.jp/contests/abc203/tasks/abc203_f)
    - 本削除は30回程度
        - これをkeyに持ったdpが？
        - できる
- [例題](https://atcoder.jp/contests/arc068/tasks/arc068_c)
    - 区間について、含まれうるdの必要十分は？
        - 数式にすると、ceil(l, d) <= floor(r, d)
        - floor(r, d)の種類数は少ない
        - floor(r, d)が等しくなるdについて、まとめて計算する
### 制約の列挙
意味のある制約だけを抜き出そうとせず、列挙してしまうと楽
- [例題](https://atcoder.jp/contests/arc105/tasks/arc105_c)
    - 各橋について、「重さがwiを超えるような列の長さはLi以上」と言う制約がつく
        - 重さが超えないやつについてもinfとかで埋めとく

#### 小さい値のキーについて、"意味のある分だけ一気に遷移する"ようなdpは悪手がち
- 別に、一気に遷移させる旨みがない
- dpが複雑になり、他の部分の高速化が見えずらい
- 問題の構造も見え辛くなる
[url](https://onlinejudge.u-aizu.ac.jp/problems/0537)



### max/min 
一般のk番目と比べ、場合分け的な発想により高速に求まる場合が多い

### 2, 3番目
max/2/3番目を全て管理することによって求める

### 全体・集合への条件
各2要素への条件に分割して、グラフアルゴリズム
    - 「辺で結ばれていたらng」...最大独立集合
    - 「0 / 1割り当て・罰金や報酬」...燃やす埋める
    
### 条件を満たす小さい集合の最大サイズ・合計スコア
答えの集合を全探索・半分全探索
  - 条件が「満たさないなら入れてはいけない」の時、集合の条件を2要素間の条件に言い換えられたらば、最大独立集合
  - 条件が「入れても良いが、入れたら罰金」みたいな時、フロー・燃やす埋めるの可能性
#### 一般化せずに、列挙するような条件変形
例えば、「木において、間に1頂点しかない」という条件を考える。
 ・距離 = 2 ... 2という小さい値を活かせない 一般の距離を求めらんないときつい
 ・実際の位置関係...  じつは数通りしかない。よって、それらを全探索する。

### 小さい方・大きい方から選べる
- マージテク

- 合計が定められている数列において、相異なるQこのペアのminの和
    - distinctであることが重要
    - https://x.com/SSRS_cp/status/1819732406972404184
    

<br><br>
# 差分を更新する計算
- 必要なこと: 差分の更新が高速にできること
- いつ考える
    - 順々に何かの値を求めていく時
        - 差分を取る以上、複数種類のを何個も求める時に良い
    - 毎回のクエリを独立に捌くことは、前計算込みでもできそうにないが高速化したい時
        - 特に、差分の更新さえ高速であれば良い。
        - 二分探索 <-> 尺取り法
            - 集合の要素を全て保持したい時、毎回集合の要素を1から拾っては間に合わないが、差分は小さい（合計変化が抑えられる）など

- 区間内の集合管理は、区間について何らか単調性があれば計算量が抑えられることが多い。単調性がなくても、激しく境界が動かなければ。
- [grundy数の計算...パラメータをちょっと変えて計算していく<-差分更新](https://atcoder.jp/contests/abc278/tasks/abc278_g)
    - 毎回高速にやるのは（mexの中身を毎回構築するのでは）無理
        - mexの集合の変化を考えると、せいぜい2n個ずつしか変化しない
        - セグ木でシュミレーションすれば、差分を更新する手法で求まる

<br><br>

# 前計算
- 1.繰り返し同じものを計算する時、1回だけ計算しておく
    - 計算するものの種類数よりも、その数の方が大きい時
    - [判定の回数はO(N^2)だが、判定の種類数はO(N)/複数の選択肢を掛け合わせるような問題](https://atcoder.jp/contests/panasonic2020/tasks/panasonic2020_e)
        - ずらし方を全探索する
            - 実は、間に空白を2つ以上含めるのが最適な場合もある
            - 3要素だから
        - ずらし方の候補はO(N^2)あり、1回にO(N)かかる
            - しかし、中で行う判定には、(i, j, k) (i,j=01, k=n)のパラメータで表されるものしかない（ように分解できる)
            - 判定の結果を前計算しておこう 
- 3.計算に入る前に何かしらのデータ構造を用意できるなら、それを用意しておく
    - パラメータの固定は、コレのために外側に持っていく

- 2.後々になって何かを計算するという時、その「本計算」でのオーダーを落とすために、(その対象が全探索できる範囲に入っているならば)、何かしらのテーブルを用意して高速化できるかも
    - 特に、本計算で質の異なる計算を複数する時は、先に何か準備できないか考えると良い
    - [nim: 山の分裂 分裂後のg[a]^g[b] = tarとなるような分裂はあるか](https://atcoder.jp/contests/abc278/tasks/abc278_g/editorial)
        - aとbの個数を全探索できる
        - 分裂後に作れる山の条件... L <= a + b <= R の形
        - g[a]^g[b]ごとに、a+bの順でsortして入れておけばlogで所望の分裂を見つけられる
<br><br>

# シュミレーション/判定

## 長いシュミレーション
以下では、遷移が一意なシュミレーションに対する高速化の手段を述べる
- 単に、シュミレーションせよと言われた時...
- 貪欲によって、判定問題の遷移が一意になった時...
## ダブリングによる高速化
必要な事: 状態と、それにより定まる一意な遷移が定義できれば良い。
- 状態のテーブルサイズが大きすぎるとダメ
いつ考える: 「遷移が一意に定まる」シュミレーションを高速化したい時

- テーブルさえ作れれば、特別な実装上の注意は要らない事が多い
    - 保持できる程度のサイズ && それの繰り返しによってシュミレーションを記述できるようなテーブルを選ぶ必要がある。
- "似た状態"が繰り返される時、その遷移のテーブルからk回を辿れる
- 必要: 繰り返される状態
    - 似た状態が繰り返される時、それを状態にできないか睨む

- [頂点:時間を状態にもてない -> 「最後に乗ったバス」を状態に持ってもシュミレーションを記述できる](https://atcoder.jp/contests/abc212/tasks/abc212_f)
#### ダブリングでないと厳しい問題
- [例題](https://atcoder.jp/contests/abc370/tasks/abc370_f)
    - $O(N)$単体では間に合うが、それを$O(N)$回するので間に合わない
    - 貪欲によるシュミレーション(遷移が一意なもの)を、ダブリングで$O(\log n)$にする
## ループを利用したショートカット
- ループがある事が必要条件
- ループに入るまでの距離・ループの距離によっては、ループがあっても利用できない
- ループに入るまではどこまでか・どこからループでどこまでループなのか・の処理がやや面倒くさい
- しかし、これでしか解けないタイプのものもある（計算量の話ではない)
    - [例題](https://atcoder.jp/contests/arc051/tasks/arc051_c)
        - minを選んで、値を大きくしていく
        - 周期性はいつ生まれるか？
        - minがmaxを飛び越えるようになると、もうrotateになる
            - 元の値の大小と、操作後の値の大小が一致するので、全てがmaxの後ろに回るようになる

### 特定の段階に注目する
- 状態が多いという時、特定の状態だけに注目し、その状態と計算した情報を用いて計算する。
    - 状態を纏めるというモチベではないが、「答えを求める上で必要な情報・イベントだけを状態に保つ計算」というのはdpと共通。
        - よって、dpと同じような高速化ができそう
- 必要な事
    - 状態を元に答えが計算できる。かつ、状態の情報も更新できる。
        - 例えば、特定の段階だけを抽出するなら、ある段階 -> 次の段階　までの情報が計算できる必要がある
            - 再帰的にやりたい
        - 状態の数が多すぎると厳しい
- いつ考える
    - シュミレーションの状態が多くて、愚直シュミレーションしか出ない時
    - これを元にダブリング・周期性に飛んでもよさそう

- 状態の考え方として特に、「シュミレーションの始めの状態である」のに必要な情報を状態に保つことが多い
    - 多少の情報が違っても、「シュミレーションをそこから始める」と思えば、再帰的に諸々を計算できる。かつ、答えを計算するのに、初期状態があるとそこを参照すれば良く都合が良い。


## シュミレーションを、数学的な値で表すことによる高速化
- 手順が与えられた時、結果を高速に求めろというのは難しい
- しかし、数学的な操作（和を取るとか、何かのsumがOOになるまでやるとか）で表せれば、高速化しやすい
    - 色を数字にするのはこの動機
    
## シュミレーションの特徴量を考える/前計算をすることによる高速化
- 愚直は自明なので、高速に求めましょうという時
    - いきなり解法について考える前に、前計算として有効なものを考える
    - シュミレーションで追うべき情報は何か
    - シュミレーションでロストしてしまって良い情報は何か？
## 何かの種類数が少ないシュミレーション
それを段階に全探索ができれば通る
たんｔちょう単調なうご動きをしているなか中でｚじょうｎん条件をみたすま満たすまで、をかんがえれ考えればよくな良くなりら楽
- [例題](https://atcoder.jp/contests/arc159/tasks/arc159_b)
    - 引く数は、abs(a - b)の約数に限る
    - かつ、引く数は倍々になっていくのみ
    - つまり、引く数の種類数は、せいぜい $\sqrt{A}, \sqrt{B}$で抑えられる
    - 次に引く数が変化するのはいつか？が求まれば、高速にシュミレーションできる！
        - ad-hocな考察をすれば解ける
        - gcdで割っても答えが変化しないことより、gcdで先に割ると、常に引く数 = 1からの変化でよくて、楽になる

- [例題](https://atcoder.jp/contests/abc368/tasks/abc368_g)
    - B >= 2のところは60回以上は通らない
    - そこまでセグ木で飛ばせば良い
    
### 変化の回数が少ないシュミレーション
- 毎回求め直していては間に合わないという時、変化の回数が少ないならば、「今回変化するか？」をやる事で間に合う
    - [例題](https://codeforces.com/contest/2013/problem/E)
        - v, {a0, a1... an-1}がある
            - gcd(v, ai)がminになるやつについて、aiを抜き取って v = gcd(v, ai)
            - vのsumを求めよ
            - 毎回gcdを取っていたら $O(n ^ 2\log ai )$とか
            - gcd(v, ai)について、変化の回数は $\log v$ 回程度
            - つまり、vは $\log ai$回ののちに1になる
            - よって、 $O(n \log ai)$で通る

## 途中まで単純な動きをするが、ある時点から変な動きをするシュミレーション

- 最初に変な動きになるのはいつか？が二分探索で求まりがち
    - 直前まで単純な動きをしていたと仮定した時、今変な動きに変化するか？の判定問題で二分探索
    - [例題](https://atcoder.jp/contests/arc082/tasks/arc082_d)

- 状態がまとまる...一つに扱える
    - 特に、まとまる条件に単調性がある時、「まとまる」をさらに「境界にある状態と同じ動きをするようになる」と言えたりする
        - これにより、状態が[1] 状態Xと同じ動きするやつ [2]最初から単純な動きしてるやつ の2つに分けられたりする
        - [例題](https://atcoder.jp/contests/arc082/tasks/arc082_d)
## 初期条件を決めたらシュミレーションの様子が一意に定まる
- 初期条件から結果を表せないか。特に、数式で表せないか。
- 取りうる結果の必要十分条件は？


## 動的に形を変化させるシミュレーションは遅いがち -> させなくてもなんとかなりがち
形を保ったまま重みの変更にで対処
- 例えば、木の辺が縮約される、配列がrotateされる...
- これらを素直にやると、大抵計算量が厳しくなる
- 実際にやらずに、必要な情報を得る方針で書くように努める
    - [辺の削除 -> 重みを0にする HLD](https://atcoder.jp/contests/abc133/tasks/abc133_f)
        - 各色に対して毎回専用の木を作っていてはダメ
        - 形が一定...色cについて求めたい時は、色cの辺だけ重みを付加した状態にする
        - その後、色cの辺の重みを0にする事で削除する

    - [例題](https://atcoder.jp/contests/arc043/tasks/arc043_c)
        - 配列のrotateをやりたくない
        - 一番右まで動かす時、何回swap?
        - 「最初の時点で右にいた&&まだ動かされていない」
        - seg[i] := 最初iにあったやつは動かされたか？

    - [配列のrotate -> 繰り返した配列上のスライド](https://atcoder.jp/contests/abc337/tasks/abc337_f)
        - rotateと考えると、添え字が一気にズレるのに対応するのが大変
        - A + A上でスライドすると考える
        - チャンスボールの個数...単調 尺取り方できる

- 区間に対する何かしらの"変化"は、遅延セグ木で扱えがち
    - [累積和列の一致判定 -> 累積和への変化は範囲なので、それを遅延セグ木で行い、列の統合はhashでやる](https://atcoder.jp/contests/abc238/tasks/abc238_g)


### 最適化

- 典型: 要素の並び順を決めたのち、シュミレーションに従って要素を振り分けていく...結果の集合を固定したら、大抵の場合その集合になるような並び順が存在する
    - https://atcoder.jp/contests/agc054/tasks/agc054_b
　　　　- https://icpc.iisf.or.jp/past-icpc/domestic2021/contest/all_ja.htmlの D
        - スライドする、と考えると結果を使えないので、消費スペースを区別する必要がある

## 無限に続くかもしれないシュミレーションの無限判定
- 大抵グラフのサイクル検出に落とす。ダブリングと同じで、状態の考察が重要。繰り返されるもの。
- 有向グラフ・サイクルがあるかもしれない...in[v]とout[v]を持つ。in[v]とout[v]の値で場合分け。
<br><br>

# 重実装・シミュレーション

- 書く前にサンプルを試す
    - 後から実装を膨らませないようにする
- 処理の共通化をする
    - 積極的に関数を作る
    - しかし、一つに統合できる関数は統合する(例 : add/delete )

- 枝分かれしないシュミレーションはwhile文で書ける
    - 速い
    
- クエリの重複
    - クエリごとに代表のクエリ番号とか付けるより、クエリそのものをkeyに答えを出して、それを後から還元した方が楽

- 長さを表す変数の値は変えない方が良い
    - [失敗例](https://atcoder.jp/contests/arc181/submissions/56364913)
-  処理に「中途半端な場合」と「纏めて処理する場合」の様に場合分けが生じる場合、「1stepだけ進める」処理を書いて、それの繰り返しで両方を表すことにすると処理が共通化される。


- 1回の処理で、どれだけシュミレーションを進めるか決定する

- 処理すべき対象：起こりうるイベントを列挙する
    - 1回の処理で、そのイベントが2回以上起こる場合をちゃんと処理する
        - 要素が直進する中で、要素がぶつかる... 2回以上一度にぶつかることは？

## 初期値が与えられるシュミレーション
- 初期値がノイズとなる場合がある
    - ある程度シュミレーションが進むと、ある動きに収束する
        - 初期値が極端な時は、それを補正するように動く
    - よって、シュミレーションの挙動を考える時、「ある程度シュミレーションが進むとどうなるか？」を考えると良い
        - [ある程度シュミレーションが進むと？](https://atcoder.jp/contests/agc026/tasks/agc026_b)
            - まず、問題を数学で置き換えよう
                - 1日ごとのジュースの変化を関数として表す
            - ある程度シュミレーションが進むと？
            - Cの近くでうろうろすることになる <- 明らかに最初と違う！
                - うろうろするとは
                    - 数直線上で見る
                    - T軸は要らない
                - + (D - B) or  - B
                - - B は常にある
                - 動く範囲はD
                - mod Dで見ると、ひたすら-Bをする操作!
                    - 無限に続く⇔任意の回数において、条件を違反しない と読む
                    - 判定...最小値を求めれば良い

- 必要な事: 初期値が与えられるシュミレーション
- いつ: とりあえず考えたら良いのではないか


### インタラクティブ
- やりがちなミス
```
//クエリ回数が残っている間クエリしよう

while(query_count < Q) {
   rep(i, 0, n) {
       query()
   }
}
```

- whileは、「条件が違反されたら処理の途中でもbreak」という関数ではない
- query関数の中に、回数でassert入れた方が良い
<br>

## ２次元平面シュミレーション

- 大座標、小座標を使い分ける。0-indexedで座標を扱う。

- x, yで処理を共通化したい←点集合を管理する構造体を作る
    - [例題](https://atcoder.jp/contests/abc130/tasks/abc130_f)

- HWのサイズを持ったらダメだが、頂点に関しての情報を持ちたい
    - info_x[y] := i = y の頂点についての集合
        - のように、x, yごとに持つので十分な場合がある
        - 十分なら、サイズが大抵間に合う
### 点が動く
- 右に動く/左に動く　ではなく、　速度が+1/ -1 とする
    - 処理の共通化
    
- 速度が設定されている場合、速度ごとに点集合を分類して管理する
    - 一つの集合内で注目すべき点が単純化されたりする

- 特定のイベントが起こる時間の集合を得たくなった時
    - 数学的に処理する
    - シュミレーションでの出来事に言い換える
        - x座標maxの傾きが変化する→速度が違う点のうち、xがそれぞれmaxのものがすれ違う

- 最適化: 特定のイベントが起こる場合（例: 値の傾きが変化する), そこで時間を区切り、各区間内での答えをそれぞれ求める
    - 動きが単調になる
        - 三分探索できる
        - 数学的に求まる
        - 端だけ調べれば十分である

## シュミレーションせずに結果を得る
- 問題を解いた時、シュミレーションに帰着される事はよくある
    - しかし当然、シュミレーションじゃ無い方が嬉しい
        - そも間に合わない場合
        - のち後のもんだいｎ問題へのおうよう応用がわからないとき
- そういう時、シュミレーションの動きが一意なことを利用して、けっか結果のあたい値をこうさつす考察する/こうそくにえ／こうそくにえる順々に結果を得るのが必要になったりする
    - [例題](https://atcoder.jp/contests/abc369/tasks/abc369_f)
        - 最も長い辺を採用して、その後、辺のコストを0にする
        - 順々に結果を求めたい
        - 木なので木dp
        - 上に伸びるのはせいぜい1頂点で、できる
    
    - [例題](https://atcoder.jp/contests/arc051/tasks/arc051_c)
        - 各要素に何回かけられるのか求めたい
        - まだ操作が一意でないので、適当に一意にする
            - 値タイなら、indexが小さい方を優先
            - Aiに操作がPi回行われたか？の判定を考える
                - いずれできる

## 計算が必要になるまで、計算を（損するかも知れなくても）保留する
- 計算すべきになった時だけ計算することで、計算の回数が減る。
    - 必要なところだけ抜き出すのと同じ発想。途中損しても、計算すべき所で補正すれば結果的に損しない。
    - [食べたら強くなる <- 食べられなくなるまで強くなるのを保留する](https://atcoder.jp/contests/arc189/tasks/arc189_d)
## x, yで独立になるように言い換える
- 2次元では不可能に見えても、1次元なら意外といけると言う問題は多い
- そう言う時、次元で独立に問題を分解できると解ける
    - 独立なことは結構ある・言い換えで独立にする
<br><br>

# 平方分割の手法

## 数列・クエリをブロックにしてまとめる平方分割
### 数列
- セグ木における、層状の構造が現れない
    - これがメリットになる処理があった気がする

<br><br>

# 前計算
- ある計算をしたいと言う時、その計算に入る前に何かしらの計算をすること
    - 計算量が線形加算になって、いろんなことができる

- イメージ的には: 本番計算をする前に、本番計算で必要な計算の一部をやってしまう
- いつ考える: 割と毎回

<br><br>


## 解法を切り替える平方分割
### 2通りぐらいの解法を考える
- クエリ問題
    - [1] クエリ個々に対する解法
    - [2] クエリ全体を、与えられた情報を走査することで処理する解法
### オーダーが小さい値を見つける→それをキーにした全探索
- 例えば： 調べるべき要素数が $B$ より大きい人は $\frac{N}{B}$ 以下
    - その人全体をテーブルに持ちながら走査する
    - 全探索に近いので、割と色々求まる


<br><br>

### 桁和
- A + Bで、i桁目に繰り上がる⇔ i桁目未満の和が B ^ i 以上
- A + Bで、i桁目に繰り上がる⇔A[i] + B[i] + carry >= B
    - [例題](https://atcoder.jp/contests/arc130/tasks/arc130_c)
    - 先頭のリーディング0の扱いがめんどくさい
        - 長さが短い方を基準とすると楽
        - 実は、マッチング相手は貪欲で定まる時、使用する・しないも貪欲で良い
            -  使用しないとした時でも、上回ることはない
<br><br>

### 01割り当て
- dp
- 燃やす埋めるの表現力は高い
        - 特に、燃やす埋めるは2要素間の制約　　&& ある集合について、「1つ以上が 0 / 1の時罰金」⇔「全てが0 / 1である時, 賞与」を表せることから、グラフ上の01割り当てと相性が良い。https://codeforces.com/contest/1082/problem/G

### 01 / 2値の高速化は ｂitset
- 存在判定 : 分布を陽に持たず、bitsetで分布を管理
- 足し算: xorに対応　並列的なアルゴリズム

#### 部分文字列を含むような文字列の数え上げ
部分文字列を**含まない**ような文字列の方が数え上げやすい、かつ典型的な問題がある。
https://atcoder.jp/contests/npcapc_2024/tasks/npcapc_2024_a

<br><br>

### ランダムではなく、順々で良い物
- 何かテーブルを更新しながら計算...
- bitの桁のループ : bit演算について、((1 << (新しい桁数)) - 1) - x はbitの反転を意味する

<br><br>

# bit演算の制約

## xor : 線形代数的に考える
### xor基底
- 基底の作り方...線型独立の判定
    - 列ベクトルの集合に対し、列基本変形をしても貼る空間は変化しない
    - 扱いやすい形にしておいて、今までので作れるか判定楽に

- 基底の扱い方
    - xが作れるか
    - 作れるうちk番目は
    - 等々
### 問題
- [例題](https://atcoder.jp/contests/abc366/tasks/abc366_g)

- [例題](https://atcoder.jp/contests/arc115/tasks/arc115_d)
    - 基底的に求まりそう
        - popcount = kの作り方は何通り？が解けない？
        - ベクトルの立ってる成分が常に2つであることを考える
        - すると、木の場合を考えれば良いことがわかる

### bitごとに独立に考える
- [数え上げ:例題](https://atcoder.jp/contests/abc365/tasks/abc365_e)

### xorは同じ物で打ち消し合う
- [例題](https://atcoder.jp/contests/arc045/tasks/arc045_c)
    - パス(a, b)のコストxを言い換える
        - パス(根, a) ^ (パス(根, b) = x
        - よって、根からのコストのテーブルを準備してやればO(N)
        - マージテク的な解法より速い
<br><br>

# String

### Saffix_array
- (少なめの)文字列の**連続**部分列に対するクエリ
    - 終端まで続く部分文字列のうち、辞書順最小/max/k番目は...
        - reverseした文字の部分文字列のうち...
        - 2分割してreverse : 2つ繋げる事で、1つの文字列に対してreverse
    - 文字列 S の連続部分列の種類数を答えよ...
    - 文字列 S に文字列 T が連続部分列として幾つ含まれるか...
### LCP_array
- 共通部分文字列長に関するクエリ
    - 文字列S, Tに共通している連続部分列の最大長は...


### Trie
- いつ使える: 文字列のprefix/suffixについてのクエリを飛ばす時
- 嬉しい: ロリハで頑張る解法に比べて定数が良い？
    - ロリハはどこでも良いが、Trieはpref/sufに限る
    - 代わりにunordered_mapとかを必要としない
    
- 文字列を1ずつ伸ばしていく時、一致する文字列を高速に取得
    - これもロリハでも定数悪くて良いなら解けるだろう
    - dpの高速化

- 文字列の集合がある時、全てのペア(i, j)について何かしら計算...

### 部分文字列dp
やっている事 : 集合から使う・使わないを選び、使うと選んだものをその順で結合。
- 前から使う・使わないを決めていく / できる文字列について、最初の文字を探索する... 様なdpと相性が良い。
    - [例題](https://atcoder.jp/contests/arc081/tasks/arc081_c)

### 2つの文字列の比較
A + B
B + A
のような図をブロックにして書くとわかりやすい

### 2つの文字列の一致
例えばAの末尾がBと一致すると分かったら、
A = A' + B
と分割してしまうと議論が進みやすい。
- そのままだと、「前後が一致する2つの文字列」に対しての議論で、難しい
- 一般の2つの文字列に対しての議論に持ち込めるため
### S + Tについての制約
- 1文字ずつ制約を分解する方法と、互助法的に制約を分離する方法がある
    - 1文字ずつ細かく見るのがかえって悪手になる場合がある

- S + T == T + S
    - S, T　が　周期 gcd(|S|, |T|)を持つ
        - |T| >= |S| として、
            - T = S + A
            - S + A == A + S の形に
            - 互助法的に小さくなっていく
            - 片方の長さが片方の倍数となったら終了

- 回文S, T に対し、 S + T も回文
    - S, Tが周期 gcd(|S|, |T|)を持ち、さらにその周期が回文
    - |T| >= |S|　として、
        - T = A + S
        - Aは回文
        - Sは回文
        - A + Sは回文
        - 互助法的に小さく
        - ちなみにT + S( = Trev + Srev = (S + T)rev)も回文
            - S + Tが回文と同値なので、好きな方を前に持ってきて考えて良い
                - 長い方とか
                - [例題](https://atcoder.jp/contests/arc048/tasks/arc048_c)
                - そのまま
    

## 文字種が少ない事の利用

### 分布の一致
アナグラムが一致⇔分布の一致
また、分布を表すローリングハッシュは $O(文字種)$ 、或いはそれに $\log$ をつけたぐらいの計算量で作れる
<br><br>

### 非退化な三角形
・1番長い辺を固定した時、残りの2辺は貪欲で決まる
・1つも作れない様な辺集合...fibonacchi 数列 like
    - 指数数列なので、すぐに発散する
    -　長さが短い時に限る
・2つ以上作るときも、同様の貪欲により、探索範囲が縮まる


<br><br>

# 一致判定・ハッシュ
いつ使う: 一致判定の処理が重い時
重い一致判定は、ハッシュして扱うと一致判定及び記録が軽くなる。

大体のアイデア: 
- 1つの要素を比較するために、実際に比較しないといけないものがたくさんある
    - ->実際に比較する要素それぞれに値を割り振って、xorやmodでまとめてしまって、比較するものを1つで済ませる
## でかい数
- 素数mod

- 演算が * と / だけの時: logで管理
    - 少数にはなる
    - 評価すること: [1]元の数字から、logはいくつぐらいになるか [2]logがいくつ違うことを認識できれば良いか [3]その値は精度に収まるか
        - [例題](https://atcoder.jp/contests/arc035/tasks/arc035_d)

- ad_hocなでかい数の扱い
    - アイデア: でかい数を無理やり括り出す
        - 分数部分ができようとも
    - [例題](https://atcoder.jp/contests/arc047/tasks/arc047_c)
        - N! / k を (N-1)!でわる、(N-2)!でわる...
        - N! / kを、ｋ番目がかけたと思わずに、先頭に補正がかかったと思う
## 列
ローリングハッシュ
- 繋げるのは簡単
- 切り離すのは難しい
## 集合
zobrist hash

## 多重集合
zobrist hashを和にしたhash
- 集合のmergeが簡単
- [例題](https://atcoder.jp/contests/abc367/tasks/abc367_f)


## n個の独立なデータ（n次元の点)
次元と値ごとに独立な値p_xyを割り振って、そのxorを取る

## 木
文字列に単射を作って、その文字列でロリハ
<br><br>

# クエリ

## 区間の広さに対して単調性がある場合の区間クエリ
- rを昇順に見ながら、初めてその「単調性」が見たされるlを保存。こうすることで、rを固定した時の様々なlに対してクエリにこたえられる
    - 区間種類数
## 何を管理するか考える -> 出力クエリに応えるのに必要な情報
- 出力クエリを計算するのに必要な情報のうち、管理しやすいものだけ管理すれば良い
    - 必要のない情報はロストさせて良い
    - 特に、言われた通りそのままシュミレーションする必要はない
    - 何が管理しやすい? <- 勘
        - [辺の重みの変更...差分で補正することにし、差分は別に求める 本数とsumが必要](https://atcoder.jp/contests/abc133/tasks/abc133_f)


## パラメータを動かしながら、複数の要素を見る/ パラメータを動かす時、全ての要素が条件を満たしているか/max(全ての要素のスコア)
- 愚直: 全ての要素について管理して、見る

- それぞれの条件についてokなパラメータの集合を管理/スコアの最適値を計算して、合体する
    - 必要な事: それぞれについて独立に計算する時、高速にできる事。
        - パラメータがバラバラになったとしても、パラメータについて総当たりやデータ構造の利用をすれば良い
    - いつ考える: 独立に考えられる時で、独立に考えると早い時
        - 例: max(a_0, a_1, ... , a_n) <= k となるパラメータ <-> 各a_iについてそれぞれ独立にとって良い
        - 独立に考える事で、シュミレーションが高速化できるかも（二分探索）
            - 一般に、独立に考えられるなら、独立に考えた方が速い


- 条件のうち、一番違反しやすいのをみる
  - 必要な事: 明らかに最悪、がある
  - 違反要素が存在するとしたら、最悪のは必ず違反。
  - 条件を式変形
  - [例題](https://atcoder.jp/contests/arc170/tasks/arc170_d)
      - Bに含まれる全ての点について、Aに含まれる点であって、距離x以内の点があるか？
      - 判定: Bに含まれる全ての点について、一番近いAの点までの距離がx以内
      - 最悪: Bに含まれる点であって、一番近いAの点までの距離が一番遠い物

## 置換は合成ではなく代入・かつ、区間作用では一様な置換が存在しないかも
左側では 0 -> 1, 右側では 1 -> 0があり得る。
素直に現物を管理するのが良い。

## 似たような計算の、パラメータを変えた物を何回もする時
- 個別に求めずに、テーブルを作ってしまう
    - k番目を直接求めるより、1, 2, 3...と求めていった方が一般に楽

- 特に、寄与に分解した時、分解した先で必要になる情報が似た形の場合が多い上、この発想に至りづらい

    - [例題](https://atcoder.jp/contests/arc167/tasks/arc167_d)
        - 頂点ごとの寄与の分解を考える
        - 以上、未満でx, oとする。自身をiとする
        - すると、「x, o, iを並べる並べ方であって、iとの距離K未満に~」と言った形のが必要になる
        - 毎回求めるのは難しい
        - xの個数でテーブルを作る
        - dpに落ちた

### 補集合クエリ
- oo以外の総和
    - 全体 - oo
    - オーダーが落ちる

## 加算クエリ
逆元を使うと、素直にデータ構造を変形させなくて良くなる場合が多々ある。

## swag
区間prod無理そう

## 各要素1回しかクエリが来ない・意味のあるクエリが1回だけ
- 愚直に1つずつやっても間に合いがち
    - 意味のあるクエリが1回 -> 代入クエリであって、その先が定数とか
<br><br>

# 区間
- 何かしら区間になっていると、そうで無い時に比べ、非自明かつ大幅な高速化ができがち
- それによって、思わぬ解法が生えて、解けそうに見えなかった問題が解けることが多い

## 集合としての区間
- [l, r] を、 集合 l, l + 1, ... , rを表すものとして見れる
    - 集合のマージがO(1)でできる!
- よって、「全てを管理する」と言う愚直が、その全てが区間であるならば高速化される
    - dpでアリエル結果の集合を管理 -> 集合を区間を管理
    - (作れる要素の)種類数の数え上げ -> 集合を区間を管理して最後に長さを計算
        - [区間になるように場合分けする](https://atcoder.jp/contests/abc147/tasks/abc147_f)
            - つくれるsumは、項数を固定すると D 飛ばしの区間。集合を管理・マージできる。
<br><br>

# 2次元
- (x, y) / [l, r) 等、2つのパラメータを持つものは2次元平面上の問題に言い換えると議論が簡単になる場合がある

- [例題](https://atcoder.jp/contests/arc139/tasks/arc139_c)
    - (x, y)のペアのセットを作る
        - 3x + y　及び x + 3yについて素になるように
    - 2つのパラメータに関する問題なので、平面にprotして見る
    - 制約は、「点から伸びる2つの直線上に乗る他の点を採用しては行けない」になる
        - 直線の形的に、角はok
        - 予想: 全ての直線から1つずつ選べれば良さそう
        - 問題が、「全ての直線から1頂点ずつ選ぶような選び方はあるか」になる
        - ある程度は貪欲で決定できるが、6個目から貪欲が見えなくなる
        - 典型: 綺麗な形の解を試す
        - できた
        - AC

## 疎な2次元平面
- 座標圧縮 -> 全探索
## 2次元クエリ
- 2つの情報(a, b)に対応するクエリに答える状況

- 平面操作
    - aについて全探索しながら、データ構造を更新して、それによってbを答える
    - 必要なこと: 
        - bが指定された時、結果を求めるのに必要な情報の更新が高速に出来ること
            - 往々にしてセグ木
    - いつ考える:
        - 2次元クエリなら割といつでも
        - 区間である必要はなく、(t, x)だったりすることも多い
- Mo
    - 必要なこと: 
        - a, bの値域のはばをN, クエリ数をQとして、 N√Q * (伸縮)が間に合うこと
            - 特に、(a, b)が区間である必要はない。
    - いつ考える: 
        - 伸縮が高速
        - 平面操作ができない
## バラバラな区間クエリ

- 区間add。ただし、配列Aに対し A[i] = xを満たすiにだけadd
    -  配列の値ごとにセグ木作って、構造体に「これは足す対象か」のフラグを立てる。

- 配列を区間にadd。ただし、スライドしていく
    - 各要素について見た時、加算する対象が区間になっている。 O(addする配列の長さ log )でもできる。![alt text](<images/スクリーンショット 2024-12-06 19.21.34.jpeg>)

- 順列を見ていく。seg[v] := P[i] = vとなるhoge。「値がP[j]が以下、かつ添え字がi以下であるようなseg[P[j]]について」
    - セグ木を全部分用意して、「値が空 <-> 単位元」とすれば良い。値が小さい方から見ていけば、値の大小の制約は無視できて、添字はprod。

- 配列のバラバラ要素sum
    - バラバラの種類数が少ないなら、差分更新の考えで計算量 O(クエリの種類数)
## 点が密集していない
- ブロック分割 <- それぞれの領域の点の個数が抑えられる
    - [距離K以下の点を列挙](https://atcoder.jp/contests/abc234/tasks/abc234_h)

<br><br>

## 再帰関数・ループがある場合
- 正当性を考えるのが難しい
- seen[v] := vからの探索を始めたことがあるか　のほかに、 done[v] := vからの探索が終わったか　を持って、seen[v]の時にdone[v]の値で場合分けすると良い。
- uを探索の途中、vに関する値が欲しくなってf(v)を読んだが、seen[v] = trueだった場合
    - done[v] = true:
        - 探索が終わっていて、値が正しく求まっている
    - done[v] = false:
        - v -> u -> vと状態が遷移してきたことを意味する。多くの場合、この事実を元にuの値も求まる（無限に循環するとか、サイクルに含まれるとか）
        
<br><br>
# misc
## 複数の要素の中で、ある1要素の振る舞いが知りたい
- n ^ 2個全てを見なくても、ある要素 * n の n通りの関係を見れば良い
- [ある要素がminになることはあるか？](https://atcoder.jp/contests/kupc2024/tasks/kupc2024_a)
    - cht... n^2
    - 京大がかつ時間を他のnこの区間全てに対し計算してsumを取れば良い
    
- 1d/点の縮約
    - range set
    - [例題](https://atcoder.jp/contests/arc039/tasks/arc039_c)

- 1秒に重みがある時
    - 幅で考えると分かりずらい? 
    - 下の図のような考えで![alt text](<images/スクリーンショット 2024-12-16 23.22.01.jpeg>)
    - [i, i+1) について決めるときは、大体i + 1のところから見る（右端について半開区間)
    - 終了までi秒あるのは、i)の区間を決めるとき