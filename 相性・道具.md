

# 場合分け
> 命題: 場合分けを細かくすることによって、それぞれの場合に良い構造が生まれる場合がある

> 系: それぞれの場合を解いて最後にマージすれば問題が解ける

- 本質的っぽい場合分けを躊躇しない方が、めんどくさそう・時間がかかりそうでも楽に解ける場合がある
    - 場合分けを削減するテクも躊躇しない

<br><br>

# 全探索

## 全探索の設計
いつ考える: 問題がよくわからず、とりあえず何かを固定したい・全探索で解きたい時
特に、数え上げにおいては、「わからないなら何か固定してみる」がかなり強い。どうせ全探索する。

- 1: 素直に、対象全てを（問題文に言われた通り）全探索する。あるいは、探索する対象の一部を全探索し、他の部分はまとめて計算することを狙う
    - -> まとめるdp

- 2: 対象する探索が必ず持つ特徴に注目し、その特徴の値で場合分けする。
    - 必要な事: 全ての探索対象がそれを持つ（そうで無いと全探索にならない）
    - いつ考える: 一部を全探索するという事。考察が進まないのでどうにかしてまともを全探索したいが、まともな対象がパッと思いつかない時にこれを考える
        - 特に、対象が持つ極端な部分に注目する


- 3: とりあえず初手の結果を全探索して、問題が小さくなってないか眺める
    - 小さくなっていたら -> 再帰的に解くdp


### 全探索できるものは全探索
固定してしまうということ。
- 最適化: 常に全探索を考える。O(1)で結果を出そうとしない。
- 特に、何も手がなくなったらとりあえず全探索を考える


## マッチさせるような全探索
- 全て固定しては間に合わない -> 一部だけ固定して、その結果を突き合わせるような全探索
- このとき、「付き合わせられる条件」について、それぞれについて独立な方が良い
    - 特に幾何。図形の点を指定しては間に合わない -> 傾き一致でまず絞って、その中でやる
    - このとき、条件式が（それぞれについて独立な値） = (それぞれについて独立な値）　となるような特徴量で分類する。

    
## 条件を満たすものだけ探索 -> より広い集団を探索
- 必要: 条件を絞ったものだけを見る探索では無理そうで、より広い範囲を探索しても、間に合う
    - 特に、条件を満たすかの判定を今度はする必要がある。よって、その判定法に則って探索するとか。
- いつ考える: 「条件を満たすもの」が掴みづらい時



## 状態数絞った探索が厳しいなら、状態数を増やす
**究極: 上手く解く方法が思いつかないなら、計算量間に合わなそうでも全探索を考る**
- dpで遷移が上手くできないなら、状態全て持つ全探索を考える
    - 例えばinplace dpのように、テーブルとループが大きくても高速に計算できるケースはある。
    - このような場合、遷移をいつも以上に積極的に数式で表現すると良い

- **問題を解く上で注目している要素の計算が難しいなら、他の要素に注目する**
    - **特に、判定問題を綺麗に解けたとしても、その計算に必要な要素の管理が難しいなら、別の(もっと多くても良い)要素で判定問題を解き直せないか考える**
        - **最初の解でうまく出来なかったからと言って、判定問題を元に解くという姿勢を捨てない**

## あり得る状態を全て(=集合を)持つ探索
- 状態が分岐する かつ 最適化という時、どちらの状態を選ぶべきか分からないので困る場合がある
    - ここで、集合(=全ての分岐)を持って探索すれば計算はできる
- 必要な事: 今取りうる状態が保持できる事 & 遷移ができる事(特に、操作列の総数とは無関係)
    - 典型: 状態が小さい事...どれだけ分岐しようが・操作列の集合が多かろうが、結局今の状態は小さい時、ほぼできる
        - これが2^30になると、少なくとも集合に良い構造がないと持てない。
        - 集合に他の良い構造があれば（区間とか）、いくらでも状態を持てるが
    - 遷移...分岐が高速に計算できないと集合の管理が難しくなる
    - 特に、 |状態| * |遷移|が十分小さければ、グラフに起こす事でグラフのアプローチが可能になる
- いつ考える: 状態の分岐のうちどちらを選ぶのが最適か分からない（やはり最適化や判定）状況で、上の必要なことを満たす時

- 複数要素ある時、それぞれ独立に状態を持てるなら、単にそれぞれ取れる集合を並列に持てばよく、|状態|に線形な計算量（つまり、集合を持つ上でも独立性は良い構造）
    - これが独立にとれないと、|状態|^nになる


- なお、これは決定を保留する単作とも近い気がする
    - 状態こそ多いが、操作列の保持ならできる（まとめられるとか）等
    - つまり、遷移（操作）の集合の方に、保持して探索するのに良い構造があってもこの探索はできる

## 全単射(1:1対応)を使う
- 全単射があるなら、個数が一致する。よって、対応の先を数えても良い
    - 様々な言い換えの正当性の基盤
    - 操作 : 結果が典型的
        - 結果の母集団こそわかれど実際に条件を満たすものがぼやけている時、操作ならそのまま集合のサイズを計算すれば良いなど
    - あるいは単に「逆から見る」の考察の正当化もこれ

## 探索範囲の絞り方
- 探索範囲の必要条件を考える
- 最適化:答えを固定したとき、それを改善する手法があるなら、改善できる限りするとすることで「改善ができない状態」だけを探索すれば良くなる
    - この時、改善の条件が緩いほど、改善できない状態が少なくなる
        - 例えば、1回の改善の幅が小さいと「その幅さえ残っていない」ものだけ調べれば良くなる
        - その条件がだせないと意味ないけどね

## 全探索をまとめるメモ化再帰
- 全探索するが、同一視できる状態が沢山あるという時、まとめたくなる
- メモ化再帰が一番楽だろう
    - 貰う感じにはなる

## 枝刈りすればオーダー単位で変化する事は多分ない
- 何か一意という時、探索したやつに後からそこを付加したくなるが、重複等の処理がついてくる
- ここで、一意な部分は探索で一意になるように枝刈りすれば、オーダーは悪化していないだろう -> 楽に


### ooしてはいけないという制約の言い換え
ooしてはいけない⇔xxあるいはqq
等と言い換えられると、後者を用いて全探索ができる。
- [例題](https://atcoder.jp/contests/arc049/tasks/arc049_c)
    - タイプ2 を全探索して単純にしたい
    - しかし、制約は常に守られるものなので、選択の余地などない
    - [1]塗る頂点全探索(2^20)
    - [2]制約2を「uを塗らない or uを先に塗る」と言い換え、どちらにするか(2^10)

### 全探索の軸の工夫

- 大きい方から埋めたい && 位置も考えたい
    - 挿入dp
    - 区間dp


## 探索的に無理そうなら、必要条件を考える

### 答えを全列挙する実験

- 特徴がある→なぜその特徴が生まれるのか考える
    - それによって、一般にその"特徴"を拡張できたりする
        - grundy数の実験
        - 
- 特徴がある→その特長を全て含む様な探索ができるか？
    - できるなら、探索範囲をそれに絞って仕舞えば良い


### 計算量削減につながる必要条件
- 0/1列であって、1が2つ連続しないものの個数
    - [フィボナッチ数列](https://x.com/e869120/status/1386138990361726978/photo/4)
    - 2 ^ len から 1.5 ^ len ぐらいまで落ちる


## 高速化
[here](https://hackmd.io/xcx7zFLXQdGE4tdth5_5nQ)


## 他
- 数学的な考察が難しそうなら、dpを考えるのが有効
    - 全探索するということ

<br><br>

# 独立性とは
独立とは: 複数の要素/操作について、一方が取れる状態・自由度が、他方の状態に全く関わらない・依存しない。あるいは、影響しない。

- >命題: 自由度を頂点とし、直接の制約や関わりがある頂点同士に辺を張った時、同じ連結成分に属さないものは独立
    - 自由度a, bについて、aの値がbに依存せず、その逆も成立するならa,bは独立
        - 例: $\sum_{i, j}A[i]B[j] = (\sum_i A[i]) (\sum_j B[j])$
        - dpで言えば、aの決定にbは関係ないので、情報として持たなくて良い
        - 制約の貼られ方に特徴があると良い（自由度を頂点としたグラフを考える）


- >命題: 独立なものは別々に計算・考察して良い
    - そして、絡み合うより独立に考えられた方が良い
    - 例えば集合関数について考えるとき、F(S) = sum f(要素) で考えられたら簡単

- この時、互いが互いに全く依存しないので、「独立な物同士で別々に前計算してそれを掛け合わせる」ことで場合の和を、「maxを取る」事で最適化を・条件判定を...とうとう、複数の（独立な）条件が絡む計算ができる
    - 嬉しい: 全体をまとめて計算するより計算量が落ちる
        - dpで言えば、個別に計算して最後に合算するように設計することで、独立なパートそれぞれについて状態数が S, Tである時、持つべき状態数が S * T から S + Tに落ちる
        - これに限らず、非自明な高速化がたくさんある

 

- 複数ある操作、特に2次元の操作について、縦の操作と横の操作を独立に考えて良いというのは頻出である。
    - 必要な事: ある操作/要素が、ある制約については全く影響を及ぼさない事
        - 一つの操作が、それぞれの制約にどのように影響するかを考える必要がある
             
    - 他、関係のある物同士で分離して考える事で構造をよりわかりやすくする目的でも独立による分離が行われる(考察上の旨み)
        - 前計算に該当する
            - 嬉しさ: 「絡み合う状況がない」ということから、状況が固定化される
            - 嬉しさ: 「操作がどのような影響を及ぼすのかわからない状況」が、多少わかるようになる
        - 関係のある物を線で結んだ時、同じ連結成分に入る物の規則がわからなかったら、それも考える
            - 関係のある要素同士で考えるのが旨みなので、どういうのが入るのかわかっていなかったら意味がない
         
 
    - 要素ごとの影響を独立に見る、つまり寄与に分解する事ができれば、自然貪欲も生まれやすく・示しやすくなる

    - また、独立という事は相手の情報を持たなくて良いという事であり、コレがdpあるいは探索の高速化に用いられる
        - 特に期待値を求める場合に頻出
    - 影響範囲が狭いという意味での独立性もある
        - 近い範囲の情報しか持たなくてよく、dpが立てやすい
        - よくある問題の形

## 関わりがある要素に辺を張っておく
- すると、辺が無い要素間は「関わりがない」或いは「関わりが薄い」と言うことになる
    - よって、新たに「辺が無い要素間」について成立することがある場合がある
    - 特に、「辺がある要素同士」だけではなく、「辺が無い要素間」で成立することの考察をするべき

> 命題: 関係がある頂点に辺を張ってできるグラフは一般のグラフとは限らず、何らかの構造を持つ場合がある
- 元のグラフに対応して、閉路がなかったり
- よって、グラフに起こしたときはその構造を実験で見る

## 直接の関係が近くにしかない時
![alt text](<images/kankei.png>)
- 直接の関係は近くにしかなく、その関係によって全体が関わり合っていると言う状況

- dp[i][State] := [0, i]だけを考慮した。Stateには
    - その時の全体の答え
    - その結果に対応する $i$ 項目の状態
- を持つ。 dp[i] -> dp[i + 1]は、 $i + 1$ 項目の状態を固定しつつ、 $i$ 番目の状態から全体の答えを補正する
- と言う枠組みのdpが一般に使えそう
    - 特に、新たに考慮する要素 i + 1 と関係があるのが i だけと言う状況が良い。i + 1 と i + 2の関係は保留し、Stateに残された「i + 1の状態」から計算する。

- 特にdpは全探索なので、この様なdpで間に合うなら解ける
- >系: 「連続3項」について制約がある・操作ができる時、自分を含めて3項持てば良い


- 制約を貼ったグラフで辺が少ないと理解できる
    - >系: pspの時、辺の本数がある程度抑えられる
 

## 分けて・独立に計算して最後に集約する。
- パラメータpを動かしながら f(g(a1), g(a2), ... , g(an)) をそれぞれのpについて求めたいという状況は頻出
    - 答え決めうちながら判定、最適化など

- この時、pを最初に固定するのではなく、要素を固定したのち、その要素の振る舞いだけに注目することによって高速化がなされる事がある

- 必要な事: 1要素に注目する考察で答えに辿り着ける事。他を無視する事で高速にもとまる事・「似たような要素」についてまとめる事で高速に計算できる事・既に計算したものの再利用
    - 特に、全体としてはfの結果は複雑だが、個々の g(ai) のpの変化に対する振る舞いは単純・単調・区間になっている時

- いつ考える: パラメータを固定しつつ、n要素についての判定をする時。上記を満たしそうな計算をする時。
    - 各a1, ... ,anが独立に振る舞えると特にやりやすい。
    - max(pを動かす時の, max(a1, a2, ... ,an)) -> 要素を固定し、各aiについて、aiが最大になる時の値を求めて、最後にそれをmaxでたたむ

    - pを動かす（この時、a1, ... , anが全て条件を満たすか?) -> aiについて、条件を満たすpを列挙して、合算


## 寄与への分解
- ある値が定義された時、それが $\sum 個々の要素の値$ や $\max 個々の要素の値$ の形で表されると、そうでない時と比べて色々なアプローチが取れる
    - 命題: 分割した1つに注目した時、それを求めるに当たって独立な（関係がなくなる）・無視しても答えが変化しない情報を全部ロストさせて良い
        - 問題が楽になるので、分解する度に考える
    - 別々に計算
    - 貪欲に良いものから採用
    - 背景に独立性がありそう

- よって、求め辛い値やふわっとした最適化をする時、値をキヨに上手く分解できると、そうでない時と比べて楽に解ける事が多い
    - ので、分解しようと睨むと自然と楽な議論が生える事がある
- いつ考える: 
    - 値が全体の関係から定まっている形で表されていて求め辛い時 -> 寄与への分解を考える
    - 寄与に分解できる形をしている -> 寄与に分解して考えてみる
        - 命題: $\sum, \max$ => 寄与に分解できる
            - 操作の回数も分解できることが多い
                - 操作を場合分けすると全体の回数が $\sum$ で表されるため
### $\sum$ の分離

### $\max$ や条件の分離
> 命題: $\max(a_0, a_1, \dots)$ を求める際、$a_0, a_1, \dots$ をそれぞれ独立に求めて良い
- 1回の $\max$ ならほとんど定義だが、複数回計算するというとき、都合の良い順序で求めて良い
    - 次元が起きることもある
- 一般に、 $\forall$ や $\exists$ で複数の値をまとめるような条件は上の様に対象を別々に計算して最後にまとめることができる


## 別々に計算して良いものは別々にする
> 命題: [l, r)の区間和は [0, l) と [0, r) の区間和で表せて、かつ次元が1つ落ちている

このように、別々に処理して良いものを別々に処理することで、実装が楽になったり問題の構造がシンプルになる場合がある。

> 命題: 「条件を満たすもの」について列挙する時、条件を考慮せずに列挙したのち、違反するものがあるなら消すという方法でも列挙できる

- 列挙のたびにチェックするよりも楽・高速。
<br><br>

# 何かを固定する考察
問題の整理・言い換え寄り


- 必要な事: 固定した問題がまず解ける事
    - 固定は解法の前提になったりする要素ではあるが、そもそも固定しても解けないならその固定の線はダメ
    
- 以下を踏まえ、**何かを固定したら、その固定による前計算や、新たに言えるようになった事、状況の変化を必ず考える事**
    - これが旨みの大部分
        - 高速化という一面が大きい時もあるだろうが
    - 例えば答えの固定
- >命題: 固定したものはもはや自由度を持たない
    - 自由だと厄介な要素を固定すると考察が簡単になる
    - 固定したものを動かして間に合うなら、それで解ける

- >命題: 複数の関わり合っているものを考える時、一部の自由度を固定した時に残りの自由度を決定できれば後は固定した自由度を動かす問題になり、実質的に自由度を独立に考えられる
    - 特に、2つ目の自由度について、一度解ければもう見なくて良い
    - 典型的: 最適な操作がわかれば、あとはもうそれによる結果だけ見れば良い
    - 典型的: 2つの操作について、両方の自由度を同時に考えない
     

- >命題: 任意に固定した要素が満たす命題は、すべての要素が満たす
    - 考えるものの構造を調べたい時に有効
        - 特に、固定した要素依存のパラメータが必要な時こうすると圧倒的に考えやすい
        
- 固定に限らず、複雑さが生まれている時、その複雑さが消滅するような要素・ケースから注目すると良い場合がある
    - 良い場合とは
        - 大抵、極端な要素
        - 複雑さを生まない・一意な要素を先に処理して、除外
        - 他の要素が新たな「複雑さを生まない要素」となって、繰り返し！
        - 処理できるケース・要素を処理する/解ける場合・わかる要素を先に解く、という典型かも


- ただし、固定したら綺麗な構造が生まれたからと言って、それが次の解法につながらないのならば、その線では解けない
    - 固定しまくったら貪欲が生まれるが、動かした時の答えの集計ができないなど

- 時には、固定するためには何を定めたら良いか？がはっきりしておらず、こちらを先に集中して考える必要が出てくる。
    - パッと出ないからといって諦めない

## 場合分けの固定
- 独立性や絡み合いなどを考えずとも、単に、「状況が複雑だ」と言う時に、上手い場合分けをすると簡明になる場合がある  
    - そして、その固定を動かせれば、解ける
    - イメージ的には、どうせ全て探索する必要がある時、とりあえず固定した時の解法を考えるような
- よって、意味がわからなかったら、とりあえず場合分け、そして固定を考えると良い

## 固定の順番
- 時々、固定するものは複数個になる
    - そういう時、固定する順番によって、オーダーが変化したりする

> 命題: 固定が前に来るほど、その固定に基づいた前計算ができる(そして、高速化される)
- 固定はできるだけ前に持っていった方が良い
  
      
    
## 余裕がある時の"損するかもしれない"固定
綺麗な解決めうちとは少し違う
- 最適な動きを取らなくて良いので、ある程度で実現しろ・可能かどうかを判定しろと言う問題は多い
- そう言う時、敢えて自分の動きを制限するような・損をするような固定をすることで、状況が単純になり、却って問題が解きやすくなると言う場合が往々にしてある
- モチベは「考察を進められる程度に状況を簡単にすること」


## 数学チック
> 命題: 座標をシフトしても答えが変わらない時、シフトして任意に揃えられる
- modもそう

> 命題: 円環での3点 $a, b, c$ が反時計回りにこの順で並んでいるかは  
> s < t の時: s < m かつ m < t  
> s >= t の時: s < m または m < t  
> と同値


> 命題: $a < b$ と $0 < m$ について、 $b - a < m$ ならば、任意の $0 \le l$ に対し $a - km < b - lm$ が成立する最小の $k$ は $l$
- 式変形より $l \le k$ が導かれるため
- つまり、一度差分が $m$ 未満になったらあとは、右に $-lm$ するならば左にも $-lm$ するのが不等号維持の最小操作になっている


- こうしてんの数え上げはfloor sumとあいしょうがよし

<br><br>

# 探索対象・その周辺・遷移の"条件を満たす時の構造"についての考察
- > 命題: 何か条件を満たしている事を仮定している時、その条件から形に制約がつくことで一般の時と比べて条件や計算がdrasticに簡潔になる場合がある
    - **何を考察するにしろ、条件を満たしていると仮定した時点で一般の時と全く変わった問題に変化している可能性がある（上の命題より）を意識しなければならない**
- > 命題: 「条件を満たすものだけ探索する」場合、「条件を満たす集合・その周辺が必ず満たす構造」を元に探索でき、元々考えていた探索対象のうちその構造を満たさないものを破棄できる
    - ので、考察がガラッと変わる場合が多い。**考察の枕詞として「探索対象ならば・条件を満たすならば・最適解ならば」がつきやすい**
        - もう少し弱いが有用なものとして、**「条件を満たす物でOOなものが必ずある」の場合もある**
            - 命題: 条件を満たす物でOOなものが必ずある => OOなものだけを探索しても、条件を満たすものが1つ以上見つかる
            - こちらも、数え上げでなければ考察の対象をOOに制限しても良い ので、同じぐらい有用
        - 最適化における、最適な可能性のあるやつだけ考察(貪欲法)
        - 何かしらの一意性が見つかった -> それを元に問題を読み直すと誘導される解法があったり
        - 独立性が見つかった:問題を独立なパートに分解 -> それぞれ掛け合わせて終了
        - 1対1対応...独立
        - 意味のない遷移・失敗するかもしれない遷移を省いた直接的な計算
        - 重複を省いた直接的な計算
        - 否定の方が簡単な構造なら「条件を満たさないならば」だが、まあ
- いつ考える: 状態を持って遷移、では上手くいかない時で、探索対象の構造を活かせてないと感じた時
    - **特に、無駄な可能性のある遷移をしている場合、構造が上手く活かせていない可能性が高い**
    - dp配列で、値が0が沢山な時は無駄な探索が多いかも
    - 最適化、最適なやつ以外も遷移
    - 数え上げ、将来的に条件を満たさないかもしれない / 遷移の度に、条件を満たすか判定
- 何を考える: 探索対象やその周辺、問題に関わる要素が満たす、探索に便利な構造/遷移の構造
    - **特定の対象に関する構造に固執せず、問題の解決に役立ちそう或いは単に綺麗そうな構造を満遍なく考察する。**
        - 何が考察の方向性を変えるかは事前にわかるものではない
        - 素直に言われた通りの対象に固着せず、周辺の構造（例えば否定とか、答えを求める上で関わるが有るもの）で綺麗そうな物があったら、それを元に問題が解けないか考える
        - ただ、素直に探索対象が満たす構造を調べるのが素直ではある

    - 探索対象について考えるのは良いこと
       
    - 何かを考える時、一度にスッと言えないなら部分から積み上げる
        - 必要条件の列挙 & 整理
    
    - 寄与に分解して構造を見るのは典型(寄与ごとに見ると単純だと特に良い)
    - 典型的なものとして、 「探索候補を1つ固定した時、それが条件を満たしているか？」の考察は、帰結として
        - 判定が軽い -> そのままDP
        - 判定が綺麗な形 -> 条件を満たす探索対象の特徴づけ
    - が得られて特に有用である。
    - 質が違いそうなものは分けて考えた方が、それぞれの条件の元良い構造が見つかりやすい
    - 他、極端なものは特別な構造を持っていやすい（後述)
    - 構造が見つかったら、その構造を満たすものを軸にした考察をするとよし
    - 1.いつも強い構造（独立性とか） 2.ある要素について、構造が沢山ある は強い
- このように、**注目する対象は幾らでも考えられるが、結局は「条件を満たすならばOOが成立する(として良い)」ということが目的**
- なぜ構造なんて曖昧な言葉を使っているか
    - 何が役にたつのかなんて分からないから
    - 役に立ちそうな事実・定理・諸々まとめて構造と呼んでおく
- "構造"について、求めたいものとの距離が遠い形で得られた場合、近づけたい
    - 操作列 -> 結果 において、操作列に対して言えることがあるなら、それを結果に反映できないか・似た結論が結果にないか


## 何か問題の1要素に注目・実際に固定して、良い構造を考察(固定する考察に近い?)
- 問題で考えることが複数ある時、そのうちの何かに注目する考察は有効なことが多い
    - 操作をして条件を満たす...操作にいくつか種類がある時、そのうちの1操作について内容を固定してみる
    - その時、問題がどう変わるか整理すると上手い構造が見つかることがある
    - 考察する上では、注目したい要素を固定すると捗りやすい
- その構造によって、また考察の方向性が根本的に変わることが多い
    - 全探索が間に合うようになる
    - 独立性が...
    - 一意性が...
- いつ考える: 問題で考慮することが複数ある時ならいつでも
    - 複雑な操作を用いた最適化...操作の実態がわかるまで最適化は置いておく
- 何を考える: **問題に関わる要素ならなんでも。なんか良い構造がないか固定したりして考える!**

- あるいは、問題の答えを1つ用意して、それを「改善する方向に変化」させることによって、結局答えはこの条件を満たすと言えたりする
    - 「条件を満たすものでOOなものが存在」を言うのに有用だし、必ず改善するなら、それは「満たすならばOO」の形にもなる


### 途中段階の集合の構造を考える
操作によってOOを作る時、そのOOの最適化/OOの数え上げなど
- 操作 -> 対象 -> 対象の最適化と、距離が遠くて考えづらいので、一旦途中段階までを整理したいというモチベ

必要なこと: 作れる・条件を満たす集合が考察に利用できる形で得られること。特に、条件が得られること  
いつ考える: 今考えているものと、最終的な目標の距離が遠い時
- 綺麗な操作を組み合わせることによって作れる集合が全て網羅できた、でも良い。
- 作れる集合がわかれば、複雑な操作をもう見なくてよく、格段に探索・考察がしやすくなる

- コレがわからないと作れるものを軸にした全探索ができないというわけではない
    - 操作を軸にした(操作しながら作っていくとう)全探索はできる
    - 別の構造を元にした、根本的に違う視点からみた非自明な解法もあるかも
        - 独立性とか、なんか言えることとか...

### 途中結果の集合・自由度がわかったら、もうそこに至る過程・構成要素は考えなくて良い。結果だけを用いて議論して良い。
- 固定でも記述したが、「自由度を決定することによって結果が定るという時、その結果の集合がわかったならば、もう元の自由度は考えずに結果のみを用いて議論できる。そして、結果を直接いじって考える方が考えやすい。
- 必要なこと: 途中結果の集合がわかること
    - 考察、xor基底...
- いつ: 自由度と、最終的な結果が離れていて考えづらい時。
    - 自由度を固定した時の結果を考え、それにより途中結果の集合を考察する等



## 手続きによって得られる物の構造考察
- 手続きによる特徴づけより、より簡素に条件を満たすものとしての特徴づけの方が使いやすい・役に立つ。
    - 後の考察だったり、最適性の証明だったり、一般に。

- 一旦手続きによる特徴づけが手に入ったら、全く別の問題として、「その手続きによって得られる集合はどのような特徴を持つか？」を考える。
    - 特に、ストレートに特徴を求めようとしないで、その手続きを考察の足がかりとすると良い。遥かに考えやすい筈。
    
- 条件を満たす限り何かをするというシュミレーションは、結果として「条件を満たさない」物が残る
    - 条件満たさない場合をうまく処理できればこれも解になる
    - 命題: 条件を満たさない時、その条件の成立のみが反例となる様な命題が成立する

- シュミレーションによって得られた解が正しいことの証明
    - 最初のstepをして良いこと、そしてその後再帰的に解いていることが多い

## 条件Aを満たす・違反する条件
- > 命題: 満たしていない -> 満たす の条件に比べ、 満たしている -> 満たさなくなる の条件が非常に簡潔に書ける場合がある(非対称)
    - これは今Aを満たしているという仮定により構造が生まれ、それによって議論が簡潔になるから

- > 命題: 条件Aを満たす必要条件を考える時、 満たす => OO という命題から議論を進められる



- 条件Aを満たさなくなる条件を考察する時は「今条件を満たしている」ことから何か言えないか考える
    - 特に条件Aが強い時


### 自由度がない要素
- > 命題:自由度が一意に定まる要素は、今その影響を計算すればもう無視できる
    - 一意に定めるのは貪欲など
    - そういうのがあるなら、何かしら極端な要素がこれを満たすことが多い
### 要素の順番
- > 命題: 要素の並び順が一意に決定できれば、その順に見て要素の使用・不使用を決定するdpができる
    - 他、dpに限らずとも前から使用・不使用を考察して貪欲ができる場合もある
    - つまり、順番が一意というのは良い構造
- 条件が明らかならばそれでも良いが、次の手続きでも条件を得られる:
- > 命題: 要素の集合を任意に固定し、順番も固定する。その上で隣り合う2要素を見た時、「その2要素をswapして良い条件」が要素に関する全順序になれば、その順でsortして良い
    - 例: 文字列を結合して辞書順minにする。隣り合う文字列をswapする事を考えると、swapして良い条件が要素ごとに定義される値の大小になる
- この命題を考えると、割と非自明な順番も得られる。よって、順番を固定したい時はこれを考えると良い。

### 重複がない
- 01になってオーダーが落ちる
    - 単調増加列の個数 >> 狭義単調増加列の個数
<br><br>


# 区間・連続
何かしら区間になっている時、それを上手く利用できると非自明かつ大幅な高速化・考察の変化が起きがち

## 区間演算
- > 命題: 長さkの区間にaddする時、mod k = 0の要素の総和 の変化 = modk = 1の要素の総和の変化... modk = k - 1の要素の総和の変化
    - これを元に必要条件が構成できる場合が多い
    - > 系: kが定数ならば、mod k事にみた要素の総和の差分は操作を通して不変（不変量）

- > 命題: 区間演算は、列に対し差分を取るなどする事で、変換した列上の2点への操作と同一視できる
    - 数え上げが容易になる場合
    - 応用：操作が存在する2点をグラフ上でも辺を張り、パスと操作列で対応が取れれば、後はパスを探す問題になる

## 区間同士の演算
- > 命題: 区間の共通部分は区間
- > 命題: 区間の和は区間とは限らない。特に、共通部分を持つならば区間
    - このように、区間同士の演算は区間になりやすい
    - > 命題: 区間同士の演算 $1$ 回が常に区間になるならば、演算を何回やっても区間

- そして、実際に区間になる場合、結局ずっと区間になっていて、考察が簡単になる・再帰的に処理できる可能性が高い。


## 集合としての区間
- >命題: [l, r] を、 集合 l, l + 1, ... , rを表すものとして見れる
    - >系: 集合のマージがO(1)でできる
        - 高速
    - >系: 集合の保持が整数2つでできる
        - これを持って探索する・場合分けする等の計算量が（元と比べて）drasticに落ちる
- よって、「全てを管理する」と言う愚直が、その全てが区間であるならば高速化される

- >命題: 最適化の問題において、最適な遷移がわからずともあり得る遷移を全て列挙できれば解ける
    - >系: 区間ならばそれができる可能性が高い
- > 命題: 数え上げにおいて、区間にしてまとめて遷移できる
    - dpでアリエル結果の集合を管理 -> 集合を区間を管理
    - (作れる要素の)種類数の数え上げ -> 集合を区間を管理して最後に長さを計算
       
## 区間をサポートするデータ構造
- セグ木
    - 区間演算
- 遅延セグ木
    - 区間変更
    
区間を管理するset、区間に辺を張るテク


<br><br>

# 単調性

## 二分探索
> 命題: 二分探索できる

## 要素の順番
> 命題: 要素の順番を好きに並び替えて良い時、適当にsortすることでkeyについて単調性が生まれる
- 例: マンハッタン距離 $|x_i - x_j| + |y_i - y_j|$ は、 $x_i \ge x_j$ ならば $x_i - x_j + |y_i - y_j|$ である。これを用いると、 $x$ 座標でsortすることで、マンハッタン距離最小のペアが $O(n \log n)$ で求まる

- 単調性は強い構造なので、このように問題が簡単になる・貪欲が正当になる場合が多い

### $f(i, j) = f(j, i)$
> 命題 : $\oplus_{i < j}f(i, j)$ について、$f(i, j) = f(j, i)$ かつ $\oplus$ が可換ならば、 $1, 2, \dots , n$ の順列 $P_1, P_2, \dots, P_n$ について 
>$$\oplus_{i < j}f(i, j)  = \oplus_{i < j}f(P_i, P_j) $$ 

- つまり、要素を好きに並び替えて良い
    - ok: $\max, \min, \gcd$
    - ng : $f(i, j) = i - j$

<br><br>

# 凸
> 命題: 凸関数の和は凸関数

- 凸関数の集合のminやmaxは凸とは限らない。
## 三分探索
- >命題: 底以外で狭義単調増加・減少な関数 => 3分探索によって最大値・最小値を求められる
    - 系: a0 < a1 < ...  < an かつ b0 > b1 > ... > bn な関数について、 $\max_{i + j = k} a_i + b_j$ が $\log$ のオーダーで求まる

## 構造
- 凸であるという条件は強く、これが構造をもたらすことがある
- >命題: 何処で底を取るのか三分探索せずともわかれば、解の形を制限できたり、値を直接求めにいける。かつ、凸という制約によりそれは求めやすくなっている。
    - 単調性がある時、わざわざ二分探索しなくて良いことがあるのと一緒

<br><br>

# DON'T GET STUCK ON ONE APPROACH
- 一般に、強力な構造を元に建てた解法は速めだが、しかしいつも求められているオーダーに届くとは限らない
    - 例えば独立性は一般にはとても強力だが、今見ている問題に限っては別の構造を主眼に置いたような解法の方が強いかも知れない

- よって、例えいつもは上手くいく構造が見つかったとして、それで解法が立たないなら別の構造を探す必要がある
- 1つの線に深い考察というより、たくさんの線を考えて綺麗なものを見つける

- いつ考える: ある(強力に見える）構造に注目しても解法が立たない時
- 何を考える: 別の構造を探す・注目する


<br><br>


# 考える要素の中でも、極端なものに注目して考察する
> 命題: 全ての要素が条件を満たす => 極端な要素も条件を満たす  
- かつ、極端な要素は、その要素がユニークに満たす条件から追加で特別な構造を持っていることが多い。よって、どうせなら常に極端な要素を見れば良い。  
-  **必要な事: 何か極端なものに対して、言える事がある(のみ）**
    - 上手くいく良くあるパターン
        - 他の自由度と比べ一意性が強くて
            - いま決定できる -> その決定によって問題が変化する
            - 考えやすくてなんか良い事がある
        - 全体の形に影響するため、それを固定すると問題全体の一意性が上がる
- > 命題:わからない事を全て解き明かさなくても問題は解ける可能性が高い**
            - 議論に曖昧な事を挟むのはよくないが、それに取り憑かれないこと。

- また、**極端な要素に注目する時は、必ず”全ての方向に対して"、極端なものをそれぞれ見ること**
    - min・maxの要素、最初・最後の要素
    - 1方向きで少し上手くいっても、それでは不十分なことがある

> 命題: 1つ決定して良いことがあり、かつその決定を再帰的に行えるならそれを繰り返すと解が得られる
- 例: 最小全域木や貪欲法、マッチング
- 往々にして、max/minのものを決定する(他ができるならこれも決定できる



<br><br>

# nが小さいケースに帰着
- > 命題: 決定できる自由度が1常に1つ以上あるならば、その自由度の決定を繰り返すことで問題が解ける
    - よって、今決定して良い極端な要素があれば解ける
        - 例：マッチング
    - 常には存在しない場合 -> 適応条件を明記して、それが守られているか確認する
- また、「次々決定していく」という形のアルゴリズムが正しい答えを返すなら、背景に上の命題があることが多い
    - 例: 最小全域木...コストminの辺を含んで良い
        - 応用: 連結成分をk個にするという時もコストminの辺を含んでよく、同じアルゴリズムが使える
- n -= 1
    - 端や外周、n番目を埋めるパターン
        - 何かしらについて決められるパターン
        - 問題によっては、綺麗にn-1に帰着するために、決定するものが固定な場合がある
    - 必要なこと： ある要素について、n-1に帰着できるような形で今決定できること。あるいは、解けてる・ベースケースに行けること
        - 特に、全体についての構造がわからなくても良い。全探索でもなんでも良いので、探索的でもその要素が決定できればok
            - 要素ごとの制約に分けられる時 -> その要素について満たされていればokでやりやすい
        - 想像もできないような構築も作れる
        - 偶奇やmodで解けているケースがわかれている場合、1要素決めればmodもずれて解けているケースにできる
        - ベースケースは全探索など。また、なんでそのベースケースで成立するのかの考察は無駄なこともある（帰着できればそれで良い）
        - n-1に帰着する際に消す要素は特徴的な要素 かつ いつでもあるやつ が好ましい
    - いつ考える
        - 全体の構造の想像がつかない時
        - 構築でしんどい時
        - 要素ごとにちょっと独立みがあると嬉しい
    - 何を考える
        - **必ずしも綺麗なルールや規則に基づいて帰着する必要はない**
            - 状況から計算したり(一貫したルールではなく）、全探索したり、自分がやりたいようになど、いろいろな都合から何を・どう決定するか選んで良い
                - 自由度が高くて適応しやすい

- n -= (小さい時に可能な構築)
    - 構築を組み合わせてサイズが大きい構築が作れる時

- 問題の分割
    - 数列をどっかで区切って独立に解く、など

## 帰着させる時、何を決定するか
- 条件を導いて、それを満たすものを決定しても良いことを示す
- なんらかの評価値を作って、それが一番良い（小さい・大きい）ものを決定しても良いことを示す
    - 貪欲。いつでもmin/maxは存在する

## nが小さい時の答えを利用して構築
- 割とある
- 基本要素みたいにして組み合わせる

<br><br>


# 全単射/1対1対応するもの
- 命題: ある集合のサイズを考える時、その対象と全単射が存在する別の集合が存在するのなら、別の集合のサイズと一致する
- 命題: 性質を保つ全単射が存在する場合、元の問題を別集合上で言い換えて良い
    - 集合のサイズ -> 数え上げ
    - 性質...コストとか。最適化

## 数え上げにおいて
- よくあるのは 操作 : 結果
- 必要なこと:
    - 条件を満たす要素全体の個数さえわかれば良いという状況である事
    - 1対1対応するものがあり、それなら数え上げられること
        - 片方にだけ良い構造があるのかと思うかも知れないが、そういうこともある
        - 特に、1:1対応に移すという事は集合のvalidな要素の個数だけが重要で、よってvalidな要素の個数がわかりやすいような対応先は良い（特に、集合内の要素が全てvalidな時、もう集合のサイズさえわかれば良い）
        - 特に、数え上げる対象そのものに直接良い構造が無くても良いことに注目
- いつ考える:
    - 1:1対応が取れた かつ　困っているならば、対応の方に眼を向ける
    - 特に 操作 : 結果


- 命題: 単調列の個数は、単調とは限らない列に比べオーダーレベルで少ない
    - 単調列は集合と列に全単射があるので、個数が集合の個数になる（順序の自由度がなくなる）
    - 例: distinct かつ $0 \le a_i < n$ である数列 $\{a_i\}$ の個数は $2^x$ であり、冪乗のオーダー

## 最適化において
- 例えば: グラフで言い換えた時
    1. 操作列が存在 => 対応するパスが存在して、パス長がコスト
    2. パスが存在 => 対応する操作列が存在して、操作列のコストがパス長
- という時、コスト最適な操作列を考える上でもうパスの最短経路を考えても良い


## シミュレーションの言い換え
> 命題: シミュレーションによって定義された値についても、同じ値を返す別の条件があれば、その条件を満たすものを求めるとして良い
- 単にシミュレーションをそのまま高速化するよりも柔軟に高速化できる

<br><br>


# 数え上げ
- 数え上げは全探索なので、多くの手法が他の分野の問題に使える
    - 足し算の線形性を用いて分解とかの手法は使えない

## 否定・以上
基本: 否定の方が数えやすいなら、否定を数えよう
- 肯定ではふわっとしているもの <-> 否定なら固まってるかも
- たくさんのバリエーション <-> 否定なら少ないバリエーションかも
- 2以上  <-> 1
- とりあえず、「ooで**ない**」「oo**しない**」といったものは全て疑って良い

- 操作列 -> 結果 で、作れない結果を探索する時、
    - 作れる :$\exists$操作列
    - 作れない:$\forall$操作列
- となって、考察の方向性が変化することに注意(判定の貪欲が変わったりする)
- [式変形](https://hackmd.io/aQrfqrLIQxabjpiwcTLSIw)

- [例題](https://atcoder.jp/contests/arc090/tasks/arc090_c)
    - 2人が交わらない経路
        - よくわからない
        - 交わる点の距離は一意
        - 交わるような経路を数えた方が簡単？

- [例題](https://atcoder.jp/contests/abc355/tasks/abc355_d)
    - 区間について、交わるより交わらないの方が簡単な場合がある
    - 交わらない、は状況が一意で、交わる場合より却って少ないので
    - 右端昇順に見ていけば、交わらない⇔相手の右端が、こっちの左端より前

- 1つ以上OOである...余事象・包除原理を考えた方が楽
    - いつかんがえる: いつでも
    - 1つ以上は、ある自由度に対してさえ満たしていれば他はどうでも良いという構造をしていて、自由度ごとに独立ではない。
    - 全てOOではないは、自由度に対して独立。
    - 母集団引くの忘れがち、最初に書いておく
 

## 探索の軸は基本自由
- 決めるものがたくさんある時、何から決めるかは自由である。
- いつ考える: always
- 何を考える: 楽になる決め順。高速に答えが出る決め順
    - 特に、あるきめ順を検討して上手くいかないなら、必ず逆向きの順を考える
        - 左から <-> 右から
        - 時系列前から <-> 後ろから
        - 小さい方から <-> 大きい方から
    - sortして良い -> とりあえずsortして考える

## 全探索できる物を見つけたら、とにかくそれを軸に全探索を考えてみる


## よくわからない -> 何かを固定した時の数え上げを考える
なにかを固定 -> 一意になったことによる影響を考え、真っ先に処理
- 固定したものを動かしながら総和を取れれば解ける。
    - 固定した時について考えた時、数え上げる上で固定すべき情報」がより少なく済むとわかれば、固定を緩和することで動かしての数え上げが簡単になる。固定したものを動かせるなら解けるし、固定の緩和によって動かせるようになっても解ける。
- また、固定する事で状況が単純になって、構造・数え上げるものにつく強力な必要条件がわかりやすくなる事がある
    
- いつ考える: 数え上げでよくわからないなら割といつでも。


## 何かについて場合分け -> 問題のサイズの小さいのに帰着されていて、終わり
- 特に、その何かには極端なものを選ぶとうまくいきやすい。（集合の最小の要素とか、数列の左端とか）

- 必要なこと :場合分けすると、うまく問題のサイズが小さくなるような要素がある。高速化すれば間に合う
    - これさえ成立すれば、他がいくらわからない状況でも解ける
- いつ考える: 極端な要素がありそうな時。集合の数え上げ。他より際立って考えやすい要素がある時。


## iによらない遷移
- 高速化: 行列累乗など
- 考察: シミュレーションが行われると捉えずに、全体を俯瞰すると良さそう？


## 数学的な考察

### xの倍数である
- 1: kを自然数として、 xkで表して立式。ユークリッドの互助法など。
- 2: mod k で考え、 = 0とする(mod k以上の情報を捨てて、同一視。数え上げなど。)
    - Ai + Akがkの倍数 -> Ai + Ak = 0 ⇔ Ai = -Ak     
        - iとkで独立!
### パラメータをずらした・状況を一部変えただけ
- ずらす前・より簡単な状況で綺麗に表せる操作は、ずらした後・変えた後でもある程度綺麗に扱える場合が多い。かつ、それでも綺麗なので、その結果が使える事が多い。
    - 例: 線分上での対称移動    
        - 基準点をaとして x -> 2x - a
    - 例: 円環上での対称移動x
        - mod 円環の長さになるだけ
        
### 区別すべき物を区別せずに、後から係数を掛ける
- 嬉しい: dpにしやすい
    - dpは同じ状況を纏めるという側面があるので、状態の情報量が減ると当然高速化につながる
- 必要: そのような係数が求められる事
    - もとまるにするために、dpの設計をし直す場合すらある
    - 結構大変

- 疑惑: そのようにできる場合、そもそも人に対して制約が対称的であり、dpにおいて「具体的に残っているのは誰か」をロストさせられる

### 互いに素でない時
- gcd = gとする。
- 倍数関係について、割っても変化しない -> gで割って、互いにその場合に帰着

### 丁度 $k$ <-> $k$以上の言い換え
ちょうど $k$ より、 $k$ 以上の方が好ましいやつ
- 全てのkについて列挙ならいつでも言い換えて良い
- 丁度k, のせいで制約が増えて考えづらい時

- 「各素因数について、次数が $k_i$ 以上」である整数であって、 $n$ 以下の個数 (from : 各素因数について、次数が丁度  $k_i$)
    - ⇔何かの倍数
- 集合に $x$ が $k$ 個以上含まれる (from : $x$ に丁度 $k$ 個含まれる)
    - $x$ を $k$ 個とって来たとして、残りの集合についても以前 $x$　を含んで良い
    - これによって分割統治がうまく行ったり
        - そもそもの条件が「$x$ が含まれて良い」の時に、 $x$ が $k$ こ含まれる場合...で場合分けした時

- a or b $\subset$ $k$ (from : a or b = $k$ )
    - 条件が「a と b が共に $k$ の部分集合」になる
        - 演算に逆元があれば、左から右を復元できる
            - メビウス変換
-min(a, b) $\ge$ k (from : min == k, max == k)
    - 全てがk以下、とk-1以下を解いて引く
        - 逆元が必要
    - 「どれかについて丁度kが存在」が消え、それぞれの要素が独立に動けるようになる
    - 期待値問題とか
    - 判定問題にも使えそう
    - min(A1, A2...)の期待値の求め方:
        - minがx以上である確率を足し合わせていけば良い
        - すると、全ての値がx以上の確率を求めれば良いことになる

### $\sum_{i=0}^{n-1} ai \le S の時の組み合わせ$
- $n$ 項目を追加して、そいつにも重みを負わせることにすれば、「sumがちょうどS」に帰着できる場合が結構ある
    - 何かの固定を動かす場合、動かしてsumを取らずとも求められたり
    
### 数列に対するスコアのsum <-> 数列の個数の数え上げ
- 数列のスコア $\ge a$ となるような数列の個数が、a全体にわたって求められれば良い
    - 上のテクと合わせる場合
### ある値aiを含む集合のgcd
- 単調に上位集合になっていく時、そのgcdはせいぜい log ai 通り
    - aiの約数通りではない
    - 割り算するので、という理由
    - 単調に... -> 区間とか
## 約数包除
- 動機(いつ考える): gcd(a, b) = k は条件が独立じゃ無いせいで難しく、 gcd(a, b)がkの倍数は独立なので容易い。
    - lcm(a, b) = k -> a, b共にkの約数
    - （素因数の視点から見て）ちょうどx -> xの倍数
- ここで、この左右の値を結びつけるのが約数包除とか呼ばれるもの

### テーブル -> テーブル
- f(x)が与えられた時、 F(x) := $\sum_{xの約数であるようなy}f(y)$ とかを求める
- 簡単
- ライブラリにある

### （疎なテーブル) -> 変換後sum
例として、F(x) := $\sum_{xの約数であるようなy}f(y)$ を扱う
- F(1), F(2), F(3), F(6)が与えられ、他のF(x)は0だと言う時、$\sum f(x)$ を求めると言ったような
    - テーブルを変換する手法よりも計算量が落とせる(単に変換するよりはhard)
- $\sum f(x) = \sum A_iF(i)$となるような $A_i$ (つまり係数)を求め、それを用いて F(i) != 0の項を集計すれば良い
    - 係数の求め方1: 機械的に係数を求める
        - (1): 既知の配列{bn}と、求めたい配列{an}の関係を約数や倍数の言葉で書く
        - (2): 式変形して係数列を導く
        - (3): 求める
        - (4): n, mを丁寧に書く。入れ替わると全く変化する。
            - [そう言う問題](https://atcoder.jp/contests/arc185/tasks/arc185_e)
            - この手法では$\sum B_if(i) = \sum A_ig(i)$ のように、求めるものにも係数がかかっていても求められる
            - Bのうち特定の項だけ集計したいとかもok!
    - 係数の求め方2: 包除原理の考え
        - gcd(a, b) != 1 ⇔ a, bが共になんらかのpの倍数 ⇔ 素因数が1, 3, ... に+1, 2, 4... に-1, p^2に0(メビウス関数)
        - 素因数に関する包除原理は、一見（素数が多くて）計算量がやばいが、有効な値の範囲から見ると間に合っていることが自明な場合が多い
        - [係数を求めることで疎なテーブルについて変換後sumを高速化する](https://atcoder.jp/contests/abc230/tasks/abc230_g)

    
### 多項式復元
- 方程式
- なんか上手い方程式であって、値がそうなるもの
    - (x - ?)^? みたいなのを足し合わせる

### 数え上げ: 補集合/否定
否定や補集合を考えた方がわかりやすい場合は多い。
特に、OOでないという形の制約は考える対象が多い・漠然としていることが多く、保守業を考えた方が良い。
区間であって、交わりを持つようなペアは何個あるか？
→実は、交わらないという条件の方が数えやすい。

### 集合の数え上げ
- 数える集合の必要条件を考える

- "作り方"を決めて、それに沿ってdpする
    - 数列の左から使用・不使用を決めていく...
    - 一番小さい/大きい要素から個数を決めていく...
    - 常に総和の条件を満たすように一番大きい要素を突っ込んで、それを分割していく.../一番小さい要素を統合していく...
    - 重複してはいけない : 集合の作り方を一意にする・標準形を決めて、それを遂行する
    

- 順番を決めて、add or notを決めていく。1回notしたら復活しないルールにする
    - 0個含まれる場合
        - 次へ
        - ooが含まれないという条件から、再帰的に問題を言い換えられるかも
            - 要素全てから-1するような言い換えは、要素の値の範囲が変わるので注意
    - 1個以上含まれる場合
        - 1個の影響を処理
        - 
- 典型 :分割数数え上げ
    - 分割統治
    - 問題のサイズをキーとしたdpと見るか
    - dp[i][pre][S] := iまで決めた、最後の要素はlast,総和が S の集合の個数...を高速化する典型的な手段
        - 以降がlast以上という条件の時、「以降の要素にはすでにlastの下駄がある」と思えて、その下駄を総和に反映した上で問題サイズが小さくなる



## 纏めて数える数え上げ
何か、パラメータを共有するものを纏めて数え上げられないか？
- 探索の軸を変えるという事
    - しかし、軸を変える理由の全てがこれというわけではない
        - 他: 持つ情報を減らすとか
- 高速化に悩む時、これを考える事によって軸の変更を考えるのは有意義
    - 計算量が「元々の母集団」から「まとめた後の種類数」になる
        - 種類数のオーダーの方が小さければ高速化


    
## 数え上げの主客転倒・寄与の分解
全ての数列を動かす時...に強い
- 一般に、そのような状況でdpしようとすると情報量が大きくなるため

**計算するものが + で結合されるならば常に、それぞれを分割して計算して良い。**
- 必要な事: + で結合されているものを数える時に、注目するものを固定したら解ける&&それを全体に動かした答えがわかる時
- いつ考える: 基本分割した方が楽なので、方針の1つとして必ず考える
    - 特に、1つ1つが独立だと、その1つに注目した時に情報量が一気に減ってできやすい
- **何をする: 分割した1つに注目した時、それを求めるに当たって独立な（関係がなくなる）・無視しても答えが変化しない情報を全部ロストさせる**
    - キヨに分解すると独立性が生まれ、問題が急激に変化する場合が多い。この変化を忘れず整理する
  - 何を計算するのか、立式すると良い
  - 要素を固定した時、状況の整理によって独立に動かせるようになって、それぞれを高速に求められるというケースは多い
    - 要素を固定した事によって状況が2値になる/対称性より1回計算すれば良い等で、劇的に簡単になる場合がある。
    - $\sum$ の $\sum$
        - $a_{i1} + a_{i2} + ... + a_{in}$ の総和
        - 個数の和・期待値


- 寄与を分解すると決めたら、寄与の種類についてのループは一番外側に行くべき
    - なぜ:状況の単純化や、それによる前計算の恩恵を受けるため。
        - 答えを固定する考察と似てる
- かつ、寄与に分解、つまり今注目する物を固定したら、できるだけ状況を単純化・2値化する
    - 例えば、もはや値の大小しか関係ない場合、一旦 0 / 1で考えて、最後に0/1内での並びの分階乗をかける
    - 変に一度に計算しようとすると、却って状況が単純にならず旨みがない場合
   
- 演算にbit演算が入る場合、bit毎に和を数え上げる主客転倒がうまくいく場合がある
    - $\sum \sum A[i] \oplus A[j]$

- Σの添字の範囲よりも、中身の値の種類数の方が少ない時、入れ替える高速化



- 
##  寄与への分解をする、と宣言したら解けるというものでもない/分解の上手い定義
- 寄与への分解の仕方についても、「うまい分解」の仕方を考える必要がある

- まず、**分解した対象には文脈がない方が良い**
    - 文脈あり: 「OOという手順でシュミレーションした時、この要素までやったら...」
        - これだと、結局シュミレーションを実際にやりたくなって、状態量が爆発してダメになりやすい
    - ない: 全部をし終わった時、結果としてこの要素は?
        - これなら、「全てを動かす <-> 今の選択がなんであろうが、他の要素は全体を独立に動く」という、"全ての変化"を考える時の独立性を活かしすい。
        - および、「関係のない情報を全部ロストさせる」という目的から見ても、関係のある情報は少ない方が良い。

    - よって、シュミレーション中にこのイベントが起こる回数を求めたい、などは、そこまでのしゅみレーションの結果に依存するところがあって求めにくいだろう



- 寄与に分解したのちも、係数を求めなければならない
    - ここでさらに寄与に分解することもある

- いつ寄与が発生するのかがわかれば、寄与を数え上げるdpにする事ができる
    - 必要な事: いつ寄与が発生するかの情報　という事


- 寄与に分解して求める時、同じ寄与を複数回足さないよう確かめよう
    - 特に、極端な部分だけ場合分けして足す場合
    - maxとminだけ別に足す <- max = minの時バグ

## 数列を動かす・変化する時のooの総和
- 寄与への分解が強い
    - 素直なdpだと、変化の自由度に応じて「前までの変化の結果はooだった」を持つ必要が出てきて、情報量爆発しやすい
    - そういう時に、シグマを分解する・順番を入れ替える事によって、まとめて数えやすくする

- 差分を計算、もok
    - 主に、変化の影響が小さい時

### 寄与の分解を用いた条件の分離・言い換え
- 条件A, Bに対し、「A かつ notB なら寄与2, A かつ B なら寄与1」のような時
    - AとBが絡み合って、数学やdpに起こし辛い
- **条件ごとの寄与を求める**
    - 言い換え: 「Aが成立なら寄与2 かつ B が成立なら寄与 - 1」
        - 条件を分離できた

        - 実際には、条件の成立関係(B ならば A等)が上手くなってないといけないので、確認する
        - [例題](https://atcoder.jp/contests/arc167/submissions/57188317)
            - 「距離k以内に1つ || 2つあって、その2つの距離がk以内なら寄与1、2つあって、距離がk以上なら寄与2」
            - 2つの距離がk以内になると減る
            - 距離k以内に1つ...寄与1
            - 左右の距離がkいない...寄与-1
            - とすると辻褄があう



## 差分更新をする数え上げ
- K = 1, 2, ... , nについて問題を解けと言う時
    - Kの変化であって、変化量が小さいような変化順があれば、その変化順に従って求まる
        - 最も典型には K = 1, 2, 3, ...


- 基本的に、なんらかのテーブルや値を維持・更新していく
    - 途中で、テーブルのある部分の値が意味なくなったりする
    - **ここで、意味のなくなった値について考察してはいけない/必要な値が正しいかだけ考える**
        - 何を考察すれば良いのか？
    - 及び、テーブルの値について、途中で意味がなくなった（必要が無くなった)かと思いきや、その後再び正しい値が必要になる場合がある
        - その時は、必要になったタイミングで、正しい値が格納されているか考える
            - 途中を考えない
                - どうなっていれば良いのかわからないため


### 全てのprefixについて求めよ
- 差分更新の考えを使うことが多い
    - 数列がほとんど変化しない -> 新たにaddした要素による変化を考える
## 敢えて立式しない方が簡単な数え上げ
- 代表: 組み合わせ的な数え上げ
- 入りそうなもの: 組み合わせ的な物、数え上げる対象の条件が簡潔に表せる物(特に、生成手順ではなく、満たすべき条件が与えられる物)
    - 対応を用いることもある
    
    - 順列であって、i, jに対し、「(i <= k <= j), P[k] >= P[j]」
        - 言い換え: P[j]がP[i]....,P[j]の中でminである
        - 数え上げ: 全ての順列に対し、P[i]...,P[j]を抜き取ったものを考えると、P[j]がその中でminであるものが1つあって、つまりN!/(j-i)+1 みたいな感じ


- 2つの要素のペア
    - N!通り
    - 行列のdetと近い式をしていて、実際利用できる場合がある


### 具体: 連結成分の数え上げ
- そのまま考えて出来そうならいいが、dpしたいとなった場合、連結性をどうやって持つのかが問題になる
    - 難しい場合が多い

- 別のものの言い換えにしよう
    - case1: 列上のグラフ o-o-o  o-o o-o-o
        - 切れ目ごとに、連結成分数に寄与 + 1
            - 切れ目ごとのキヨを数える問題になる

    - case2: 木、森
        - 辺ごとに、連結性分数に寄与 - 1
            - 辺の本数を数える問題
<br><br>

# 期待値/確率

## 命題
- 遷移のグラフを(アバウトに）考える。それぞれの状態vについて何らかの期待値 $\mathbb{E}[v]$ が定まっているとする。この時、
 $$\mathbb{E}[v] = \sum_{vから出る辺(v, u)} \mathbb{P}[vからuに遷移する確率](\mathbb{E}[u] + 遷移のコスト)$$
 $$\mathbb{E}[v] = \sum_{vに入る辺(u, v)} \mathbb{P}[直前の頂点がu　|　現在vにいる] (\mathbb{E}[u] + 遷移のコスト)$$

- のどちらかが成立する。
- 一般に、 $\mathbb{P}[vからuに遷移する確率]$ は問題で与えられていることが多い。また $ \mathbb{P}[直前の頂点がu　|　現在vにいる] $ は与えられていないため自分で計算する必要がある。

- 直前の頂点が排反なので
$$\mathbb{P}[直前の頂点がu　|　現在vにいる]  = \frac{\sum \mathbb{P}[現在uにいる]\mathbb{P}[u \to vの遷移をする]}{\mathbb{P}[現在vにいる]}$$  
になる？
## 「今までの」ではなく「これからの」を持つdp
- **上の命題より、期待値を求める問題では多くの場合で「これからの」期待値を求めることが、「これまでの」を求めるよりも難しい**

    
- 期待値を求めるdpでは、1回の遷移で状態が変化しなくても良い場合が多い
    - 右辺と左辺に共に未知数が入ったとしても、式変形で消せる
    - よって、「1回の試行」をもとにdpの値を求めていくと楽で良い
    - [例題](https://atcoder.jp/contests/arc016/tasks/arc016_3)

## 初手の試行の結果で場合分けすると問題が小さくなって解ける
- 必要な事:　初手の試行で場合分けすると、問題が小さくなる事。および、全部計算できる程度に状態数が少ない事
- いつ考える: 線形性での分解とかよくわからない時・方針に困った時
    - 上の「これからの」に発想が近いと思う
    - [合計がX以上になる最小のiの期待値](https://atcoder.jp/contests/abc382/tasks/abc382_e)
        - これからの、で考えても解ける。状態は「これからX枚取る」
        - 初手で場合分けしても、問題のサイズが小さくなってる。上と全く同じ。
## 期待値の線形性・寄与の分解
$\sum$で表される(例:個数や回数)期待値について、それぞれの要素について、**独立に**期待値を求めた後和を取って良い。
- 使える必要条件
    - 分解したのちのそれぞれが求まる事
    - 分解したら計算するものが多くなるなら、全てについての和が高速に求まる事
- いつ考える: 期待値で、状態が多い時
    - ほぼ毎回考えて良いが、素直に定義に従って分解できる程度に単純なら、定義から求める（分解しない）方がよいこともある[区間転倒数がわかれば定義通り求まる。かつ、分解した時高速に求める術がよくわからない](https://atcoder.jp/contests/abc380/tasks/abc380_g)

- 基本的に、独立で分解したほうが解きやすい。
    - 独立性より
    - よって、求めるものを、できるだけ「要素ごとに+で結合されるような・要素ごとの重みの和で表される」式で表したい。
    - 表示が一意でないなら特に。
        - 例: 順位の期待値を求めるとき、 i * (i位の期待値) とするより、 $\sum$ 要素iが自分より前に来る確率 とした方が分解しやすい。

- dpと分解は独立なテクではない
    - 要素の個数の期待値について、要素毎に持っている確率を求めるとして良い...[例題](https://icpc2024.jag-icpc.org/icpcdomestic/contest/all_ja.html)
    - 操作の回数の期待値について、それぞれの操作毎に行われる確率を求めるとして良い...[例題](https://atcoder.jp/contests/awtf2024-open/tasks/awtf2024_b)
- また、本当にこの言い換えによって独立にしてしまって良いのかの保証は、期待値の線形性を用いて行えば良い


独立なら、積についても分解して求めて後で掛けるとして良い。

## 状態の分解（定義より）
- $\mathbb{E}[試行で発生するスコア] = \sum_{試行が取りうる状態} \mathbb{P}(試行がその状態になる確率) \times \mathbb{E}[その状態から遷移する直前までで試行で発生するスコアの期待値]$
    - 命題:状態 -> 状態の、細かい遷移を考える必要がない。状態を固定した時、その状態になる確率と、そこでの期待値がもとまれば良い。
        - 遷移を全て計算するには状態の情報が大量に必要だという時、dp[状態]:=そこからかかる期待値 というdpだと計算量が爆発するが、これはその計算がいらない。
- 必要なこと: 状態の分解を固定した時、それに至る確率と、そこから遷移するまでに発生する期待値が計算できること
- いつ考える: 上記のようなdpを立ててしまい、困った時
    - 多くはシミュレーション的な試行でこの状況になる。



### シャッフル
なんかすごいランダム  

シャッフルした要素の中から1つ選ぶ <-> シャッフル範囲内の要素からランダムに1つ選ぶ

### 分解典型1: $\mathbb{E}[試行の回数]$
- $\mathbb{E}[\sum X_i := i回目の試行をしたなら1, else 0]$ の形に落とす。すると、$期待値 = \sum i回目の試行をする確率$ になる。
    - 分解したところで、それぞれが関わり合っていて高速にもとまらないなら、あまり良くないかも

### 分解不可典型1: $\mathbb{E}[max(X1, X2...)]$
- 分解できない
    - かと言って、期待値の定義通り分解してももとまらない場合がある
    - そういうときは、E[max(X1, X2...)] = $\sum_i (P[max(X1, X2...)] >= i) $ を用いると良い
        - maxの条件が、要素ごとに独立になって、愚直に定義通り展開するよりおそらく考えやすい

### 分解不可?典型2: $\mathbb{E}[\sum X_i \ge K となる初めてのi]$
- 双六とかである
    - 初手で場合分けしても良いし、「これからのdp」（再帰的なdp）で求めても良い

## sum / 場合の和 の還元して、sumを求める
- 分解するよりも、こちらを考えたほうが楽なケースがある
    - 楽で無いケース <- [グラフの削除回数の期待値](https://atcoder.jp/contests/agc049/tasks/agc049_a)
    - 少なくとも、積の和典型を使おうと思うと、コレをすると格段に見やすい
    - 積の和典型は場合の和を経由する



## ループの解消
- 漸化式ではループを持つ時の解消法
    - 0: 移項する
    - 1: ループの1点を、漸化式とは別の方法で求める
        - 計算量を多くかけても良い場合が多い
        - 元々求まってる場合も多い
    - 1-2: 1次式を持つdpでやって、だす
        - 巡回の解消がとても無理な場合
        - (1) : 1次式の形で全て表す
        - (2) : わかっている等号からxを導く
            - 期待値... ax + b = cx + dとか
                - 等号
            - 確率... a0x0 + a1x1 + ... + anxn = 1の連立方程式を解くとか
                - 確率sum = 1
                - 特に, ax = bx ならばx=0であり、これが出た場合勘違いしている可能性が高い
                    - ループの1箇所でだけうまくいかない漸化式を考えているとか
    
    - 3: 循環 -> 回数の情報をつけて、無限和にして、公式から計算
        - 考察重め、実装軽め、いつもできるかわかんない
   

## 条件付き確率が厳しい時、問題の言い換え/dpの言い換えで対応する
- dpの設計によっては、「この操作でooが起きる時の操作回数の期待値」& 「この操作でooが起こらなかったという条件のもと、操作回数の期待値は何か」が知りたくなる場合がある
- 難しい場合がある
- そのような時は、dpを言い換える事で、「ooが初めて起きるまでの期待値」だけを必要とする、というテクニックがある
    - case: 幾つか独立な要素があって、それぞれについて1回以上ooを達成したかが重要な時
         - ooを達成した場合と達成しなかった場合で分けると、どうしても達成しなかった場合の期待値が必要になる
         - どうしよう
         - ooが達成されることを1段階とすると、「達成した時にした場所が、ooをすでに達成してたかornotの確率がわかれば良くなる」
<br><br>

## 対称性
> 命題: (key, value)の組みを計算するとき、同じvalueをとるとわかっているkeyはまとめて考えればよく、2回計算しなくて良い
- 系: dpにおいて、同じ値を取るkeyを持たなくても良い
- 系: シミュレーションにおいて、高次元の情報をもたなくてよくなるばあいがある

> 命題: ランダムワープを繰り返すとき、全ての場所について、そこにいる確率は等しい
> 命題: 打ち消す様な操作について、それが起こる確率が同じなら期待値は0
に、期待値ならばこれは打ち消しが起こる可能性



<br><br>

# 最適化
## ノイズとなる要素の排除
- 考察の上で、「明らかに無駄な要素」は邪魔になることが多い
    - これを考えるせいで綺麗な貪欲がないなど
- そう言うのは最初に排除した方が良い
- しかし、これは結構時間と労力が要る
- しかし、問題の見方を変える事でその作業が「明らか」の1声で済む場合があり、積極的にしようね

- 2パラメータ -> 平面プロット
    - 実数係数なら
    - 2要素の組み合わせ -> 線分
    - 3要素以上 -> 平面
    - 無駄を省く -> 凸包
    - に対応しがち
    - (こう言う都合で、inf・極限->実数に言い換えが良い)

## 判定問題に落とす
- 非自明な問題の簡略化の恩恵がデカすぎる
    - 目標が定まらないと、それに向かった貪欲も生まれない
- やっぱり辞めるかの判断は、直接求まりそうと言う前向きな動機がある時で良さげ


## 全探索できるものは全探索する
O(1)で答えを出そうとしない
- 最適解になるうる答えの構造として、特徴的なのがいくつかある
    - -> 最適解はどの形なのかを考えるのではなく、全ての形について最適解を出して最後に比べる

## 最適解の構築⇔全探索
- 最適解の構築→全探査
    - とても綺麗な構築が無理だと思った時
    - 貪欲や、「この解は無駄」という事実が見つかっていれば、探索に活かせる
      

## 判定/固定問題を解く
- 必要な事: 何か（特に: 答えを）固定した問題が（簡単になったことによって）解ける事・その固定を全体に動かせる事
    - 固定の旨みは上に書いた。
- いつ考える: 詰まったら常に。基本姿勢。貪欲やしなくて良いの利用・選択肢・条件を全て見ないは、探索空間を狭めてこの探索を高速化するためのテクニック。
    - 一意に定めて良い -> それを決定する、も考慮すべき対象を狭めていると考えて良いかも
    - 特に、「貪欲によって答えをすぐに求める」事はできないが、答えを固定した時の判定は簡単に解ける&&判定を（二分探索やそもそもの愚直で）回しても間に合うというコースは非常によくある。


- 結果を固定した時、その結果は実現可能か？を考える
    - これが解ければ、その結果を直接全探索したり、あるいは判定に必要な情報だけを全探索することができる
        - 特に、重複とかを考えなくて良くなる
    - **日本語で終わらせずに、ちゃんとアルゴリズムにすること**



- 判定問題に単調性があれば、二分探索できる
    - 時には単調性を持たせるために、判定問題を少し変形する必要がある
    - 変形した判定が解けなくても、そもそも判定回数がそれなりに収まるなら、元の解きやすい(: 答えを**丁度**、あるいは何かしらの形で xにできるか) 判定問題を解けば良い
        

- [上界の利用]明らかにこれ以上は無理という結果が得られた時、逆にそれを達成することは可能か？
    - 自由度が高い状況では有効


- 最適化において、「取りうる値が複数種類ある時、値を選択する事による副作用がないと仮定すると、最高をとることを確定できるなら即座に確定して良い/ 逆に、今は最低しか選べないなら後回しにして良い」

## 上界・下界の利用
- まず、答えはOO以下。かつ、OOを達成できる。と言う論調
- 必要なこと: 上手い上界ができて、かつそれを達成できることを言える
- いつ考える: 
    - 探索の自由度や答えの形の自由度が高くて困った時
        - 自由度高いならいろんな結果が作れる -> 上界も作れそう
    - 特徴的な要素に注目した結果として
        - その要素が全体の結果を左右するなら、その要素のみによって結局決定される場合も多い
            - [木の次数列を固定した時の直径のmax -> 次数 = 1が支配的な制約]


- n個sum
    - [1, 2, ... , n]
    - [1, 2, ... , n-1, n+1]
    - [1, 2, ... , n-2, n + 1, n + 2] or [1, 2, .. ., n - 1, n + 2]
    - ...

## しなくて良いの利用・自由度の制限

最適を取らないような探索を省いて良い。そのために、「ooしなくて良い」「ooとして良い」のような貪欲が見つかりやすい
- 必要な事: 最適化の観点上、しなくて良い探索がある
    - 特に、全体の形に対するものでなくても、特定の部分に対して「OOは連続しなくて良い」等は多い
- いつ考える: 最適化で高速化に悩んだらいつでも


- 自由度が制限され一意になることにより、状況が簡潔になって考察し訳すなる・全探索ができるようになるのが旨み


### 同じ結果を2種類の操作で得られる -> 片方の操作の制限
- 片方の操作をしないとしてよい


### 目的関数を最大化するように並び替えろ
**何かしらの比較関数でsort**
  - 比較関数の作り方
  - [1]**隣接する**2つの要素について、どちらが前に来るべきかの判定関数を書く
      - swapした時の影響を数式で書くhttps://atcoder.jp/contests/npcapc_2024/tasks/npcapc_2024_h
- [2]その順序が、推移律を満たすことを確認する

さえすれば、その隣接要素の判定をそのまま比較関数に用いて、sortしたものが最適であることが言える。
- [参考](https://drken1215.hatenablog.com/entry/2022/12/16/194300)


 - 極端な物を見た時、「後ろに・前に持って行った方が良さそう」という感覚がある時に有用



### 関連: 順番を入れ替える: sortする考察
隣り合う2つについて、入れ替えても良いことを言えば良い
- [例題](https://atcoder.jp/contests/arc151/tasks/arc151_d)
    - 簡略化: Xiの値が不変の区間について、高速にできる
        - 入れ混じるのが大変
    - エスパー: Xiについて、クエリをsortしても良いのでは？
        - Xiが異なる隣り合うクエリについて、入れ替えてもok

## ある選択肢について、決定をのちに保留・選択肢や分岐を持ちながら探索
- 持ちながら探索とは: それぞれ別々に探索するのではなくて、あり得る集合を持って1本の探索するみたいなイメージ

- 必要なこと
    - どの選択肢を取ろうが、後の選択肢が変化しない
        - するなら別々に探索しないといけない
    - あり得る結果の集合を管理できること
        - 区間の場合は頻出
- いつ考える: 上記が満たされていて、かつ「今決定」は無理な時
    - 保留せずに一意に決めていいなら、今決めてしまった方が影響の前計算ができて速くなる事が多い
    - とはいえ、殆ど全探索なので、本当に選択肢を保持できるならほとんどの場合解けるはずで、これ単体で解けるぐらいには強い構造
        - 保持する上で余計なコストがかかる分、決定できるならしようという話

- 判定問題で保留の考えは活躍やすい？
    - [A以上B以下のaddを繰り返してcを作れるか？](https://atcoder.jp/contests/abc388/editorial/11912)
        - とりあえず最悪にして、後から差分を決定
        - 貪欲にできるO(1)
        



## 最短経路への言い換え
- 何が嬉しい: DAGでなくともO(|状態数+遷移数|log)或いはO(|状態数+遷移数|^2)ぐらいでテーブルが求まる
    - つまり、DPできなくても答えが求まる

- 必要なこと: (1)始点(すでにコストがわかっている点)があること (2)各状態間での遷移のコストがわかっていること (3)状態数+遷移数が間に合う程度に小さいこと

- [そのまま:最短経路への言い換えで解ける](https://atcoder.jp/contests/arc064/tasks/arc064_c)
    - それぞれのバリアに入るまでのコストがわかる
    - 始点もバリアだと思うと始点が生まれ、終点もバリアだと思うと所望の結果も得られる


## 時系列逆に言い換える
- 今の選択が、後の選択によって塗り替えられる時
    - 嬉しい:最終的に残す部分以外はなんでも良いことを反映できる
        - 最終的に残る要素から決めたい、を形にした一つ
        - 保留させてほしい
    - 数列の置き換え...
        - 後ろから見て、ワイルドカードを導入することによって、この命題を利用できる

- 選択肢を選ぶ条件が「選択肢を選ぶ直前において」では異なるが、直後においてでは一致する時
    - 直前においてC以上なら、-Cして良い
        - 直前の値に対して、状況の良さがが単調でない
            - 少し高い方がマイナスできて生き残れる,等...
        - よって、様々な状態を持たないと前からdpなどできそうもない...
        - 単純にするには、選択肢を全て固定するぐらいしかないが、ここまで固定すると同時にシュミレーション、ができない場合が多い
    - 逆から: +Cして良い。ただし、直後において、0以上でないといけない
        - 直前の値は大きいほど良い
            - 貪欲が生まれる


- また、「順方向にやると操作が無限に広がるが、逆にすると有限」という時、有限性から何か制約が発生 -> 一意の流れが出たりする
    - 例: 加算...+無限にいけるが、逆からにすると、最初が>0なので、 <0となるような減算はできない

- （時系列逆に限らず）言い換えは、「どちらも難しいが、一方はさらにとても難しい」という時、その一方を引いてしまうと厳しい
    - よって、難しいと思う度に反復横跳びしよう！
  

- 期待値
- 要素が時間の経過によって変化していくタイプ
    - 終了の時刻がわかれば影響が決定できるというアイデア -> 二分探索
    - f(i) := 今、終了からi秒前とした時のOO と定義すると、今から終了までの時間がわかるので影響が計算できる。貪欲等すれば、上記に比べてlogが落ちる
## こちらに有利になる制約 -> 敢えて外すことによって、答えの自由度を上げる
- いつ考える:考察の過程で「結果を固定した時、実際にこれはあり得るか」を考える時、有利になるような制約のせいで、実際にあり得るのかの判定が複雑になる時
    - 最小化で min(ai, bi)を選ぶ -> ai, biから好きな方を選ぶとして良い。かつ、そうすると採用するai, biを決め打った時の実現判定が楽になる(biを使うと決めたが、実際はaiが小さい場合...の場合分けが減る)

# 最大値・最小値

## 判定問題
答えをxにできる・x以下にできるか？を解く
- 必要な事: 固定したら（解きやすくなっていてかつ）解ける事。また、その固定を全て動かしても間に合う事。
- 最初に、条件を与えられた数値 $x$ で書き直す
    - 最大値がx以下...全ての要素がx以下
    - [例題](https://atcoder.jp/contests/arc053/tasks/arc053_c)

- 目標によって（最低限）取るべき解の形が変わる時に特に有効
### 二分探索
単調性があれば、判定問題を解く回数を減らせる。
かつ、基本的に、最小値が存在するならば、「値をx**以下**にできるか？」は単調性を持つ。よって、この判定問題が解けるならば、その問題は解ける。
- 動機 : 愚直なら思いつくが、完全な愚直は間に合わないという時に、愚直を実行する回数を減らして間に合わせる

なお、常に単調性があるとはいえ、判定問題が解けなければ意味がない　例 : 無向グラフ　サイクルのサイズの最小値
問題例 : https://icpc-domestic.trap.show/contests/jag2018/　のE
- 最小値の最大化
  特にこの、「問題を二分探索によって変換する事で解ける」傾向が強いようだ。逆に、それ以外で解くには複雑な関係を処理しないといけないからかも。
  
## convex full trick
- 基本アイデア：傾きが大きい方から見ていって、なんとかする

- 直線...convex full trick 

- 折れ線: 始点が共通...始点バラバラに比べて綺麗な形をしていて、上側の変化の計算が楽
![alt text](<スクリーンショット 2024-12-16 23.20.01.jpeg>)
### 周りの値さえ定まれば貪欲できるという問題
- 最短距離への帰着

- 値を定める制約にDAGの構造→順々に決定
    - [例題](https://atcoder.jp/contests/abc368/tasks/abc368_e)
        - 辺iに制約を課すのは、T[j]<=S[i]を満たす辺jだけ
        - 制約の関係がDAG
        - 制約がかかってないから貪欲に決定していく



### maximize  x ⇔ minimize -x
- [例題](https://atcoder.jp/contests/abc368/tasks/abc368_e)
    - 牛げーの特殊版(制約がdag)
        - しかし、特殊版なので、上記の言い換えをすることで牛ゲーの枠組みでも解ける
        - $O(M^2)$の辺ができるので間に合わない


## 単調性/区間
- 単調性は嬉しい性質

- 単調性を持たないが、似たものがありそう <- 区間になっているケース



### 大きくなりうるスコアと上限が小さいスコアの加算
- 大きくなるうる方をB, 小さい方をSとすると、スコアが小さい方ではSの影響が大きいが、Bが大きくなってくるうちにSの割合が小さくなっていく
    - よって、Bの大小でスコアの大小が決まるようになる
        - 枝刈りになる
    - [大きい方はN^2,小さい方は高々N](https://atcoder.jp/contests/arc052/tasks/arc052_c)
        - 全探索したい
        - 情報が多い
            - 前もって処理とかも浮かばない
        - 小さい方は高々N
            - Bが大きくなったら、それより大きいBは無視できるはず
            - B' - B > N
            - これを元に、Bの範囲は√Nぐらいでok
            - 前よりスコアがデカかったら省く、をすればok 

### 複数のオプションと、それぞれにスコア
- ある選択肢であって、他の選択肢のスコアのsumより大きいのがあったら、それを貪欲にとって良い。
    - 2値...値がでかい方を貪欲にとって良い。




<br><br>

# 判定

## 最適化との際
> 命題: パラメータ $n$ が大きい時常に yes ならば、パラメータ $n$ が小さい時だけ計算すれば良い
- 最適値を求める時より計算量が落ちる
<br><br>

# 証明

## 貪欲


- その選択をした後の状況に注目して、「今最善をとっても状況が悪化しないのでおk」をいう
    - のちの状況が単純で、良い・悪いが比べられる時

- ある操作について、「いつかしなければならず、かつそれをするまで、その操作に関わる部分の状況が変化しない（周りと独立？）」時、今すぐして良い
    - いつ考える: 操作ができるならば、今すぐして良いの証明

- （ある特徴量によって）上界が示せて、それにそうならその操作が最適
    - 操作の最適性を言いたくて、いい感じの上界がある時  
        - 操作によって動きが大体一様なもの/どんな操作でも一定量変化するものを選ぶと良い。特に、必ず+1 -> 操作回数の下界

- 任意の探索について、1.その探索の中に最適解が含まれる 2.その探索において、Aが最適 => 全体においてAが最適解
    - 探索を絞る時の正当性

- 任意の状況について、より偏らせた方が得 => 極端なものが最適
    - a^2 + b^2 <= (a+1)^2 + (b-1)^2 等

    
-  任意の最適解を持ってきた時、初めて貪欲から外れる点に注目して、そこを貪欲ベースで選ばれた選択肢に置き換えても解が悪化しないことを言う
    - よくあるのはswap。最後に持っていっても良いはswapせず、抜きだして移動など


- 2方向の自由度がある -> 全部を極端な物で初期化して、それを減らしていく一方向で考えると変更の方向性が一意
    - 全体に総和制約 && 日毎に累積和で総和制約 最適化[例題](https://atcoder.jp/contests/abc250/tasks/abc250_g)
    - 全ての日を最適な選択肢で初期化 -> 日毎にこれまでの解を改悪する事で制約を満たすようにする
    - この時改悪の選択肢を貪欲に選ぶ

- 複数の要素がある状況で貪欲したい -> 考慮する要素を順々に減らしていく方針にする
    - 極端なやつについて決定 -> 無視できるならもうその要素は無視

- 困ったら
    - 場合分け
    - 特に、対象の個数が小さい時はできる
    - 前提条件はちゃんと明示する
        - 特に、再帰的にくり返す系
## 必要十分条件
- 最後の操作に注目 -> 最後の操作はそのまま残るので、それにつく必要条件が考察しやすい
    - 操作をしていく/置き換えていく系で、可能・不可能の必要十分条件を考えるならば、常に有効

## 同じと見做せる -> 制限
- 同じと見做せるものは、「条件を満たすか」「最適か」を考える上では、制限しても良い

- 特に単位元的なものは好きにadd/削除して良い
- 例
    - a + b or a ... a を a + 0とすれば、常にa + bの形で操作を表せる

### 2つの操作列から同じ結果
- 片方の操作列は発生しないとして良い
    - 操作1をx回 = 操作2をy回 -> 操作1はx回未満

## 最適化の探索・DPの正当性
- 最適解が探索に含まれる
- 最適解より良いスコアをだす違法な解が探索に含まれない

- の2つが必要十分
- 多くは前者を考える
- [なんとなくで立てるとWA](https://atcoder.jp/contests/abc388/tasks/abc388_g)
    - 意味がある周辺20マスぐらい保持 -> 2WA
    - 遷移で漏らしてるかも...そうらしい


## 背理法
- 自明に解けるケース: 成立するケース
    - 成立しないとした時、何が言えるか?
    - [特殊なグラフ上でのマッチング](https://atcoder.jp/contests/arc045/tasks/arc045_d)
        - 連結成分でnがevenならできる？
            - 言い換え無理
                - 次数1はすぐやって良い...それ以外？ 

## 過去を改変する貪欲
- 命題: 局所的な最適と全体の最適が異なる時、「常にその時の最適を取る」で構築した解は全体の最適解とは限らない
    - 命題: 一致するならば、常にその場の最適を取る解法が最適解と一致する。(一般的な貪欲)
    - しかし、次の命題のような条件を付加する事で、そのような状況でも貪欲できる場合がある
- 命題: 「今までの範囲**だけ**見た時の最適解と何らかの情報」を元に、新たに1要素追加した時の新たな「最適解と情報」が求められるなら、それを続けることで全体の最適解が求まる
    - 1要素だけaddした時に修正できれば良いという事
    - 局所的な最適と全体の最適が異なっても良い
    - 往々にして今まで構築した解を変更する <- 過去改変貪欲
        - 改変について、「過去に決めたやつの中で最悪なやつを追加した要素とswap」するなど
## misc
- 手続き型の記述の証明 -> その手続きによって得られるものを条件の形に落として、そこから議論
    - 頭を一回スッキリさせて、「その手続きから作られるものは？」を解く
        - 最適なものは何？より考えやすいだろう
    - 常に最適が示せない時に考える
    - 例えば: 作れるものの必要十分条件は、この手続きで得られるもの <- 距離が遠くて考えづらい>
        - この手続きで得られるものとは？を先に解く解く
<br><br>

# 状況が変わる部分で問題を区切って、変わらない部分は一気に求める様な計算
- 必要な事: 状況が変化しない範囲での答えが出せる
- いつ考える: 状況が変化する時・情報を持って探索するが、必要になる情報が途中から変化する為たくさんの情報を持つという時
    - 例えば、最初の方は初期HPを使い、途中から回復するという時、両方をまとめて処理しようとすると「今のHP、回復量」の2つのパラメータが必要になる
    - しかし、初期HP -> 回復ゾーンでそれぞれ分けて計算したのち、初期HPが切れるタイミングを全探索して状態を合わせる事ができれば、持つ情報が1次元に落ちる
    
<br><br>

# 選択肢を全て列挙しない・条件を全て確認しない
- 必要な事: 求めることが「全ての自由度の対してある値」なのでは無いこと。例えば「最適な値」であったり、「何かの判定に必要な値である」こと。
- いつ使う: 愚直に全ての選択肢を試してそれを集約しては間に合わないが、上記の条件を満たす時。
- よくある手法: 最適なものから「選択肢になりうるか」を試す。選択肢になりうるなら、そこの自由度は確定なので、その自由度を考慮から省く。

- $n \times n$ ペアの探索対象 -> 全ての $n$ に対して、理想な相手を探す

## 問題の構造的に等価なものを両方調べない
- 情報のロスト的な
- 主に最適化・判定で、等価なものを両方調べなくて良い



## 二分探索による高速化
判定の回数がlogになる。
## 並列二分探索
シュミレーションを完了するのはある程度まともな時間に収まる かつ 独立な二分探索をたくさんしたい時に使える

### 各選択肢について、そこで取れる選択肢のうち最適なものだけを計算する
- 必要な事: 愚直に全ての選択肢を列挙している状況において、ある選択肢を取る事を固定したら、その自由度の中でも「これを取れば良い」という一意な選択肢が存在する事
    - 固定みたいな
        - 内側の選択肢を消す

    - 選択肢になりうる、未確定の自由度の検知が高速にできれば間に合う
        - [全ての開始位置を探索](https://atcoder.jp/contests/abc268/tasks/abc268_h)
            - 素直: 全ての文字列について、全ての開始位置について、そこから始めて含まれるかを計算すると間に合わない
                - 一つの開始位置について、そこから含まれるもののうち、長さが最短のものだけ考えれば良い。
                - これは貪欲より成立

### top2だけ持つ探索
- 必要な事: 「いくつかの選択肢から最適を選ぶ」という時に、例えばtop2の選択肢さえ求まっていれば良い(的する方を選ぶ等)なら、それだけを求める（ダイク小さい方から）探索をすることによって、全ての選択肢から全ての対象への値を求める事をしなくても解ける
    - 特に、全ての選択肢について最適な値を出さなくて良い事を使える
        - 最適な選択肢について、その値を求めるというのは頻出
    - 最適化ならば、小さい方から・最適な方から求めるというのはダイクストラ方
    - [人気者を始点に、国でまとめるとそう](https://atcoder.jp/contests/abc245/tasks/abc245_g/editorial)
    - 
<br><br>



# 構築
## どうなっても良い（決定を自由度として保留しておく）のは構築において便利そう
### 不変量の見つけ方
典型的な不変量を頭に浮かべながら実験する。

### 典型的な不変量
操作によって、全体として必ず減る・必ず増えるもの・常に不変なものを考える
 - 個別の要素間では増えたり減ったりするかも知れないが、全体では減る事がある

- **何かの偶奇**
    - 和の偶奇、差の偶奇、個数の偶奇...
        - 0にしろ...最終的には偶数
        - 操作できない状態...偶数・奇数・あるいは個数
            - ゲームを不変量で解析するときに頻出
- 大小が制約に関わる(sort, swapの条件)時、転倒数を見るのは良い
- 数列の和、mod M

- bit/ bit演算
- b進数表記した時の桁の数について...
    - [例題](https://atcoder.jp/contests/arc145/tasks/arc145_d)
- +1と-Nをする操作... mod(N+1)で、一様に+1 
    - [例題](https://atcoder.jp/contests/arc079/tasks/arc079_c)
         - 任意の順で操作しても答えが変化しない事の証明
             - 任意の順で最小A回→定められた順でもA回、を証明する...総和とmod(N+1)の一致より、数列一致

或いは、何かの証明をしたい時に、"これは不変なので、これ以上は操作できない・これ以上この遷移が走る事はない"の主張で使える
 - その時も、"その操作で"全体で不変・増加・減少しているものを見る

### 典型な必要条件
- 不変量に注目した必要条件

- 最初の操作による必要条件

- 最後の操作による必要条件
    - 途中は自由でも、最後だけはきっかりとした事が言える場合

### 典型的な"綺麗"な操作・事実
小さい操作
- 一致させよ
    - +1/-1できる...
    - swapできる...
        - 特に、隣接swapさえできれば任意の並べ替えを作れる
        - [例題](https://atcoder.jp/contests/arc183/tasks/arc183_b)
                - 最終的な位置に注目
                - 各要素の相対的な位置を隣接swapで合わせていけば大体できる
大きい操作
- 一致させよ
    - sortできる...
    - 種類の違うものを前後に分割できる...
- 最適な物を構築せよ
    - 上界が達成できる...
        - 上界を作ることだけを考えれば良く、目的が定まって嬉しい
- 数列SをTにせよ
    - 先頭から合わせる事で高々定数項を残して一致させられる...
        - 残った数項は不変量で評価

- **多方向から考える**
    - 片方で詰まったら切り替える
    - [例題](https://atcoder.jp/contests/agc067/tasks/agc067_a)
        - 大きいクリークがある || 補グラフで3角形なし

- サイズが大きくなるとだめ・常にok
    - ダメなものを貪欲に取ると、maxが指数オーダー
    


#### "できる事"は丁寧に集める・早とちりしない
- 時間の浪費
- 回数制限クエリ系、 $O(???)$でoooが求まりそう...本当にそのオーダー？
    - 丁寧に見る事で、応用にも繋がる
    - 誤った考察を元に考えるのは本当に時間の無駄

## 存在しないものを作ろうとしてはいけない/できない時がある
- 出来ない場合について「条件を満たす」手段を考えたって解けない
    - 特に条件が複雑な時、存在しない事が見え辛い
- まず、判定を先に解くべき(判定問題ならはなからこれ)
- すぐに解けないなら、必要条件を出して状況を整理するだけでも良い
    - 旨みが状況の固定化なので、これでも十分恩恵を得られる
  
- 必要条件から手が出ない場合もある
    - 「そのそも作れるものは何か・それに対応する条件の要素はどのような振る舞いをするか」というアプローチからも、必要条件を得られるし、これがクリティカルになることもある
        - 条件が複雑な時


- そういう時は、貪欲などによる「ooとして良い」を用いた状況の固定・考察が強い？



- 数学の式に持ち込んで不変量を作るのが楽
    - [ドミノを置く、制約 -> 個数の式](https://atcoder.jp/contests/agc041/tasks/agc041_c)
        - 1個置く時、全体へのキヨは3
        - よって、 3 * (置く個数) = 2 * n * クオリティ
            - nが3の倍数ではない時、クオリティは3の倍数に限るとわかり、全部愚直にやるより高速に考えられる


## 判定 : 必要条件を積み重ねる
必要十分条件が直ちに出せない時に考える。
- 必要条件を足していって、十分にする
- 必要条件になりそうな要素を貪欲に取っていくことが大切
- 必要条件が増えるたびに、「これからはその必要条件を満たすものだけを考える」として、状況を再び整理する



### 利用の仕方がわからない制約・規則
- 機械で答えを列挙して、何か答えに良い性質が生まれないか実験する
    - [例題](https://codeforces.com/contest/1991/problem/D)
    - 答えを列挙が難しくても、何か列挙できるならそれを見る


### 一致・変形判定標準形の利用
一致判定に良く使う
最初の状態S,目標状態Tを共に綺麗な状態にする
- 01列...1だけの列
- この時、置き換え操作ならば、その操作の逆をできないか考えると良い
    - 逆ができるならば、もう2始点と思って良い
    - [例題](https://atcoder.jp/contests/arc071/tasks/arc071_c)

### 条件を満たす"部分"ができるように操作しろ
- [1]条件を満たす集合を選択 [2]その集合を、条件を満たすように操作 の 2段階に分けられる
    - 集合を固定した時の操作の仕方をまず判定問題として解いて、その結果を元に何を選ぶか考えたりdpする
        - [例題](https://atcoder.jp/contests/arc126/tasks/arc126_d)

## 似たようなものを複数用意する時
- サイズが大きいものを1つ用意し、それを部分的に利用するような構造にできれば、用意するものが減ってコストが減る。


## 掛け算 / 足し算
- 掛け算...「始点と終点が定まっているが、途中で分岐する」という時、その外側の経路に対して、今見ている分岐の数だけ掛け算になる
- 足し算...一つのブロックの分岐を増やすと、足し算（そこの係数に対して）になる

## 綺麗な形の利用
実はうまくいく場合が多い。
- 綺麗な形を試して上手くいかなかった時は、何故うまくいかなかったか？を考える
    - それを克服する綺麗な形はないか？
 

- 小さい時に「未来にも役にたつ解」ができたら、それを組み合わせる
    - [補正がたくさん聞く盤面がn=5で作れる](https://atcoder.jp/contests/kupc2024/tasks/kupc2024_b


## 存在するなら1つ見つけろ
- 鳩の巣原理
    - 嬉しい: 実質的な全探索が小さい計算量で行える
        - 存在する条件で絞れない・枝刈り全探索が無理とかの時
    - 必要: "適切な"巣
        - そもそも鳩の巣原理とは、「どのような要素もいずれかに該当する」という条件の集合を見繕った時、「いずれかの条件について、それを満たすものが2種類存在する」というものであった
        - よって、任意の重複 <-> 答えの発見 出なければならない
        - 式にすると、f(i) = f(j) のような式が一つ見つかるので、それを元に答えを構成できれば良い
    - あるいは、重複がある程度少ないなら、探索を進めることで巣を完全に埋める(:= 答えを見つける)ことができる

- 乱択
    - 必要な事: 1回の失敗確率が小さい
    - いつ考える: 条件を満たすものが（存在するならば）多い時

- 範囲を絞り込んでいく
    - 候補:= 全体集合とする。その集合を小さくしていく。 
        - 特に、候補を二分割して、「存在するならば少なくともこちらには含まれる」というのが分かれば、log回の深さでわかる
    - 必要な事/いつ考える: 集合に対するクエリが捌ける

### 集合から要素を1つ見つける: 条件を満たす要素が多い時
- 必要な事:　条件を満たす要素の個数が多い・全体からの割合で表されている事
    - これが満たされていれば、全ての選択肢を試さなくても、うまくサンプルすれば小さいオーダーで良くなる・乱択ですぐにみつかる
- いつ使う: 条件を満たすものが存在するなら1つ出力せよという時に、愚直に全ての選択肢を試していたら、その削減策(最適化の時みたいな)

- 例: 集合の部分集合であって、条件を満たす&&サイズがn / 2以上
    - そのような集合が存在するならば、適当に2要素のペアを取った時、そのペアが共に集合に含まれる確率は 1/4 <- 確定的にするなら $O(N)$通り試せば良い。
        - 特に、1つ選ぶ時は1/2 <- 確定的にするならどのみち $O(N)$通りであり、ペアを試してもオーダーが変化しない

## 連続と離散の違い
- 連続では対称にすると最小値を取る関数が、離散では少し偏らせた方が最小値を取ることがある。
    - 対称で条件を（少しだけ）満たさない時は少しだけ偏らせると値が小さくなり条件を満たす可能性がある
## 埋め込み
- 無理に関数で実現しようとおもわず、視覚的に埋め込む（2次元配列とか）で、適宜コピー関数で埋め込むのが早い&&安全そう[参考](https://atcoder.jp/contests/agc041/tasks/agc041_c)
## examples 

- [マス目を01にする。個数の比を保ちつつ制約を満たせ](https://atcoder.jp/contests/kupc2024/tasks/kupc2024_b)
    - 解法1: ox, oox, ooox, oooox の基本要素を使ってA : B の列を1つ作る
    - 解法2: どっちでも良いますをたくさん作って、それを変更して作る
        - 小さい時の綺麗な解法を繋ぎ合わせる
<br><br>

### 他
- 初期状態を作っておいて変化させるという構築の場合、初期状態はシンプルなほど良い
    - デフォルトで1だけ重みを持つなどすると構造が少し複雑になって、そのせいで解けなくなる場合がある
        - [経路数を調製<-デフォで1作ると不都合](https://mofecoder.com/contests/itfpc2024/tasks/itfpc2024_j)


- 一致させよ・全てkにせよ
    - 差分がall0が必要(十分)
    - 差分での言い換えがしやすい
- 開始状態、終端状態が与えられた
    - 片方が特別単純な時 : 開始、終端をswapして考えると、dpで持つべき状態が減る...
    - 両方複雑な時 : 綺麗な"標準形"を作り、開始・終端を共に標準形にした上で、一致判定
        - sort..
- 簡単な操作を見つけた
    - 他のバリエーションは？
        - 似たようなことによって、数値が少し変わっただけのを作れるかも...
    - それによって解ける問題のケースはどのようなケース？

- 一部のケースが解けることがわかった
    - 解けない問題のケースは？
    - 何でそのケースで上手くいく？

- 複数制約がある時、後から辻褄を合わせやすい制約は後で合わせる
    - 総和とか
    - [例題](https://atcoder.jp/contests/arc145/tasks/arc145_d)

- 要素を選ぶ。隣り合わないように選べ
    - 要素の集合を2つ用意できれば、どっちサイドを使うかを適当に割り振ることで隣り合わなくできる

- 整数nの表示
    - 三角数(nC2)3つの和としてどんな整数でも表せる
        - 四角数（=平方数)だと4 [link](https://manabitimes.jp/math/926#5)
        - ただし、三角数の時、隣り合う数字を使うことが下の3つでのみ起こりうる。かつ、1については、2つ使うことがアリエル。


## 実験の仕方
- 一番解きやすそうなパラメータの時を考える
    - 順列: {1, 2, 3, 4, ... , n}の時
- 一部の制約を無視
- 小さいケースについて列挙

- **見比べる考察**
    - 必要条件を出したい時、「それが成立するもの」と「しないもの」を見比べる
    - 必要条件に対して、本質的な違いがあるはず
        - いきなり出せなくても、事実->理由->必要の順

- 状態にループがある時、単一始点なら解ける場合が多い
    - 一度探索した頂点は見ないとする
    - 有向グラフにおける、単一始点での到達可能頂点列挙
    - ただし、始点以外の結果は誤っている可能性がある


- 条件のエスパー -> それが必要十分か
    - 他のものは一歳満たしてはいけない
    - サンプルを全てためそう

# 構造の考察 part2
- 条件を満たす時の構造の考察も大事だが、単に与えられた操作の構造の考察も大事
- いつ考える: いつでも

## 重要な情報だけに注目し、他をlostさせる・無視するよう言い換える・言い換える・特徴量を見る
- 問題を解く上で、状態の変化をそのまま受け取る必要はなく、欲しい情報・条件・制約に係る情報だけを注目すれば良い。
- そのため、それらに関わらない情報は捨ててしまってよい.
    - 何をすれば良い:必要な情報とは上記のもの。あるいは、無視しても・言い換えても答えが変化しないもの.
    - 嬉しい: 問題が言い換えのごとに簡潔になる
        - こう言い変えても答えが変化しない...
        - こう決め打っても答えが変化しない...
        - この値は操作によって不変・一意に変化/任意の操作で同じ変化をする...
            - それに沿わない場合を考察から排除
        - この値はある程度自由に動かせる <- その「ある程度」を定める数値だけを考えれば良い
            - 今値は何という細かい値は重要では無い
        - 全く同じ制約<-何回も考慮しなくて良い、独立な制約はどのような制約か? 
    - 嬉しい:条件について、不要な情報をロストさせる事で適応範囲を広げられる場合がある
        - ooな時解けるな... <- 条件的に、もっとooはゆるくて良い(ooから情報をロストさせて良い)

- また、それらの重要な情報を見つけられれば、それのみに注目した議論ができる
    - 嬉しい:もはや多様な操作を見なくて良く、その特徴量の変化についてだけ見れば良い。これは元の問題よりはるかに単純である
        - また、「ざっと見るだけではかなり複雑だが、良い特徴量さえ見つければ「それから見て無理なのは無理・おkなのは何でも作れる」と言ったように見えることが多い
        - 変な操作ができるが、結局はgrandy数だけ見れば良いので...
        - 如何なる操作もOOを一定量変化させるので...

- 必要なこと: 上手い特徴量・答えを求める上で必要な情報が存在する
- いつ考える: 存在すると思った時常に。また、必要十分条件を考えたい時。

 


- 等しい...実際の値はどうでもよくて、差分 = 0が重要 差分に注目しよう　など
## 特に重要な特徴量:偶奇
- 使える必要条件: 数値が登場すること
    - ほとんど全ての状況で考慮することができる
        - 特に、「ペアにする」が出てくる状況では、ペアは偶数なので偶奇が効きやすい
            - 括弧列
    - かつ、コレが必要十分となる場合も多い
        - ゲームの勝敗
        - 構築可能性

## 不変量
- 特徴量の中でも、「操作によって変化しない」という構造を持つもの
- これを用いると、条件達成の必要条件として「S -> Tに与えられた操作で変化させられる => 不変量一致」が言える
    - 必要条件の補強
    - 不変量によっては十分性も自明

## 先に処理して良いもの（一意なもの・決定したもの）を処理・無視する/解けるケースを先に解いて、状況を再定義する

- 一意に確定した物
    - 確実に発生する物
- 必ずOOになるもの
- 自分で固定したことによって上記のいずれかになった物
- 解けるケースを除いても、その旨みがわからない時もある
    - そういう時もわざわざその制約を捨てずに残した方が良い
    - 黒魔術的なdpに走ってはいけない

- また、何か「もう処理した」部分が発生したら、その部分を全く考えなくてなるように(情報を)整理することも大切
    - 余計なものがあると、貪欲や再帰的な状況に気付きづらい
    - また単に、情報のロストによりdpの計算量改善


### 最初から存在しなかったとして考えても良い/一旦忘れても良い
- もう自由度を決定して、その影響も処理した
- 他の要素によって、代用されうるもの
    - 考察では「でも迂回されるかも...」といったわずらわしい婆位訳として登場するが、実はそういうのは「毎回replace先を使えばよい」となったりする
  
- 明かに損なもの 
    
    
- ものすごく自由に動かせる物
    - あとから都合が良いように決めればよく、一旦考慮から外して良い
        - 決定を保留する解法？
- 今決めなくても良いもの
    - どれかから選ぶ <- 後でどれから選んだが決めれば良い
    - 必要な事: 保留しても次の状況が変化しない(選択肢によって分岐しない)・保留してるものは、全ての選択肢にとって等価でないといけない
    - **特に、今一意に決めて良いものは、保留せずに決定して処理をするべき**


## 必要条件から攻める/必要条件を積み重ねる
- 条件や特徴づけ・構造を求めたいが、いきなり全体について出すことは無理という状況は頻出
    - そこで絞り込みを諦めてしまうと進めない
    - 極端なものに注目すると良いのであった
- 極端なものに注目に限らず、比較的見つけやすい必要条件を積み重ねていく事によって、必要十分条件を浮かび上がらせていく
- 必要条件の見つけ方としては、何か特徴的な物・極端なものから、それによって一意に定まることを探すと良い
    - 極端なものは情報量が多い
    - 例: 極端なものについては、それを生み出す方法が一意だったり、何かしら一意に定まるという情報が出やすい


    - A : B を対応づけた上で、Bが与えられた時(最適な)Aを求めよ、という形は多い
        - 結果 -> それをもたらす物であって、最適な...
        - BをもたらさないAを除去する必要がある
        - しかし、いきなり「BをもたらすAの条件は？」を出すのは難しいかもしれない
        - いきなり条件を導くのが難しいなら、必要条件から考えよう 
            - 往々にして、"特徴的な/極端なもの"に注目する事で何かが得られる


- BからAの必要条件を求めるのは定番だが、同時に、BからA(つまり、原因の構造から結果の構造)についての必要条件が発生する場合がある
    - シュミレ: 結果なら、与えられた結果よりシュミレに必要条件が科されるのはもちろん、シュミレの制約から結果に必要条件が出る
    - Aの必要条件の絞り方として、A->Bの方向とB->Aの方向の両方あるということ


- 必要条件を考えたが、それではダメだったという時、「まずもう少し緩和したものについては必要条件になっていて、かつ絞られた状況について元のものを場合分けすれば必要十分条件が完成する」という事はある
    - 元の線を完全に忘れるのは筋が悪いかも
    - いつ考える: それっぽい必要条件を考えたが、それが必要条件になってなかった場合。もう少し緩いのを必要条件としてみる


### A = B という条件の緩和
- AとBがある程度調節できる時、 A = Bが緩和できる
    - 例えば、A, Bともに += 3が自由にできる時、 A = B(mod3) にできる


## 十分条件から攻める/解ける場合を排していく
- OOならok
    - 他の手法/OOの改善によって、xxもok
    - ...を、必要十分になるまで続ける
- OOなケースなら解けるということがわかった場合、OOでないケースに問題を帰着させるということ
- 必要な事: 明らかに解ける・できるケースがある
- いつ考える: そういうケースがある時積極的に
- 考察を進められるような必要条件が見つからなくても、十分条件から問題を部分部分で解いていける事は多い
  

## 2d平面での考察
- 2つのパラメータp1, p2を持つ対象について、2d平面にplotすると、良い構造がplot上での位置関係に対応して構造しやすい。
- 命題 : 2d平面での2要素の位置関係が貪欲に対応する
    - p1が大きいかつp2が小さいと明らかに無駄という時、それは「左上にある頂点は全て無駄」というように対応
    - 全部無視 -> 片側凸方の形。綺麗になる
- 命題: 2つの要素を実数係数で組み合わせてできる要素 -> 線分あるいは直線上の要素
    - 3つ以上 -> 囲まれる領域内の点


# 操作の構造の考察

## 操作を組み合わせてできる単純な操作
- 与えられた操作を組み合わせてより基本的な操作を達成できる時、その操作から構造の議論を始める事ができて、元の操作を元に考えるよりもかんがえやすくなる
    - swap
    - 移動
- いつ考える:与えられた操作とその結果が捉えづらい時
    - 組み合わせてできる単純な操作は構造の考察に不可欠な場合がある
  

## 移動させる操作

**最初の状態と最後の状態に注目し、途中経過を考えない**
- 目標の数列に一致させる問題で頻出
- 隣接swapする時、最小の隣接swap回数
    - それぞれの要素の、最後の位置を固定すると...
        - 転倒数
    - よって、最後の位置を考える問題になる
- 最後の相対位置似注目 : ~を合わせる上で、実は操作OOは最初にやるとして良くて...
- 移動しないと決めた要素について注目 : 単調増加列の必要があって、LISを選べば良い...
- 最後の転倒数は0で、かつ操作ごとに転倒数は減る、転倒数を1だけ減らす操作が存在して最適...

**絶対的な位置ではなく、相対的な位置に注目する**
- indexはどうでもよくて、相対位置が本質な時に上手い情報のロストになる

#### 連続部分文字列をrotateする
言い換え: 要素と移動距離を選んで、選んだ要素を選んだ距離だけ移動する
こうすると、大きく移動する要素について、右rotateと左rotateを合わせる必要がない事がわかる・区間の操作が要素への操作となる・小さいrotateは大きいrotateにした方が良いことなど、色々良い性質がわかる

## 操作の単調性
- 単調性とは:一方向きにしか変化しない
    - 数が大きく/小さくなる方向にしか動かない

- 今min/maxである要素に特徴ができる
    - 貪欲ができる
    - つまり良い構造

- これを作るために、部分的に逆操作を考えて、操作を1方向にするとうまくいく場合がある
    - 増やすて減らす->増やすときはゴールを下げる

- いつ考える: 逆操作を導入したら操作に単調性が作れそうな時

## 2種類以上の操作の構造の整理
- 考察: まず操作が一つだけの時に注目して、その中に他方の操作を1回だけ挟んだ時にどう影響するかを見る事で、操作の関わりが見やすくなる
    - 嬉しい: 操作を1回に絞る事で、1回の影響が見やすくなる

## 操作の独立性
op0, op1について
- op0をした後にop1をするとして良い
    - 考察が楽になる（特にop1はop0をもう考えない）

> 命題: 最適解において、「...-> op1 -> op0 -> ...」 となっている時、答えの値を変更せずに「... -> op0 -> op1 -> ...」とできるなら、op0をしたのちにop1をするとしても答えは変化しない
- 答えが変化しないとは: 例えば操作回数が変化しないなど。操作の内訳は変化して良く、種類がswapされていれば良い。




## 逆から見た方が良い構造


### 代入・置き換える操作
次の命題が成立
> 命題: ある要素について、将来的に置き換えるならば今の状態は答えに寄与しない  

置き換えないならば結局今の状態が寄与するので、このままだと上の命題は利用しずらい。
ここで時間を逆から見ることで、上の命題に対応する次の命題が成立
> 命題: ある要素について、初めて置き換えた時の状態が答えへの寄与である  
- >系: 置き換えた時点で寄与が確定する
- 「どの要素が1回も置き換えられて無いか」の01列のみで探索できる

さらに、逆から見た場合次が成立
> 系: 1回置き換えた要素について、その要素を再度置き換えても答えへの寄与は変化しない  

> 系: 1回置き換えた要素に再度置き換えをすることで、その置き換えを無視できる

これが良い構造を持つ事が多い(greedy等)。


> 命題: データ構造への要素の削除は、単位元への置換で置き換えられる場合がある

> 命題: 挿入は、最初から位置がわかっていなかった場合、実際に動かす必要が出る

> 系: 挿入する状況なら、逆から見て削除にすると計算量が落ちる場合がある


- また、直接的な置き換えに限らず、「前やった操作の影響を上塗りするような操作」は、逆向きに言い換えると良い。

一般: 最初にやる操作より、最後にやる操作の方が条件が厳しそうな場合
- 最後の方が制約が強く、今何やったらいいかわからない・必要条件がなくても、最後には必要条件がつくということはある
    - [値をどんどん大きくしていく...最初の方はわからないけど、最後の方は目標の値の大小が必要条件として絡んでくる](https://atcoder.jp/contests/agc037/tasks/agc037_c)

### 最初綺麗で最後汚い
> 命題: 最初綺麗であっても、途中操作をすると汚くなる
- 最初の状態だけを見て全てがわかれば良いが、途中経過が存在すると両方汚くなる
> 命題: 最後は変化しない

> 系: 時系列逆に見ることで、最初汚いが最後は綺麗になる
- 片方でも綺麗になることで考えやすくなる場合がある

### 1回そうさしたらもう訪れてはいけない
> 命題: グラフについて、「いくらでも訪れて良いが、操作を1回したらもう訪れてはいけない」という時、逆から見ると「初めて訪れた時に必ず操作をする」となり、する・しないの自由度が消える

- [探索空間が狭くなる](https://atcoder.jp/contests/joi2010yo/tasks/joi2010yo_f)
    - 4方向に直進するたびに必ず1回は操作をする かつ　対象は固定 という条件になる
        - 順方向ではスルーの自由度がある
        

### 操作をしていく際、最初に比べ最後の形が定まっている時
- 最初の方は自由度が高いのに比べ、最後の状況が定まっている場合、「最後の操作」にかかる制約がわかりやすくなる場合があり、そこから考察を進められる場合がある

- また、「制約がどんどんキツくなっていく」タイプでは、「最後でもok -> 最後に決定 -> 最後のは前に影響を及ぼさないので、無視する」という流れにより、最後さえわかれば問題が解けるという場合もある

### 始点と終点で状態・条件が対象ではない操作
- 例えば「非負整数列」なら、始点に >= 0 と条件をつけるか終点に >= 0 と条件をつけるか選べる
    - 条件を課すことによって一意性を高める・条件を外すことによって特徴づけを簡単にするの両方ある

- [非負整数列数え上げ・条件を外す](https://atcoder.jp/contests/arc160/tasks/arc160_d)
    - modKを固定したら? <- 連続addが決まる
    - このあと、残りの操作は独立に扱いたい
        - しかし、modKを辻褄合わせる過程で負になる要素があり、その分は必ず埋めなければならず、独立ではない
        - 辻褄を合わせる回数もよくわからない
    - 逆から: 0000 -> ???? にする
        - 終点に制約が消えた
        - つまり、「mod Kの辻褄合わせ」は発生しない -> 残りの操作が独立になった


    
## 可逆な操作・打ち消す操作
逆操作が存在する場合に言えることがいくつかある。
- 操作回数を最小化しなくて良いならば: 標準形を使ってよい
    - とりあえず考察がしやすそうな形にしてから考えるということ。
    

- A -> Bにできるか？の場合、 A -> 標準形、 B -> 標準形 （標準形は一意に定まるもの) で判定しても良い
    - 考察のstepが減りやすい
    - 「作れる集合の中で」一意なものにすると良い
        - A <-> Bにできるなら集合が同じ、できないなら違う
        - 作れる集合の中で辞書順最小等

### 可逆な操作を両方行える時
- 操作A -> 操作-A のようなものは意味がない
    - これを禁止して仕舞えば、結果的に (-A)(-A)(-A)AAAA のような操作しか存在しない
        - (-A)の回数全探索等、随分考えやすい状態になる
            - [石を乗せる・排除<-可逆](https://atcoder.jp/contests/abc313/tasks/abc313_g)

### 打ち消す操作をするとして良い
- 片方しかしてはいけないという時、両方しても答えが変化しない。よって、独立にそれぞれ考慮するとして良い
    - 最適化で考えやすくなるかも
        - 株の問題 売る・買う

### 同じ方向の操作は連続しないとして良い
- 2方向なら、初手を決めた時点で方向は一意
    - これだけより
## 1回しかしなくて良い
操作を何回でもやって良いという時、何らかの貪欲に依って「操作は高々1回まで」と制限をつけられると、探索がやりやすくなる。特に、順番を考えるも何もなくなる。

## 良くわからない操作
複雑な操作は、考える上で大きな枷となりうる。
- 本質は「自分が良くわかっていないこと」

- そういう時、「操作を組み合わせて出来る扱いやすい操作」を作って、その上で考えることで考察が進みやすくなる
    - ただ、往々にして操作全体から一部の操作に制限した場合、を考えていることになり、答えが変わる場合がある。
        - 最適化では危険だし、そうでなくても、解けないならその制限を排除する事になるかもしれない
        - 進まないよりはマシ...?
### 操作回数に上限がある
#### 操作回数が精々1回
- 操作をしない状態についての前計算をした上で、操作の仕方を全探索
    - ある操作をした時の結果を、そのテーブルから計算する
- 前から、操作をした・してないを状態に持ったdp
    - 操作の仕方に自由度がある場合、結果の状態も多岐に渡り、dpの更新が間に合わない場合がある
        - 実はooな操作しかしなくてよくて...(貪欲)
#### 操作回数がk回
- 前から、操作をした・回数を状態に持ったdp


<br><br>


# 問題の言い換え
## 答えが変化しない範囲で自由度を増やす
- 不利になりうる方向に言い換える
    - $\sum min(a, b)$ の最小化 -> $a, b$のうち、好きな方を選ぶとして良い
    - 答えは変化しない上、考察が軽くなる場合がある
        - 特に、「結果を固定した時、実際にあり得るか（もっと有利になってしまうのでは）」と言う時、上の言い換えをすればそのようなややこしい議論を消せる
## 解けるケースへの帰着
- あるケースなら解けるという時、答えが変化しない範囲で他のケースを言い換えることによって帰着できる
    - 単位元的なものをaddすると良い

## 文字を数字で言い換える
数学の上で扱える
- 一般に、文字より数学の方が扱いやすい
    - 式変形
    - 貪欲
    - 寄与の分解
## 数列 <-> 差分列、累積和列、店頭数列
- 命題: 数列上で見ると手がつけられない程複雑だが、差分列や累積和列に置き換えると単純になる操作が存在する
    - 列の短い部分列に対する操作は典型
    - こう言った場合、まず言い換えないとどうも手が出ないことが多い
- よって、数列上でのよくわからない操作（特に上記を満たす操作）が与えられたら、累積和列や差分列上での振る舞いを考える

## 例
- 隣に移動 -> x'i ＝ xi - i　の変換によって、同じ場所に移動
- 言い換えた後の問題の対応がわからない時: 元の座標で考えた後、結果だけを座標変換で移せばわかりやすい
   
<br><br>


<br><br>

## 転倒数
寄与の分解の仕方が複数ある。
- 数列の転倒数
- 全ての2要素単位での分解
- 全ての要素について、その要素が持つ転倒数を考える（転倒数列)
    - [例題](https://atcoder.jp/contests/arc181/tasks/arc181_d)


- 転倒数と順列は1:1対応しない
    - N! vs N^2ぐらい

- かつ、転倒数は距離のように扱えない
    - d(A, B) = d(A, C) + d(C, B)が一般には成立しない
    - [例題](https://atcoder.jp/contests/arc043/tasks/arc043_c)
        - A, Bがあるので、 d(A, C) == d(B, C)を可能なら作って
        - Aを{0, 1, 2,....}にしてしまって構わない（言い換え）
        - あとはそれっぽいのがok
        - 数列の変化を実際にせずに趣味レーションする方法を考える
<br><br>


### 言い換えが問題を難しくする場合もあり、後戻りも必要
- 言い換えを忘れて、もう一度考え直す姿勢が必要な場合もある
    - 条件は簡潔になっても、操作が複雑になってしまう...
    - ただしある程度の模索は必要で、やることがなくなったぐらいで戻ると良い(15分は長いだろう)
    - [単調増加->差分列...操作が複雑になってしまった](https://atcoder.jp/contests/arc185/tasks/arc185_b)
        - 差分列に言い換えると、 +1 -2 +1 して all >= 0 にしろ
        - この問題に集中しよう
        - 必要条件、端から、貪欲...
            - 解けない
        - 戻ろう
        - 元の問題に集中しよう
        - 貪欲(左端から)とかどう？
    

### クエリで情報を復元する問題
- 一部の情報がわかったら、その情報をクエリに盛り込むことで、今までよりも強力な情報を引き出せることがある
    - 特に、最小値や最大値がわかったときなど

- 必要な事: クエリ系問題/何かが明らかになったとき
- いつ考える: 常に
    - [1が分かる -> 単純な大小比較ができるようになる](https://atcoder.jp/contests/arc154/tasks/arc154_d)


<br><br>

# 実験
## サンプルが欲しくなったとき
手でやるよりも機械の方が漏れがない。かつ、そんなに時間が変わらない。
## 言い換えたとき
問題を言い換えたとき、言い換え先で元の構造がどの様に反映されるかは、機械でたくさん列挙して見た方が早い・漏れがない



## 入力が少ない -> 実験エスパー
- しやすい
- 手が出ない問題にも有効
- グランディ数が典型

<br><br>


# 数列への値の振り分け

## 最適化
振り分けのコストが単調増加なら、安い方から貪欲で良い
- それで、安い方からk個取るを達成できる

## 数え上げ

### 素因数の振り分け
数列の総積を考える時、約数ではなく素因数まで分解すると、素因数を振り分ける問題になる（かつ、素因数ごとに独立になる)

### 組み合わせ的な振り分け
- 振り分ける対象に対称性があるなら、コンビネーションに落とせるかも
    - dp[iまで][cこ振り分けた]からオーダーが2つ落ちる
    - [例題](https://atcoder.jp/contests/arc102/tasks/arc102_c)


<br><br>

# グラフ
### https://hackmd.io/rLxLpW94TBOsPhy2XDdGtA

扱うのが得意な構造:
[1]2要素の関係
 - 2項方程式についても、グラフで表現することができる。
 - 2部グラフに出来ない⇔奇数長閉路が存在する

[2]状態の遷移
ともに、独立性を顕にし、かつ操作や遷移を辺として表現できる。
- 操作の最小回数

### 独立性を感じた時 : グラフでの図示

### 一般の木
根をつけて良い。
根付き木に関する概念を持ち込める。(先祖、部分木)

### DAGと木は違う

1 -> 2 -> 3
---------------->
のように、擬似的なサイクルができる
- 到達可能頂点の数え上げでコレが効いてくる(重複する)
### 木におけるまとまった頂点集合
根をつけて、部分木に対応させる。
自分の知っている知識を使える。他、木DP。

## 連結なら成立する、という状況の時
そのような状況について考えるとき、一般のグラフ上で考えるよりも、全域木を(損になる場合もあえて)取ってその上で考察した方が楽な場合が多々ある
- グラフに対する全探索は難しい
- 木DP!
    - 必要に応じて元の辺を復活させる
    - 全域木の取り方は任意。特に、定理の成立するものとしてdfs木がある。

## 取り敢えず全域木を取る
- 1: 端（葉）から順々に考える(構築していく)のでも上手くいくという時、全域木をとってから考えると上手く構築できる。
    - 特に、制約が「後から修正できるタイプ」の物（総和とかmodとか）だと、「部分木の結果を見て、根を調整する」のような手順で解ける場合がある

- 2: グラフの全てのパスの長さについて考察する時、あるいは、頂点を塗り分けるという時、全域木をとったのち各頂点について深さを求めておくと、その深さの値を用いて議論ができる場合がある
    - 例: 2部グラフ判定　深さ mod 2が異なる頂点を結んでいるかどうか？
    - 特に、ある頂点vを始点とするパスについて調べたい時、vを根として取る
 


## 木における2頂点u, v
u, vを引っ張って両端に持っていく。u-vパス上 or notに分かれる。
パスが一意であるという性質から発生する諸々を理解しやすい。
- 例: 頂点 i, j, kがこの順で並んでいるか？
    - ⇔パス(i, k)上にjがあるか？
    - ⇔ dist(i, k) == dist(i, j) + dist(j, k) (ここで、辺を引っ張る考察を用いた)

## 連結成分数
- 間にパスがある頂点を同一視する時、頂点の種類はいくつかという事
    - 頂点と状態は対応するので、頂点 -> 状態 の言い換えをするとわかりやすい時がある
- 或いは、到達可能という同値関係で頂点を割った時の商集合のサイズ
    - よって、 u,vに辺がある条件より、u -> vに到達可能な条件の方が近い
    - 連結成分数計算の1個の解法として、 $\forall v \in V,$ $v$ から辿り着ける頂点の数 の分布がわかれば、(無向グラフで到達可能は⇔関係だったので) それから上の式で寄与をまとめて計算できる
        - 完全グラフの時の頂点のキヨ: 辿り着ける頂点数(自分を含む) を $c$ として、 $-\frac {c-1}{c}$ のキヨ（たしあわせてnから引く）

- u, vに直接辺がある条件を考えそのグラフ上で連結成分数を(uf等シミュレーション的な解法・その構造の考察から）考えても求まる
    - グラフそのものに良い構造があるときは、そっちを使う
    - 超頂点も使う
        - 常にまとまって辺を張られる => 1本以上辺があるとき、先にまとめた頂点に張るとして良い
        
- 積極的にキヨに分解したい


    
### 頂点を陽に持たないグラフ
https://atcoder.jp/contests/abc361/tasks/abc361_g

### 到達できるか
多始点1終点ならば、1始点多終点にした方が良い。
- 無向グラフにおいて、到達可能性は同値関係である。そして、1始点多終点は計算量が良い。

#### 頂点に値が付与されている。ある辺uvについて、max(a[u], a[v]) = k
a[u] <= k, a[v] <= k かつ a[u] == k または a[v] == k
とすると扱いやすい事があった。特に、どちらもkを上回ってはいけないという事がより自明に。

## 同じ属性を持つ任意の2点への辺
- 属性を頂点にすることで、へんの本数を減らせる場合がある
    - 頂点と辺が入れ替わることもある

- 頻出: y座標を表す頂点とx座標を表す頂点で2部グラフ
   

## dfsの計算量
> 命題: dfsの計算量は O(V + E)
### 頂点を増やす時の計算量
> 命題: 頂点を増やすと辺も増える
- 頂点数が抑えられるからと言って満足してはいけない。特に、普通辺の方が多い
- 頂点を $k$ 倍したら、辺も最悪で $k$ 倍になる

### 橋
- サイクルに含まれる⇔橋では無い
- 同じ辺を使えないパスを考えるとき
    - パスが端を含む⇔辺素なパスは1種

## 複雑なsort/トポロジカルsort
全順序ではないが、「aよりbは前」のような制約がたくさんある状態で制約に違反しないように並べ替えたい時はトポロジカルsortする
- 閉路があるとダメ
- なお、トポロジカルsortの数え上げは、一般には難しい
- 隣接項にしか制約が無いとかだと2乗時間

## 最短距離
- 命題: 1 -> n の 頂点v を通る時の最短距離は、 1 -> vの最短距離 + v -> n の最短距離
- 命題: 1 -> n の 辺 u -> v を通る時の最短距離は 1 -> uの最短距離 + v -> n の最短距離 + u -> v の辺の重み
    - 最短距離の独立性
    - [有向グラフで、1辺向きをflipする時のmindist]
        - u -> v を v -> u とする
        - 1: uを通らない時
            - uを削除した元のグラフ上での最短距離
        - 2: uを通る時
            - uを通るのは1回で良い。uから出る辺を削除したグラフ上での最短距離を用いて話すと
                - 2-1: v -> uを用いないでに入る時
                    - uから出る辺を削除したグラフでの 0 -> u
                - 2-2: v -> u を用いる時
                    - 同じグラフでの 0 -> v の距離

# 全域木
## 最小全域木
> 命題: 重み最小の辺は使って良い

- 使うことを決めたら頂点を縮約(つまり、連結なものを結ぶ辺は無視)と言うアリゴリズムが正当

## 最小最大重み全域木
- 定義: 重みmaxの辺の重みが最小
> 命題: 重み最小の辺は使って良い

- 同じアルゴリズムで得られる


## 最短経路木
- 定義: 頂点vを根とした時、v -> any への元のグラフでの最短距離を維持した全域木
> 命題: 存在する
- 閉路がある限り終わりを切る
- dijkstraで辺を残していって求まる


## 最短経路木(経路 = 重みmaxの辺)
- 定義: (u, v) について、経路コスト = $\min_{全てのu->vパス}(\max(パス中の辺の重み))$
とした時、全ての (u, v) について元のグラフでの経路コストを維持した全域木

> 命題: 存在する

- 構成
> 補題: その様な全域木が存在するならば、元のグラフで重みminの辺集合は閉路ができない限り使う必要がある
あとは縮約すれば良い(重みが増加するのでして良い)
1. 辺重みがminの辺を採用
2. 縮約して1に戻る
- を連結になるまでやる

## 次数が小さいグラフ
- 無向グラフ
![alt text](<images/NBMetadataCache.jpeg>)

- 有向グラフ
![alt text](<images/NBMetadataCache 2.jpeg>)
## フロー
psp(頂点2つの選択肢、最適化)
辺cut, 頂点cut

- 特定の要素をなるべく使わないflowを流したい時
    - s -> その要素　の辺を外したflowと付けたflowで2回やると良い？

- [他とペアにしても良いし、自分でペアにしても良い](https://atcoder.jp/contests/abc263/tasks/abc263_g)
    - 貪欲...「異なる種同士のみでのペアを考えた時、ペアの個数が同じなら、自分でもペアにできる奴が最大個数残った方が良い」
        - 1をなるべく使わないflowを上の方法で得るとなんか通る
        - 凸だから3分探索に落ちるらしい(yet AC)

## フローがあるなら貪欲がある
- らしい
- グラフを構築 -> そこから発想
    - 特に, maxflowならグラフが改善していく様子を、わざわざ探索せずにやる
        - maxflowなら頂点増やして再度流す、が許される    
## グラフアルゴリズム・頂点/辺の削減
ベースアイデア: 2要素間に辺を愚直に貼らずに、代表的を表す頂点を作って、 (辺を出す側の集合) -> (代表頂点) -> (辺が入る側の集合)
とすることで、辺の本数を(要素)^2から(要素)ぐらいにする。

- 必要なこと: 変形したグラフを用いても答えが変わらない事
    - もとの問題でその辺が表すべきだった状況が、変更後のグラフでも表せていれば良い
        - [前後関係: sからtに向かうパスを表せば良い](https://atcoder.jp/contests/abc277/tasks/abc277_f)
            - 1,2,2,2,2,3,3,3,3,4,4,4,4,4,5,5...のような数列を、数の大小に基づいてトポロジカルソートすることを考える
                - 普通のsortでは問題が解けない(並列に条件を追加するので)
            - 大きさが隣り合う数字にだけ貼るとしても、^2本の辺ができる
            - (値2) -> (代表) -> (値3)のようにすることを考える
            - 元の辺で表したかった状況がコレでも表されているので、この通りに貼れば良い
                - 答えが変わらないことの確認: 存在するなら、代表をそのまま2と3の間の任意の位置に置けば良い。
                - 代表の頂点を値ごとに使い回したりすると正当性が怪しくなるので注意

### 行、列を表す頂点+s, tだけを作って、flow問題をその上で表すやつ
計算量が落ちる
- [同じ行・列なら移動できる <-> 行hの頂点と列wの頂点を無向辺で結ぶ](https://atcoder.jp/contests/arc074/tasks/arc074_d)
### クリーク⇔補グラフ典型
くりーくである　⇔ 補グラフで独立集合
及び、
2部グラフ:= 独立集合2つに分離できるか
より、問題を二部グラフに落とせたりする
- [例題](https://atcoder.jp/contests/arc099/tasks/arc099_c)
- [例題](https://atcoder.jp/contests/agc067/tasks/agc067_a)

<br>

## psp(maxflowで解ける)
- 必要な事
    - 2値の割り当て
    - 2要素の制約/ all要素がooの時... 
- いつ考える
    - 最適化・判定
    - 要素が絡み合っていて、dp出来なさそう
    - 2値の割り当て
        - 使用する・しないもこれに含むので、結構広い

- [カメラのon/off](https://atcoder.jp/contests/abc274/tasks/abc274_g)
    - カメラはみぎor下として良い
    - ますごとに見ていくdpだと、「実は前もって埋められていた」がきつい
        - 独立性もなくて、横を前に決めるとしても結局同じ事
    - 全てのますについて、一番近いカメラ2つ組のon/offで制約を表せる
        - そのままだと「全て0/1なら失う」になって解けないが、横向き同士・縦向きどうしには辺がない(=二部グラフなので),横向きを反転するととける
- [黒or白。pspを使うために、二部グラフで01を反転](https://atcoder.jp/contests/abc193/tasks/abc193_f)

## mcf
「使用回数」に制限がある要素があって、その要素の使用でスコアが得られ、そのスコアをmin(maximize)したい時
- [同じ属性の人は被ってはいけない/同じ得意科目の人は被ってはないけない](https://atcoder.jp/contests/abc247/tasks/abc247_g)
    - 辺のコストをマイナスにする事でminimizeで問題に対応する
<br><br>

# マッチング
$E' \subset E$ であって、 $E'$ の誘導グラフの最大次数が $1$ であるもの
## 完全マッチング
$E' \subset E$ であって、 $E'$ の誘導グラフの頂点集合 $V'$ が $V' = V$ を満たすもの


これによって、例えば「全ての要素を、制約を満たしつつ何かとペアにする」と言った問題設定は、単に「制約を満たす完全マッチングを作る」の様なグラフ理論の言葉で表すことができる


## ホールの結婚定理
$2$ 部グラフ $G$ が完全マッチングを持つ必要十分条件が $1$ つ知られており、ホールの結婚定理と呼ばれる


## 最適なマッチング
> 命題: 直ちにマッチングさせて良いものが $1$ つ以上ある時、それをマッチングすることを繰り返して最適なマッチングが得られる


- マッチングの貪欲の証明は、最適解をおいて相手をswapすることが多い
<br><br>

# 木
## 性質
> 命題: 木の誘導グラフは森
- 連結成分数 = 1なら再び木

> 命題: パス長 <= 2 * 深さ
- 木の高ささえ低ければパスクエリは高速に捌ける。しかし、木の高さを恣意的に変更する術は一般には無い
    - auuxiliary treeが一応それだが...

> 命題: 連結成分数 = |V| - |E|
- 木であれば、頂点の個数と辺の本数がそれぞれ分かれば連結成分数がわかる
## 木DP
- 木についての全探索
- 全ての頂点についての値を求めるのではなく、「全ての部分木についての結果」を求めている
    - 木全体の結果は手に入る
    - 頂点同士が互いに制約を与え合うという時、木全体についての制約の結果を求められる
        - 全ての頂点については求めることはできない
        - 全方位にすれば良い
        - [頂点同士が制約を及ぼしあう時、木全体として満たす構築があるかを木dpで判定](https://atcoder.jp/contests/arc063/tasks/arc063_c)
            - 頂点について、取って良い値は区間になる
            - 隣り合う頂点同士が影響し合あう
            - 全体として満たすものはあるか？
            - 木DPすればわかる
            - わかったら、根からやっていくことで、それぞれの部分木についてもさっき求めた情報+追加の情報から求められる

- 必要な事: dpテーブルがそれで回る事。
    - 往々にして、「状況が部分木間である程度独立」であると、マージが簡潔に書けてできやすい。
- いつ考える: 木で全探索を考える時。つまり、積極的に・いつも。

> 命題: 部分木ごとに独立な問題になる場合、木dpで再帰的に値を求められる
- 部分木の値はどこでも良い
> 命題: 部分木ごとに関係性がある場合も、その関係性の決定に必要な情報を持ってdpすることで再帰的に求められる
- 関係性の近い列のdpのようなもの
## 木DPの設計
### 部分森を管理する
https://atcoder.jp/contests/abc351/editorial/9868
辺に重みがある時にやりやすいと思う
しかし、根がたくさん発生するので、普通考えづらいと思う

### よくある
![alt](<images/IMG_0056 .jpeg>)
根が常に2つ（高い根、低い根）しかなくて、これをよくやる
- 今までの部分木・新たにつける部分木の状態を場合分けして、dpテーブルを作る
    - 往々にして、「高い根の状態」と「新たにつける、低い根」の状態を全探索して、そこから次のテーブルを作る


## 2乗の木DP
木dpのテーブルのマージにおいて、サイズ $n$ と $m$ をマージする際
- $O(nm)$ ... $O(|V^2|)$
- $O((n + m)m)$ ... $O(|V^3|)$
である。
    - よって、下記の書き方をしてはいけない。特に、マージ後のテーブルのサイズが $n + m$ になると言う時、それ + テーブル $m$ を走査すると下記の計算量になる。
    - ほとんどの場合、 $n$ 通りの何かと $m$ 通りの何かを全探索すれば事足りる。よって、そのような書き方をする。
        - [結果を固定しなくても、マージ前でそれぞれ固定すれば結果が固定される](https://atcoder.jp/contests/arc130/tasks/arc130_d)

### 木に辺が増えていく時
mergeテク

### 木dpで、mergeの計算量が「小さい方の部分木のsiz」
mergeテク

#### dpで、mergeの計算量がsiz * siz
愚直にやってもN^2

### 木の頂点が色や値によって独立に分類されている時
圧縮木
https://atcoder.jp/contests/abc359/tasks/abc359_g
https://atcoder.jp/contests/abc340/tasks/abc340_g


### 部分木に対する操作・制約
- オイラーツアーすることによって、数列の連続部分列に対する制約に言い換え
- 他の事柄も言い換えられれば、あとは数列に対する問題に
    - 基本的に、楽になる
    - [例題](https://atcoder.jp/contests/kupc2018/tasks/kupc2018_m)

    - 楽にならない場合もある
        - [例題](https://www.codechef.com/START150A)
            - 列に還元した問題すら解けない
            - 木に戻る
            - 部分木制約だけなら解けるので...補部分木の制約を、何かを固定することで無視したい

### パスの数え上げ
- 頂点vをlcaとするパス、で木dp
- 頂点vを通るパス、で重心分解
- 条件を言い換えて別に帰着


- [例題](https://atcoder.jp/contests/arc045/tasks/arc045_c)
    - 頂点vをlcaとするパス、で良い
        - ｖから伸びるパスを記録する
        - マージに時間がかかりそう-> マージテクで良い

## 2頂点を端に引っ張る考察
見やすくなる

- [直径を端に引っ張った時のグラフの形の制約](https://atcoder.jp/contests/agc005/tasks/agc005_c)
    - maxは2つあるとして良い
    - 直径を端に引っ張ったグラフをみよう
    - 存在して良い距離の範囲と、そのほとんどがいくらでもあって良いことがわかる

## root -> v の情報(for all v), 差分更新
- dfsするだけ
    - 差分更新的にできて、複雑なクエリもできる

## staticな木に対するクエリ
- 逆元があれば、 query(u, v) = query(root, u) + query(root, v) - 2 * query(root, lca(u, v))


## 列上のパス
> 命題: 始点と終点を固定すると、左移動の距離 - 右移動の距離 が定まる
<br><br>


# 数列の連続部分列
積極的に累積和/差分列の問題へ言い換える
- 一様ならば: 2要素への何かになる
    - 一般に、n要素より計算量が落ちやすい
            - [例題](https://atcoder.jp/contests/abc365/tasks/abc365_e)
        - 2要素への操作はグラフに言い換える典型
    - 言い換える時は、ちゃんと問題が丸ごと言い変えられる必要がある

- 生で見るより、言い換えた方が見通しが良くなる問題は確実にある
    - [例題](https://atcoder.jp/contests/arc129/tasks/arc129_d)


### 連続部分列に関する制約
- 左から決めていくdp
    - [0, r]に収まる制約を全て満たすような...
        - 違反する可能性があるのが、[?, r]しかないような場合
        -
- 区間dp
    - [l, r]に収まる制約を全て満たすような...
        - ある特徴的な要素の位置を決めると、そこを跨ぐ制約が全て無視できる場合
### 連続部分列へのクエリ
分割統治的な解法で解くことで、セグ木に乗せられる場合がある。
l = 1, r = nを分割統治で解くと良いだろう

### 数列の区間

#### 「区間が交わる」条件より、「区間が交わらない」条件の方が簡潔
 - 特に、関係は一意なので、右側 or 左側のどちらかに注目すれば良い
 - https://atcoder.jp/contests/abc355/tasks/abc355_d

### 区間 ⇔ 2d平面の言い換え
データ構造の利用・平面操作の利用を期待できる。
理由 : 区間(に限らず2値で大小関係が重要なもの)を、2次元平面上の問題に落とすことで、次元が増える代わりに問題が簡略化される。

#### 全ての区間についての計算
dp[r] := 右端 = rの区間についての答え (注 : [1, r]に収まる、でも良いが、単にこちらの方が制約が増える)
とするdpが成立しやすい
    - 理由 : 区間の計算について、どこかで"切って"考えて良い場合は、昔の結果を利用するという意味で上のdpが成立することが多い https://atcoder.jp/contests/arc169
    
<br><br>

# 順番に寄らない
好きな順番で決定できる。よって、dpと相性が良い。疑うべき。

   - 違反するような部分が無くなるように数列に操作...左から、「これより左に違反部分はなくて、かつ末尾の状態がSTATEのうち、操作回数が最小」等 P329
   - 交わる部分が無いように、数列を分割...前から分割を決めていく
   - 集合に0/1を割り振る ... 前の要素から0/1を決めていく

# 順番が一意にさだまる
sortして、前の方から決めていくdpができる。
- 影響が数式で簡潔に書けそうな時

- [例題](https://atcoder.jp/contests/abc366/tasks/abc366_f)
- [例題](https://atcoder.jp/contests/arc053/tasks/arc053_c)
    - Ai - Biの符号と Aj - Bjの符号で、議論が変化する
    - よって、混じったsortは無理そう
    - しかし、Ai - Biについて、符号が違うやつは混ざらないことが言える
<br><br>

#### 操作によって要素が独立になる
どんどん問題を小さく&&独立にしていける。dpと相性が良い。
また、独立性という観点から、グラフとも相性が良い。

#### 操作をすること自体にもコストが発生する
言い換え : [1]どの要素に操作をするか [2]どれだけ操作をするか
の2つを決めると思う。すると、構造がすっきりする。

<br><br>


# 単調増加
- 命題: Aが単調増加 ⇔ 差分列の要素が全て0以上
    - 他の条件も言い換えられるなら、問題が単純になる場合が多い
        - [例題](https://atcoder.jp/contests/arc023/tasks/arc023_3)
- 命題: 極値が存在しない ⇔ 単調減少 or 単調増加


## 区間についての単調性
- 命題: 尺取り法・二分探索ができる
    - 差分更新ができる時 / 区間クエリが独立に高速に求まる時
- 命題: 単調より、$\forall l$, 条件を満たす最小の$r$ のテーブルが求まれば、任意の [l, r]についてのクエリの情報が得られる
    - 系: 区間クエリに独立に答えられない時、尺取り法によってこのテーブルを前計算すれば任意の区間クエリが $O(1)$


### 等差数列
- 同様に扱いづらい
- 差分列を取ると、条件が"全ての要素が等しい"になる
- 及び、3項の場合
    - $x \le y \le z$について、 $z - y = y - x$
    - を
    - $2y = x + z$
    - や
    - $2y - x - z = 0$
    - のように、$y$が片方にしか登場しない形にした方が良い場合がある
    - 一般に、条件に含まれる = が一つなら、両辺に同じ文字が登場するよりまとめた方が単純？
    - [例題](https://atcoder.jp/contests/arc145/tasks/arc145_d/editorial)
        - 任意のx, y, zについて 2y != x + z
            - x < y< zを課さない方が考えやすい&&課さなくても良い
        - 2倍したやつが一致しない...
        - 3進数で0/1のみ

<br><br>


# 辞書順最小・先頭から貪欲
## 一般の枠組み
- 採用できる母集合を求める
- その中で最小のものを求める
    - 採用できる母集合を厳密に求めるのが難しい時: より広い集合をとって、小さい方から「採用できるか？」の判定問題を解く
- 値としてそれを採用する
- 値としてそれを採用する中で、まだ残っている自由度・それを採用する上での操作の自由度を整理する
- 制約にその自由度を加算した上で、次に進む...


- よくある勘違い: なんらかの制約によって、ある桁について見る時、あり得える母集団のうち最小値がとれない時
    - 最小値が取れないからといって、その桁を無視して良いわけでは無い。取れる値のうち最小値を取らなければならない
    - つまり、あり得る母集団のうちminする事が叶わないなら、2番目にする、3番目にする...としなければならない
    - 一般に、ある桁について、一意で無いならば、"無視して良い"と言える状況は少ないだろう

- 一般の枠組みを上に書いたが、一番難しいのは「1番目を小さくする上で2番目を最小に、その上で3番目を...」の制約が積み重なっていくところの処理
    - 2番目を最小に、その上で3番目...と、近い繋がりで全体が関係しているタイプ
    - よって、i番目の決定の際に、全体を考えなくても「i+1の番号の答えを決定するのに必要な情報」を持って探索・遷移しても良い
        - 結局うまくまとまらない場合もあるだろうが


## 桁dp


### 桁数を固定して探索する時、leading 0を認めない方が良い
認めてなんやかんやしようとすると頭がばくはつ
- 桁数の定義を変更する必要
<br><br>

### 操作の復元・構築
 - 結果のうち、極端な物を見る
     - そこに関与する部分の操作が一意に決まり、それによってまた"極端な物"が生まれる可能性
     - グリッドなら左上等
     
     
## sortする
言い換え :転倒数を0にする

<br><br>

# 転倒数
> 定義: 数列Aに対し、転倒数d(A) を $(i, j)$ のペアであって、$i < j$ かつ $A[i] >A[j]$ を満たすものの個数とする

> 命題: 数列 $A$ を隣接swapを繰り返してsortする時の最小のswap回数は $d(A)$

> 系: 数列 $A$ の各要素の並び替え $B$ について、 $A \to B$ に隣接swapを繰り返して変化させる時の最小回数も求められる

> 命題: 数列 $A$ にswapをした時の転倒数変化は奇数

転倒数は 
1. 各要素ごとの寄与に分解
2. 全てのペアごとの寄与に分解

の2通りの分解がある(2が都合が良いこともある)
<br><br>

# k番目の値を求める

- dpしながら: topKを保持しつつ、配るdpではなく貰うdpで計算することでオーダーレベルで高速に計算できる
    - $O(KV\log K + V ^ 2)$

- shortest kth path(not DAG) : https://qiita.com/nariaki3551/items/821dc6ffdc552d3d5f22
    - $O(KV((E + V)logV)) or V^2ダイクストラで O(KV^3)らしい$

- kth takoyaki : 今順位が決定している集合と、それを一段回だけ悪化させたものを持って貪欲に決定していく。https://atcoder.jp/contests/abc297/tasks/abc297_e 


- 桁dp : 上の方の桁から決めていく

### 辞書順k番目
- 先頭から数字を決めていく。
    - 必要なこと:「prefixがoooである様な要素は何個存在するか？」を解くことになる。後ろが空文字列、つまり打ち切りという遷移が常にあり得ることに注意。
    - よって、これがすぐにはもとまらない場合、別途dpして求める等の必要性が出てくる
    

## 0 ~ k番目について列挙/計算...
> 命題: k番目の値が $x$ がわかれば、問題は 「値が $x$ 未満のものについて」 + 「値が $x$ のうち、kに届くまでについて」に分解される
- 後者は簡単なはず
- よって、[0, k]全てを調べるタイプでも
1. k番目の値を求める (この時、二分探索で行うならば値x未満のものについて調べる過程を経るはず)
2. 値 x 未満のものについて調べる (1 で使ったものを流用できる可能性が高い)
- と言うアルゴリズムができる
- 特に、2で用いるものは1でも用いるのだから、単にk番目を求める時と然程変わらない可能性が高い

## k番目までを列挙する
> 良い構造: $f(i, j)$ について、 $f(i, j) \le f(i+1, j), f(i, j+1)$
- これを満たす時、小さい値から列挙することを考える。すると、$f(i, j)$ を考えるのは $f(i-1, j)$ または $f(i, j-1)$ が列挙された後で良い
    - 列挙する時に調べる個数が $k$ の定数倍になる

> 系: n個の集合の和集合からtopkを求める場合、 $f(i, j)$ := 集合 $i$ で $j$ 番目の要素$ とすると、 $f(i, j) < f(i, j + 1)$ が成立することから、 O(n + k) この列挙で topk が求まる
<br><br>

# 重複

### 重複に気づく為に
思い出す: dpが満たすべき条件
-  (重複を許さないならば)1つの探索対象が、dp重複して探索されないこと
    - ⇔任意の探索対象について、探索の任意の段階において、2つ以上の状態へと分かれて遷移することがない
        - 気づき方: 重複しやすそうな探索対象を一つとって、手でdpしてみる
            - ポイント: 具体例を持ってきて、実際に判定する姿勢
            - 例: (1, 2)を、要素数1の集合に分解した集合族の個数は？
            - dpで一つずつ集合に分解すると、 ((1), (2)) において、 $\emptyset$ -> (1)/(2) となり、最初の遷移で2つに分かれるためダメ


- 同じ数え上げ対象が、2つ以上の状態を持たないか
    - dpで持つ状態を増やすとなりがち
    - 特に、操作列の数え上げでは無く、数列の数え上げですという時
 

### 数え上げ: 重複なく数え上げる
これら全て、重複を省く: 1回だけ数えるというモチベの元の案である

- 重複がない <-> 全ての探索対象が、探索の各段階においてちょうど1つの状態に当てはまる
           <-> 全ての探索対象が、1回も分岐せずに最後まで探索される
    - 2つめを意識すると照明が楽なことが多い

- 考察 : **数え上げる対象 or notはどうやって判定するか？**
dpを考える時に基本的な考え方。基本的に、判定の過程で同じものが分岐することによって、重複は起こる.
    - つまり、分岐さえなくせれば良い
    - 分岐がないような判定方法をdpとする...
        - 部分文字列: 先頭から貪欲に採用する
    - 可能性を全て情報とするdpをする...
        - NFA -> DFAみたいな
        - 状態の集合を状態とする
            - [例題](https://atcoder.jp/contests/arc058/tasks/arc058_c)
            
- 一旦全てを区別するものとして数え上げながら、要所要所で掛けて区別しない場合に還元する
    - 集合の数え上げなど
    - 係数をかけられる必要がある
            
- 考察 : どういう時に異なるか?/どういう時に重複が発生してしまうか？
重複特有の考え方
    - **"異なる操作"を1stepとするdpを立てる**
        - 例: 選んでいくdpなら、
        - dp[i][State]...iまでみて...から
        - dp[i][State]...最後にiを選んで変化させた。State
        - にして、次に変化させるまで飛ばす（間で変化しない選択を何回なするかもしれない)
        - この時、遷移では"遷移で0回/2回以上変化する"遷移を許してはいけない。**数え上げるdpは常に最小単位で遷移しなければならない**。
            - 最適化は重複しても良いので、2回以上遷移しても良い(しかし、最小単位に満たないやつは事故りやすい)
        
    - 重複の方を数える
        - 部分文字列の種類数...SA + LCA
    
- **重複が発生しないようなルールを作る**
    - 数え上げる対象を具体的に一つとって、それが一意に・1回だけ数えられるようにdpの遷移を制限する
    - 必要な事: 各数え上げ対象が、dpの遷移のそれぞれの段階においてちょうど1回含まれる事
        - 逆に、これが満たされていれば他に懸念することはない
    - いつ考える: これも重複を省くスタンダードな方法の1つ
      
- 考察 : **数え上げの対象になるのは何か(視線を数え上げ対象に移す)
    - 判定問題になり、重複は最早関係ない
    - 数え上げの一般的なテクでもある

- 2つの集合から重複を省く : 母集団が大きい方を含め、小さい方から排除する方が楽
https://atcoder.jp/contests/abc361/tasks/abc361_f

### 否定と重複の関係
- 1箇所以上でooを満たす、を数え上げる際に「全く満たさない」を数え上げても良い
    - 1箇所以上の判定では、複数箇所満たす場所があった際に、素直なdpでは分岐してしまう恐れ
    - 全く満たさないならば、満たしたらoutを守るだけでおk


- tips:集合二分割していくdp
- 終わりを見ればわかる通り、集合の数だけ「切り出し方」に自由度があって重複しやすい
- 係数を途中でかけて調整も難しい
    - 個数ごとに切り分けるとしても調和級数logがかかる
    - 個数に制限ない時、最後に修正も無理
- 一意に分割するルールを決めた方が無難
<br><br>

### 操作: 同じ操作を2回しては行けない
- 集合を決めるdp

#### 同じ位置に2回操作をしてはいけない
- 極端な場所からやる
    - 区間について、左からやる事で lについて独立が保証される

### [0, r]を全て作れ
n進数(特に、2進数)
発展 : [0, r]を一意... 簡略化: rが2冪 - 1をまず考える。 解法例 : 表せない分は下駄を履かせた上で[0, r2]に帰着
発展 : [l, r]を作れ...[0, r - l]に簡略化


## 集合の数え上げ⇔数列の数え上げ
- 集合の数え上げをする時,
    -  並べ替えを全て数える
        - 並べ替えで条件の違反の可否が変化するものでもなければ、普通全て数えられる
    -  後から並べ替えの通りで割る
- という条件さえ守れば、数列を数え上げるとして良い
- 探索的に解くと集合に重複が発生してしまうという時、それを解消出来る
- 特に、集合の数え上げだからといって、小さい要素からadd/notを決めていくという事をしなくても良くなったりする
- [例題](https://atcoder.jp/contests/arc146/tasks/arc146_c)

<br><br>

# 小さい・極端な値の制約
- 小さいサイズの例では、小さい値の働きが良くわからない
    - 高速化も見え辛い
    - 小さい制約が出た時は、大きなサイズの例で考える
## その値を軸にした探索
- その値の1変化を軸とした時、探索はどのように記述されるか
- 状態数が小さい事は保証されているので、これが意味を持っていると嬉しい
## その値についての全探索により、情報を得る
- 答えのあり得る値が少ない時、あり得るか？を全探索...
- プレイヤーについて直接確率を求めるのが難しい時、盤面についてbitdpで確率を求めてから人について確率を求める...
- グラフのマスの個数が少ない時、それ、あるいは頂点のペアをkeyにして何かを計算する...

## keyとvalueのswap
- dpの値として入れる要素について、keyと比べてかなり大きくても良い。
- よって、小さい値をkeyに持ってきて、残りをvalueに入れると高速化になる


### 制約の列挙
意味のある制約だけを抜き出そうとせず、列挙してしまうと楽


#### 小さい値のキーについて、"意味のある分だけ一気に遷移する"ようなdpは悪手がち
- 別に、一気に遷移させる旨みがない
- dpが複雑になり、他の部分の高速化が見えずらい
- 問題の構造も見え辛くなる
[url](https://onlinejudge.u-aizu.ac.jp/problems/0537)



### max/min 
一般のk番目と比べ、場合分け的な発想により高速に求まる場合が多い

### 2, 3番目
max/2/3番目を全て管理することによって求める

### 全体・集合への条件
各2要素への条件に分割して、グラフアルゴリズム
    - 「辺で結ばれていたらng」...最大独立集合
    - 「0 / 1割り当て・罰金や報酬」...燃やす埋める
    
### 条件を満たす小さい集合の最大サイズ・合計スコア
答えの集合を全探索・半分全探索
  - 条件が「満たさないなら入れてはいけない」の時、集合の条件を2要素間の条件に言い換えられたらば、最大独立集合
  - 条件が「入れても良いが、入れたら罰金」みたいな時、フロー・燃やす埋めるの可能性
#### 一般化せずに、列挙するような条件変形
例えば、「木において、間に1頂点しかない」という条件を考える。
 ・距離 = 2 ... 2という小さい値を活かせない 一般の距離を求めらんないときつい
 ・実際の位置関係...  じつは数通りしかない。よって、それらを全探索する。

### 小さい方・大きい方から選べる
- マージテク

- 合計が定められている数列において、相異なるQこのペアのminの和
    - distinctであることが重要
    - https://x.com/SSRS_cp/status/1819732406972404184
    

<br><br>

# 差分を更新する計算
- 必要なこと: 差分の更新が高速にできること
- いつ考える
    - 順々に何かの値を求めていく時
        - 差分を取る以上、複数種類のを何個も求める時に良い
    - 毎回のクエリを独立に捌くことは、前計算込みでもできそうにないが高速化したい時
        - 特に、差分の更新さえ高速であれば良い。
        - 二分探索 <-> 尺取り法
            - 集合の要素を全て保持したい時、毎回集合の要素を1から拾っては間に合わないが、差分は小さい（合計変化が抑えられる）など

- 区間内の集合管理は、区間について何らか単調性があれば計算量が抑えられることが多い。単調性がなくても、激しく境界が動かなければ。
- [grundy数の計算...パラメータをちょっと変えて計算していく<-差分更新](https://atcoder.jp/contests/abc278/tasks/abc278_g)
    - 毎回高速にやるのは（mexの中身を毎回構築するのでは）無理
        - mexの集合の変化を考えると、せいぜい2n個ずつしか変化しない
        - セグ木でシュミレーションすれば、差分を更新する手法で求まる

<br><br>


# シュミレーション/判定

## 長いシュミレーション
以下では、遷移が一意なシュミレーションに対する高速化の手段を述べる
- 単に、シュミレーションせよと言われた時...
- 貪欲によって、判定問題の遷移が一意になった時...
## ダブリングによる高速化
> 命題: 状態と遷移が与えられたとき、状態から伸びる遷移が1本だけ: 遷移が一意ならば、状態数 $\times$ log step でダブリングができる

- 遷移が一意でないとダメ
- 状態のテーブルサイズが大きすぎるとダメ

## 状態の抑え方
- keyとなるイベントを状態として、その間は頑張って計算する

- "似た状態"が繰り返される時、その遷移のテーブルからk回を辿れる
    - 特に、それはシュミレーションの最初の状態を含むと良い

## 「初めて条件を満たす」までの遷移
- 命題: 遷移条件を「遷移後も条件を満たさない」にして最後に+1の遷移を自分ですると上手くいく
    - 条件を満たした後に追加で遷移されると困る
    - +1しなくても条件を満たしているかもしれない
    - +1しても条件を満たさないかもしれない（から実際に+1の遷移を別実装して試さなきゃいけない）

## ループを利用したショートカット
- ループがある事が必要条件
- ループに入るまでの距離・ループの距離によっては、ループがあっても利用できない
- ループに入るまではどこまでか・どこからループでどこまでループなのか・の処理がやや面倒くさい
- しかし、これでしか解けないタイプのものもある（計算量の話ではない)
  


## 同じ遷移をまとめる高速化
> 命題: シミュレーションにおいて、
> - 遷移の種類が切り替わる回数が少ない
> - 同じ遷移をどこまでするかが高速に求められる 

> の2つが満たされれば、高速に結果を求められる

- 種類が切り替わる回数が少ない <- 切り替わるたびに何かの値が指数的に増えていくなど
- 同じ遷移をどこまでするか <- その遷移をする条件を式にしたとき、単調性が出れば二分探索できる

## シュミレーションを、数学的な値で表すことによる高速化
- 手順が与えられた時、結果を高速に求めろというのは難しい
- しかし、数学的な操作（和を取るとか、何かのsumがOOになるまでやるとか）で表せれば、高速化しやすい
    - 色を数字にするのはこの動機
    
## シュミレーションの特徴量を考える/前計算をすることによる高速化
- 愚直は自明なので、高速に求めましょうという時
    - いきなり解法について考える前に、前計算として有効なものを考える
    - シュミレーションで追うべき情報は何か
    - シュミレーションでロストしてしまって良い情報は何か？

## 何かの種類数が少ないシュミレーション
それを段階に全探索ができれば通る
たんｔちょう単調なうご動きをしているなか中でｚじょうｎん条件をみたすま満たすまで、をかんがえれ考えればよくな良くなりら楽

### 変化の回数が少ないシュミレーション
- 毎回求め直していては間に合わないという時、変化の回数が少ないならば、「今回変化するか？」をやる事で間に合う
  

## 途中まで単純な動きをするが、ある時点から変な動きをするシュミレーション

- 最初に変な動きになるのはいつか？が二分探索で求まりがち
    - 直前まで単純な動きをしていたと仮定した時、今変な動きに変化するか？の判定問題で二分探索


- 状態がまとまる...一つに扱える
    - 特に、まとまる条件に単調性がある時、「まとまる」をさらに「境界にある状態と同じ動きをするようになる」と言えたりする
        - これにより、状態が[1] 状態Xと同じ動きするやつ [2]最初から単純な動きしてるやつ の2つに分けられたりする
     
## 初期条件を決めたらシュミレーションの様子が一意に定まる
- 初期条件から結果を表せないか。特に、数式で表せないか。
- 取りうる結果の必要十分条件は？


## 動的に形を変化させるシミュレーションは遅いがち -> させなくてもなんとかなりがち
形を保ったまま重みの変更にで対処
- 例えば、木の辺が縮約される、配列がrotateされる...
- これらを素直にやると、大抵計算量が厳しくなる
- 実際にやらずに、必要な情報を得る方針で書くように努める


- 区間に対する何かしらの"変化"は、遅延セグ木で扱えがち
  
### 最適化

- 典型: 要素の並び順を決めたのち、シュミレーションに従って要素を振り分けていく...結果の集合を固定したら、大抵の場合その集合になるような並び順が存在する
    - https://atcoder.jp/contests/agc054/tasks/agc054_b
　　　　- https://icpc.iisf.or.jp/past-icpc/domestic2021/contest/all_ja.htmlの D
        - スライドする、と考えると結果を使えないので、消費スペースを区別する必要がある

## 無限に続くかもしれないシュミレーションの無限判定
- 大抵グラフのサイクル検出に落とす。ダブリングと同じで、状態の考察が重要。繰り返されるもの。
- 有向グラフ・サイクルがあるかもしれない...in[v]とout[v]を持つ。in[v]とout[v]の値で場合分け。
<br><br>

# 重実装・シミュレーション

- 書く前にサンプルを試す
    - 後から実装を膨らませないようにする
- 処理の共通化をする
    - 積極的に関数を作る
    - しかし、一つに統合できる関数は統合する(例 : add/delete )

- 枝分かれしないシュミレーションはwhile文で書ける
    - 速い
    
- クエリの重複
    - クエリごとに代表のクエリ番号とか付けるより、クエリそのものをkeyに答えを出して、それを後から還元した方が楽

- 長さを表す変数の値は変えない方が良い
    - [失敗例](https://atcoder.jp/contests/arc181/submissions/56364913)
-  処理に「中途半端な場合」と「纏めて処理する場合」の様に場合分けが生じる場合、「1stepだけ進める」処理を書いて、それの繰り返しで両方を表すことにすると処理が共通化される。


- 1回の処理で、どれだけシュミレーションを進めるか決定する

- 処理すべき対象：起こりうるイベントを列挙する
    - 1回の処理で、そのイベントが2回以上起こる場合をちゃんと処理する
        - 要素が直進する中で、要素がぶつかる... 2回以上一度にぶつかることは？

## 初期値が与えられるシュミレーション
- 初期値がノイズとなる場合がある
    - ある程度シュミレーションが進むと、ある動きに収束する
        - 初期値が極端な時は、それを補正するように動く
    - よって、シュミレーションの挙動を考える時、「ある程度シュミレーションが進むとどうなるか？」を考えると良い
   
- 必要な事: 初期値が与えられるシュミレーション
- いつ: とりあえず考えたら良いのではないか


### インタラクティブ
- やりがちなミス
```
//クエリ回数が残っている間クエリしよう

while(query_count < Q) {
   rep(i, 0, n) {
       query()
   }
}
```

- whileは、「条件が違反されたら処理の途中でもbreak」という関数ではない
- query関数の中に、回数でassert入れた方が良い
<br>

## ２次元平面シュミレーション

- 大座標、小座標を使い分ける。0-indexedで座標を扱う。

- x, yで処理を共通化したい←点集合を管理する構造体を作る
    - [例題](https://atcoder.jp/contests/abc130/tasks/abc130_f)

- HWのサイズを持ったらダメだが、頂点に関しての情報を持ちたい
    - info_x[y] := i = y の頂点についての集合
        - のように、x, yごとに持つので十分な場合がある
        - 十分なら、サイズが大抵間に合う
### 点が動く
- 右に動く/左に動く　ではなく、　速度が+1/ -1 とする
    - 処理の共通化
    
- 速度が設定されている場合、速度ごとに点集合を分類して管理する
    - 一つの集合内で注目すべき点が単純化されたりする

- 特定のイベントが起こる時間の集合を得たくなった時
    - 数学的に処理する
    - シュミレーションでの出来事に言い換える
        - x座標maxの傾きが変化する→速度が違う点のうち、xがそれぞれmaxのものがすれ違う

- 最適化: 特定のイベントが起こる場合（例: 値の傾きが変化する), そこで時間を区切り、各区間内での答えをそれぞれ求める
    - 動きが単調になる
        - 三分探索できる
        - 数学的に求まる
        - 端だけ調べれば十分である

## シュミレーションせずに結果を得る
- 問題を解いた時、シュミレーションに帰着される事はよくある
    - しかし当然、シュミレーションじゃ無い方が嬉しい
        - そも間に合わない場合
        - のち後のもんだいｎ問題へのおうよう応用がわからないとき
- そういう時、シュミレーションの動きが一意なことを利用して、けっか結果のあたい値をこうさつす考察する/こうそくにえ／こうそくにえる順々に結果を得るのが必要になったりする
    - [例題](https://atcoder.jp/contests/abc369/tasks/abc369_f)
        - 最も長い辺を採用して、その後、辺のコストを0にする
        - 順々に結果を求めたい
        - 木なので木dp
        - 上に伸びるのはせいぜい1頂点で、できる
    
    - [例題](https://atcoder.jp/contests/arc051/tasks/arc051_c)
        - 各要素に何回かけられるのか求めたい
        - まだ操作が一意でないので、適当に一意にする
            - 値タイなら、indexが小さい方を優先
            - Aiに操作がPi回行われたか？の判定を考える
                - いずれできる

## 計算が必要になるまで、計算を（損するかも知れなくても）保留する
- 計算すべきになった時だけ計算することで、計算の回数が減る。
    - 必要なところだけ抜き出すのと同じ発想。途中損しても、計算すべき所で補正すれば結果的に損しない。
    - [食べたら強くなる <- 食べられなくなるまで強くなるのを保留する](https://atcoder.jp/contests/arc189/tasks/arc189_d)
## x, yで独立になるように言い換える
- 2次元では不可能に見えても、1次元なら意外といけると言う問題は多い
- そう言う時、次元で独立に問題を分解できると解ける
    - 独立なことは結構ある・言い換えで独立にする
<br><br>

# 平方分割の手法

## 数列・クエリをブロックにしてまとめる平方分割
### 数列
- セグ木における、層状の構造が現れない
    - これがメリットになる処理があった気がする

<br><br>



## 解法を切り替える平方分割
### 2通りぐらいの解法を考える
- クエリ問題
    - [1] クエリ個々に対する解法
    - [2] クエリ全体を、与えられた情報を走査することで処理する解法
### オーダーが小さい値を見つける→それをキーにした全探索
- 例えば： 調べるべき要素数が $B$ より大きい人は $\frac{N}{B}$ 以下
    - その人全体をテーブルに持ちながら走査する
    - 全探索に近いので、割と色々求まる


<br><br>

### 桁和
- A + Bで、i桁目に繰り上がる⇔ i桁目未満の和が B ^ i 以上
- A + Bで、i桁目に繰り上がる⇔A[i] + B[i] + carry >= B
    - [例題](https://atcoder.jp/contests/arc130/tasks/arc130_c)
    - 先頭のリーディング0の扱いがめんどくさい
        - 長さが短い方を基準とすると楽
        - 実は、マッチング相手は貪欲で定まる時、使用する・しないも貪欲で良い
            -  使用しないとした時でも、上回ることはない
<br><br>

### 01割り当て
- dp
- 燃やす埋めるの表現力は高い
        - 特に、燃やす埋めるは2要素間の制約 && ある集合について、「1つ以上が 0 / 1の時罰金」⇔「全てが0 / 1である時, 賞与」を表せることから、グラフ上の01割り当てと相性が良い。https://codeforces.com/contest/1082/problem/G

### 01 / 2値の高速化は ｂitset
- 存在判定 : 分布を陽に持たず、bitsetで分布を管理
- 足し算: xorに対応　並列的なアルゴリズム

#### 部分文字列を含むような文字列の数え上げ
部分文字列を**含まない**ような文字列の方が数え上げやすい、かつ典型的な問題がある。
https://atcoder.jp/contests/npcapc_2024/tasks/npcapc_2024_a

<br><br>

### ランダムではなく、順々で良い物
- 何かテーブルを更新しながら計算...
- bitの桁のループ : bit演算について、((1 << (新しい桁数)) - 1) - x はbitの反転を意味する

<br><br>

# bit演算の制約

## xor : 線形代数的に考える
### xor基底
- 基底の作り方...線型独立の判定
    - 列ベクトルの集合に対し、列基本変形をしても貼る空間は変化しない
    - 扱いやすい形にしておいて、今までので作れるか判定楽に

- 基底の扱い方
    - xが作れるか
    - 作れるうちk番目は
    - 等々
### 問題
- [例題](https://atcoder.jp/contests/abc366/tasks/abc366_g)

- [例題](https://atcoder.jp/contests/arc115/tasks/arc115_d)
    - 基底的に求まりそう
        - popcount = kの作り方は何通り？が解けない？
        - ベクトルの立ってる成分が常に2つであることを考える
        - すると、木の場合を考えれば良いことがわかる

### bitごとに独立に考える
- [数え上げ:例題](https://atcoder.jp/contests/abc365/tasks/abc365_e)

### xorは同じ物で打ち消し合う
- [例題](https://atcoder.jp/contests/arc045/tasks/arc045_c)
    - パス(a, b)のコストxを言い換える
        - パス(根, a) ^ (パス(根, b) = x
        - よって、根からのコストのテーブルを準備してやればO(N)
        - マージテク的な解法より速い
<br><br>

# String

### Saffix_array
- (少なめの)文字列の**連続**部分列に対するクエリ
    - 終端まで続く部分文字列のうち、辞書順最小/max/k番目は...
        - reverseした文字の部分文字列のうち...
        - 2分割してreverse : 2つ繋げる事で、1つの文字列に対してreverse
    - 文字列 S の連続部分列の種類数を答えよ...
    - 文字列 S に文字列 T が連続部分列として幾つ含まれるか...
### LCP_array
- 共通部分文字列長に関するクエリ
    - 文字列S, Tに共通している連続部分列の最大長は...


### Trie
- いつ使える: 文字列のprefix/suffixについてのクエリを飛ばす時
- 嬉しい: ロリハで頑張る解法に比べて定数が良い？
    - ロリハはどこでも良いが、Trieはpref/sufに限る
    - 代わりにunordered_mapとかを必要としない
    
- 文字列を1ずつ伸ばしていく時、一致する文字列を高速に取得
    - これもロリハでも定数悪くて良いなら解けるだろう
    - dpの高速化

- 文字列の集合がある時、全てのペア(i, j)について何かしら計算...

### 部分文字列dp
やっている事 : 集合から使う・使わないを選び、使うと選んだものをその順で結合。
- 前から使う・使わないを決めていく / できる文字列について、最初の文字を探索する... 様なdpと相性が良い。
    - [例題](https://atcoder.jp/contests/arc081/tasks/arc081_c)

### 2つの文字列の比較
A + B
B + A
のような図をブロックにして書くとわかりやすい

### 2つの文字列の一致
例えばAの末尾がBと一致すると分かったら、
A = A' + B
と分割してしまうと議論が進みやすい。
- そのままだと、「前後が一致する2つの文字列」に対しての議論で、難しい
- 一般の2つの文字列に対しての議論に持ち込めるため
### S + Tについての制約
- 1文字ずつ制約を分解する方法と、互助法的に制約を分離する方法がある
    - 1文字ずつ細かく見るのがかえって悪手になる場合がある

- S + T == T + S
    - S, T　が　周期 gcd(|S|, |T|)を持つ
        - |T| >= |S| として、
            - T = S + A
            - S + A == A + S の形に
            - 互助法的に小さくなっていく
            - 片方の長さが片方の倍数となったら終了

- 回文S, T に対し、 S + T も回文
    - S, Tが周期 gcd(|S|, |T|)を持ち、さらにその周期が回文
    - |T| >= |S|　として、
        - T = A + S
        - Aは回文
        - Sは回文
        - A + Sは回文
        - 互助法的に小さく
        - ちなみにT + S( = Trev + Srev = (S + T)rev)も回文
            - S + Tが回文と同値なので、好きな方を前に持ってきて考えて良い
                - 長い方とか
                - [例題](https://atcoder.jp/contests/arc048/tasks/arc048_c)
                - そのまま
    

## 文字種が少ない事の利用

### 分布の一致
アナグラムが一致⇔分布の一致
また、分布を表すローリングハッシュは $O(文字種)$ 、或いはそれに $\log$ をつけたぐらいの計算量で作れる
<br><br>

### 非退化な三角形
・1番長い辺を固定した時、残りの2辺は貪欲で決まる
・1つも作れない様な辺集合...fibonacchi 数列 like
    - 指数数列なので、すぐに発散する
    -　長さが短い時に限る
・2つ以上作るときも、同様の貪欲により、探索範囲が縮まる


<br><br>

# 一致判定・ハッシュ
いつ使う: 一致判定の処理が重い時
重い一致判定は、ハッシュして扱うと一致判定及び記録が軽くなる。

大体のアイデア: 
- 1つの要素を比較するために、実際に比較しないといけないものがたくさんある
    - ->実際に比較する要素それぞれに値を割り振って、xorやmodでまとめてしまって、比較するものを1つで済ませる
## でかい数
- 素数mod

- 演算が * と / だけの時: logで管理
    - 少数にはなる
    - 評価すること: [1]元の数字から、logはいくつぐらいになるか [2]logがいくつ違うことを認識できれば良いか [3]その値は精度に収まるか
        - [例題](https://atcoder.jp/contests/arc035/tasks/arc035_d)

- ad_hocなでかい数の扱い
    - アイデア: でかい数を無理やり括り出す
        - 分数部分ができようとも
    - [例題](https://atcoder.jp/contests/arc047/tasks/arc047_c)
        - N! / k を (N-1)!でわる、(N-2)!でわる...
        - N! / kを、ｋ番目がかけたと思わずに、先頭に補正がかかったと思う
## 列
ローリングハッシュ
- 繋げるのは簡単
- 切り離すのは難しい
## 集合
zobrist hash

## 多重集合
zobrist hashを和にしたhash
- 集合のmergeが簡単
- [例題](https://atcoder.jp/contests/abc367/tasks/abc367_f)


## n個の独立なデータ（n次元の点)
次元と値ごとに独立な値p_xyを割り振って、そのxorを取る

## 木
文字列に単射を作って、その文字列でロリハ

<br><br>

# 差分更新
- 計算を複数回する時、例えそれぞれの計算が独立に高速にはできなくても、差分更新さえできれば全体を高速に求められる
    - 実装も軽くなることが多い（重くなることもある）
    - ややめんどくさい計算も差分更新ならそのまま行える
        - 負の添字が出るとか、データ構造が伸びるとか
    - 差分更新の回数が抑えられる必要がある

- 特に、全ての種類のクエリの情報が必要な場合、1回事に求めるよりも差分更新の方がうまく行く場合が多い。
- 例えば: 区間prodを取る時、prodの範囲さえ小さければそれぞれについて求める元で対処できる
        
> 命題: 演算が+ではなくmaxであっても差分更新ができる
- 削除あり...それに対応できるデータ構造
- 削除なし...新たな要素でchmax
## 尺取り法
- 特に動き方が単調な時、動く回数が抑えられる

## Mo    

<br><br>

# 要素の削除
定理：計算結果を要素の削除に対応させることは、追加に対応するよりも難しい
- 削除する予定の要素を使ってないものだけから集計することになるが、普通その様な物を計算しない（しようとすると状態量が増える）ので、逆元が使えないと厳しい
- よって削除に対応する時、「元からある程度削除されている状態で計算された情報」から要素の追加に対応する方が筋が良い
    - 全てを計算し直す必要はない。削除するにしろ、「削除を考えた上で絶対に使って良い要素」だけを使う計算を（多分全部の削除事にやったら間に合わないのである程度大味に）行う
### 1回しか削除しない(削除の種類は複数で良い)
- 命題: 要素[0, i) と [i + 1, n) を独立に考慮できるなら、iを削除した時の結果は [0, i) と [i + 1, n) の結果をマージする事で得られる
    - 変更であっても、[0, i) に新たにaddしたのをmergeすれば良い
    - 例: 1つ除いた時の集合minクエリ

### undoできる時
- offline dynamic connectivity

<br><br>

# インタラクティブ
> 命題: 極端な要素は他の要素より満たす条件が多い

> 命題: 極端な要素ほど情報量が多く、特定が容易い

> 系: 順に特定していくなら、極端なものから特定するのが簡単

> 命題: 情報を手に入れた時、それをクエリに用いることでクエリの情報に制約・構造が増える
- 例: 区間和クエリを考える。$a_0$ の位置と値がわかったならば、それを左端にすることで得られる情報が累積和になる


- 色々試して一番上手くいく方針を取るのが良いみたい
## クエリ回数の見積もり
> 命題: 有効なクエリの他に無効なクエリ（情報を捨てるクエリ）がある場合、クエリ回数は 有効なクエリの総数よりも多い
- よって、定数倍が厳しいときは、スカをなくす（情報を捨てるクエリをなくす・全てのクエリで情報を使える方針にする）必要がある

## 2分探索
> 命題: 1要素を特定したい時、その要素が含まれる集合（つまり候補の集合）のサイズを割合で小さくしていけるなら、それをクエリ返すと特定が $\log$ のオーダーで求まる

> 系: 候補の集合を $S, T$ でサイズについて2分割した時、そのどちらかに絞れるなら $\log_2$回

補足: 特に、集合に関するクエリが投げられる時は候補に上がる
- 特に $S, T$ 2分割について
    - 乱択と組み合わせることが多い
    - 必ずしも $S, T$ 間の情報を聞く必要はない
        - $S$ と 他の何かを比較するのが筋が良い場合もある(真にゼンタイ集合を $X$ として、 $X\setminus S$ とか)

<br><br>


# 前計算
> 命題: 計算するものの種類数よりも計算回数の方が多い場合、あらかじめ前計算しておくことで計算量が落ちる

> 命題: メインのループの中で計算量をかけて計算する値を前もって計算して置けるなら、その計算の分の計算量が落ちる
- dpの遷移とか

- 特に、値を求めるのが一度きりではないと言うときに使える


## 情報の共通化
- 前計算は使いまわせた方が良い
    - 前計算のオーダーは計算するものの種類数に対して線形
- 条件を満たすかの判定に用いるとき、個別の条件に対して前計算は難しい

- > 命題: 要素ごとに値を振り分けて、条件を「値がv以上」の様にすることで、前計算はその値の計算だけで良くなる
    - 例: [l, r)に点がない/ [l, r)に点が1つ以上 -> [l, r)の点の個数を累積和で持ち、点がないの判定を「点が0個以下」にすれば共通の前計算で処理できる。

- > 命題: パラメータを固定した時の条件に対し、パラメータ依存部分を無視してもそれが意味を持つならばパラメータに依存しない前計算ができる
- 例: $g$ で数直線を二等分した時、両端から取っていく動きが最適 -> 両端から取っていく動きを、終点を全探索しつつ探索できれば良い -> 単に両端からとっていく動きを前計算

## 情報の補正

- 前計算したものを用いて、、クエリのパラメータを含めた時の答えを出せる場合はある

- 例: 要素数 $n$ の配列 $A, C$ があるとする。その時、前計算 $O(n \log n)$ / クエリ当たり $O(\log n)$ で次のクエリに応えられる
> 整数 $x$ がオンラインで与えられる。 
> $$\min_{i} A[i] + |C[i] - x|$$
> を報告



<br><br>



# クエリ


## 逆元があるクエリ
例えば sum [l, r] -> sum[0, r] - sum[0, l-1]
- クエリの次元を1つ落とせる
    - クエリの個数が定数倍増えるだけで、かつ次元が落ちる
    - 常に考えて良さそう


## [l, r) に答える際に、rからlに向かってシミュレーションする解法が存在する時
言い換え: [l, r) を考える時、[m, r) (l <= m < r) の区間全ての答えが求まる時
> 命題: rをずらしていきながら、全てのlに対して「l, rの時の答え」を保持していけば、全ての区間クエリに応えられる
- 差分更新的に答えの列を更新するとか

## 区間の広さに対して単調性がある場合の区間クエリ
- rを昇順に見ながら、初めてその「単調性」が見たされるlを保存。こうすることで、rを固定した時の様々なlに対してクエリにこたえられる
    - 区間種類数
    - クエリを寄与に分解する必要があるかも


## 何を管理するか考える -> 出力クエリに応えるのに必要な情報
- 出力クエリを計算するのに必要な情報のうち、管理しやすいものだけ管理すれば良い
    - 必要のない情報はロストさせて良い
    - 特に、言われた通りそのままシュミレーションする必要はない
    - 何が管理しやすい? <- 勘
        - [辺の重みの変更...差分で補正することにし、差分は別に求める 本数とsumが必要](https://atcoder.jp/contests/abc133/tasks/abc133_f)


## パラメータを動かしながら、複数の要素を見る/ パラメータを動かす時、全ての要素が条件を満たしているか/max(全ての要素のスコア)
- 愚直: 全ての要素について管理して、見る

- それぞれの条件についてokなパラメータの集合を管理/スコアの最適値を計算して、合体する
    - 必要な事: それぞれについて独立に計算する時、高速にできる事。
        - パラメータがバラバラになったとしても、パラメータについて総当たりやデータ構造の利用をすれば良い
    - いつ考える: 独立に考えられる時で、独立に考えると早い時
        - 例: max(a_0, a_1, ... , a_n) <= k となるパラメータ <-> 各a_iについてそれぞれ独立にとって良い
        - 独立に考える事で、シュミレーションが高速化できるかも（二分探索）
            - 一般に、独立に考えられるなら、独立に考えた方が速い


- 条件のうち、一番違反しやすいのをみる
  - 必要な事: 明らかに最悪、がある
  - 違反要素が存在するとしたら、最悪のは必ず違反。
  - 条件を式変形
  - [例題](https://atcoder.jp/contests/arc170/tasks/arc170_d)
      - Bに含まれる全ての点について、Aに含まれる点であって、距離x以内の点があるか？
      - 判定: Bに含まれる全ての点について、一番近いAの点までの距離がx以内
      - 最悪: Bに含まれる点であって、一番近いAの点までの距離が一番遠い物

## 配列のスライド
- dequeを使うと O(スライド幅)
- 全体+1とかできる

## 置換は合成ではなく代入・かつ、区間作用では一様な置換が存在しないかも
左側では 0 -> 1, 右側では 1 -> 0があり得る。
素直に現物を管理するのが良い。


## 似たような計算の、パラメータを変えた物を何回もする時
- 個別に求めずに、テーブルを作ってしまう
    - k番目を直接求めるより、1, 2, 3...と求めていった方が一般に楽

- 特に、寄与に分解した時、分解した先で必要になる情報が似た形の場合が多い上、この発想に至りづらい

    - [例題](https://atcoder.jp/contests/arc167/tasks/arc167_d)
        - 頂点ごとの寄与の分解を考える
        - 以上、未満でx, oとする。自身をiとする
        - すると、「x, o, iを並べる並べ方であって、iとの距離K未満に~」と言った形のが必要になる
        - 毎回求めるのは難しい
        - xの個数でテーブルを作る
        - dpに落ちた


### 補集合クエリ
- oo以外の総和
    - 全体 - oo
    - オーダーが落ちる

## 加算クエリ
逆元を使うと、素直にデータ構造を変形させなくて良くなる場合が多々ある。

## swag
区間prod無理そう

## 各要素1回しかクエリが来ない・意味のあるクエリが1回だけ
- 愚直に1つずつやっても間に合いがち
    - 意味のあるクエリが1回 -> 代入クエリであって、その先が定数とか

## offline query
> 命題: 好きな順に処理して良い
- 求めやすくなるように順番を変えても良い
    - 逆から・大きい方から
> 命題: 全て求めて出力はオフランクエリ

- 同時に処理しても実行されていくとしても良い
    - [同時に起こると見ると解ける](https://atcoder.jp/contests/agc046/tasks/agc046_c)   
        - 後ろから見た時に1回しか来ないことを使いたい
        - せいぜい10 -> 各クエリ10段階あると思って、それを同時に1段階ずつ進めていくとする
            - 小さいのを軸にする
        - すると、状態数が抑えられて解ける


## 状況やデータ構造に変更を加えるようなクエリ
- 命題: 状況やデータ構造が一致するようなクエリにはまとめて答えられる
    - 命題: クエリの種類ごとにまとめて答えれば、データ構造へのそれぞれの変更を1回だけやれば良くなる
    - クエリ毎にデータ構造を変更する必要がない
        - [辺ごとにクエリの種類は一意 -> クエリの種類ごとにまとめて答えれば良い](https://atcoder.jp/contests/joi2022yo2/tasks/joi2022_yo2_e)

## データ構造雨が持つ値に追加の情報を与えたい・場合分けしたい時
- 1つのデータ構造で頑張るのではなく、追加の情報毎にデータ構造を持つようにすると上手くいきやすい
    - データ構造を上手く改造する試みは難しいといった方が良いか

<br><br>


# 2次元
- (x, y) / [l, r) 等、2つのパラメータを持つものは2次元平面上の問題に言い換えると議論が簡単になる場合がある

- [例題](https://atcoder.jp/contests/arc139/tasks/arc139_c)
    - (x, y)のペアのセットを作る
        - 3x + y 及び x + 3yについて素になるように
    - 2つのパラメータに関する問題なので、平面にprotして見る
    - 制約は、「点から伸びる2つの直線上に乗る他の点を採用しては行けない」になる
        - 直線の形的に、角はok
        - 予想: 全ての直線から1つずつ選べれば良さそう
        - 問題が、「全ての直線から1頂点ずつ選ぶような選び方はあるか」になる
        - ある程度は貪欲で決定できるが、6個目から貪欲が見えなくなる
        - 典型: 綺麗な形の解を試す
        - できた
        - AC

## 疎な2次元平面
- 座標圧縮 -> 全探索
## 2次元クエリ
- 2つの情報(a, b)に対応するクエリに答える状況

- 平面操作
    - aについて全探索しながら、データ構造を更新して、それによってbを答える
    - 必要なこと: 
        - bが指定された時、結果を求めるのに必要な情報の更新が高速に出来ること
            - 往々にしてセグ木
    - いつ考える:
        - 2次元クエリなら割といつでも
        - 区間である必要はなく、(t, x)だったりすることも多い
- Mo
    - 必要なこと: 
        - a, bの値域のはばをN, クエリ数をQとして、 N√Q * (伸縮)が間に合うこと
            - 特に、(a, b)が区間である必要はない。
    - いつ考える: 
        - 伸縮が高速
        - 平面操作ができない
## バラバラな区間クエリ
- 区間add。ただし、配列Aに対し A[i] = xを満たすiにだけadd
    -  配列の値ごとにセグ木作って、構造体に「これは足す対象か」のフラグを立てる。

- 配列を区間にadd。ただし、スライドしていく
    - 各要素について見た時、加算する対象が区間になっている。 O(addする配列の長さ log )でもできる。![alt text](<images/スクリーンショット 2024-12-06 19.21.34.jpeg>)

- 順列を見ていく。seg[v] := P[i] = vとなるhoge。「値がP[j]が以下、かつ添え字がi以下であるようなseg[P[j]]について」
    - セグ木を全部分用意して、「値が空 <-> 単位元」とすれば良い。値が小さい方から見ていけば、値の大小の制約は無視できて、添字はprod。

- 配列のバラバラ要素sum
    - バラバラの種類数が少ないなら、差分更新の考えで計算量 O(クエリの種類数)
## 点が密集していない
- ブロック分割 <- それぞれの領域の点の個数が抑えられる
    - [距離K以下の点を列挙](https://atcoder.jp/contests/abc234/tasks/abc234_h)

<br><br>

## 再帰関数・ループがある場合
- 正当性を考えるのが難しい
- seen[v] := vからの探索を始めたことがあるか のほかに、 done[v] := vからの探索が終わったか　を持って、seen[v]の時にdone[v]の値で場合分けすると良い。
- uを探索の途中、vに関する値が欲しくなってf(v)を読んだが、seen[v] = trueだった場合
    - done[v] = true:
        - 探索が終わっていて、値が正しく求まっている
    - done[v] = false:
        - v -> u -> vと状態が遷移してきたことを意味する。多くの場合、この事実を元にuの値も求まる（無限に循環するとか、サイクルに含まれるとか）
        
<br><br>

# 推定
要素a, bをランダムに取ってきた時、a, bは似たような振る舞いをする。
- 集合 $S$ をランダムに・何らかのランダム性のある手続きの末に取った時、 $a \in S$ の確率 = $b \in S$ の確率
<br><br>

# 乱択
> 命題: 確率 $p$ で成功する事象を成功するまで続ける時、回数の期待値は $\frac{1}{p}$
- $p$ を保証できれば良い

## 条件を満たすものを見つける
- 必要なこと
1. 条件を満たしているかの判定ができる
2. 発見確率がある程度抑えられる
- 特に、どうすれば見つかるか？どのような解か？考えないで良い

- 例: 原始根

<br><br>

# misc
## 複数の要素の中で、ある1要素の振る舞いが知りたい
- n ^ 2個全てを見なくても、ある要素 * n の n通りの関係を見れば良い
かつ時間を他のnこの区間全てに対し計算してsumを取れば良い
    
- 1d/点の縮約
    - range set
   
- 1秒に重みがある時
    - 幅で考えると分かりずらい? 
    - 下の図のような考えで![alt text](<images/スクリーンショット 2024-12-16 23.22.01.jpeg>)
    - [i, i+1) について決めるときは、大体i + 1のところから見る（右端について半開区間)
    - 終了までi秒あるのは、i)の区間を決めるとき


## あり得る、という条件や言葉は言い換えた方がよし
- > 命題:  同値な言い換えとして「存在する」で言い換えられる場合が多い
    - そもあり得るの定義より
    - あり得る、だといつあり得なくなるのかなどをいちいち考える必要性が出る