- 多項式のdpが立ったら、基本高速化をねばっこく狙う！
- ここに書いた高速化は他の解法にも共通して使える

### 1回の処理ならば間に合うが、それを複数回やることから間に合わない時
- 二分探索・三分探索によって、処理の回数を減らす
- 差分を更新していくことによって、処理の時間を減らす
- 1回の処理の時間をより速くする
- データ構造に頼る
- 極端なケースのみ見ればよい 
    - 区間DP : 端を選んだ時だけ見る
        - 通るならok
    - 分割は分割でも一番短い分割だけ試す
        - 答えの中に、一番短い分割をした物が存在することをいう
    - 2分割だけ試す
        - 偶数分割しかできない為、必要に応じて統合すれば2分割で可能性の判定ができる等

<br><br>

### 処理の仕方に自由度がある時
- 計算量の軽い方の処理を常に選ぶことで、一度の計算量が大きいにも関わらず全体の計算量が抑えられる場合がある
    - マージテク
    - 方針が異なるのに計算量が同じな解法のペアがある時に、それぞれに有利な処理を任せることで $O(N\sqrt{N})$
        -  dpの貰う・配るの両立
        -  軸が違うdp
        
<br><br>


# 前計算による高速化
## 関係の前計算・独立性の前計算による高速化
dpの遷移のたびに条件を確認するのではなく、前計算によって最初から"取りうる状態"を追加していく。
- [dpの遷移時に条件を判定せずに、条件を満たすような組みを先に計算して、それをグループで一気に追加することによる高速化](https://atcoder.jp/contests/abc352/tasks/abc352_f)
    - dpのたびに違反していないかを確認すると計算量爆発
    - 制約を前処理しよう
    - 関係性が張られている頂点どうしを辺で結び、それを一気に追加することにする
    - もはや制約を見なくて良い！高速化
    
## 答えの固定による前計算によるシュミレーションの高速化
- このようなことができるので、普遍的なパラメータの固定は他の固定よりも前に持っていくべきである。

## テーブルを前計算して、適宜修正することで欲しい情報を得る
- 似たような状況で似たような情報をなん度も欲しい時、毎回1から計算するのではなく、テーブルをまず高速なアルゴリズムで求めて、そこを修正・参照する方法で情報を得る事で間に合わせる事ができる。
    - 必要: 修正点が一様(データ構造で高速に対処できる)
    - 嬉しい: 全体を計算する時に使える、高速なアルゴリズムが使える
<br><br>

# 差分更新して情報を維持・そのための探索順の変更
- 一から計算せず、差分を更新していく手法で解く事はよくある
    - 必要な事: 情報の変化を高速に反映できる
- このとき、情報の変化を少なくするために、探索順を変える・工夫する必要が出る場合がある

<br><br>

# 解法を使い分けて高速化する
- 必要なこと: 
    - 計算量が違う解法が2つ以上あって、それぞれについて得意なケースを割り当てたら全体が高速になること。
    - 「値がなんであれ高速だが、種類が多くて全部は無理」と「値が大きい時、特に高速」があって、小さいケースを「値がなんであれ高速」に投げられること。
    - 「特に時間がかかる」というクエリの種類が少ない時、クエリの処理をもらう・配るにしてどうにかする
        - 計算量が異なるについて: 特に、与えられた文字を使ってオーダーを表すと同じだが、実情は違うという事がある    
        - 例えば、グリッドの問題で「マス目の数」と「コマの数」は、どちらも 縦 * 横　で抑えられるが、これらが一致しない時オーダーレベルで（どちらかが）ずれている評価になる
            - この「オーダーレベルのズレ」が常に一方の解法で起こる時にこの解法の使いわけで高速化される。よって、見やすさを重視し、問題文で与えられた変数でまとめるのは危険
    - よって、普段から、計算量を考える時は「ギリギリまできつい」評価をしなければならない    
    - いつ考える: 高速化のために、試行錯誤した結果、上のように、「ギリギリまできつい評価をした結果」オーダーが異なる解法が2つ以上出た時。

    - [bの全探索 or b進表記の全探索](https://atcoder.jp/contests/abc044/tasks/arc060_b)
        - bを1つごとに $O(log n)$ ぐらいで常に。できる
            - 全部やったら間に合わない
            - sqrt(N)以下なら間に合う...他の、bが大きい時に有利な解法は？
            - b進表記で全探索
    - [要素ごとに集計の仕方をもらう・配るで切り替え](https://atcoder.jp/contests/abc219/tasks/abc219_g)
        - 次数が少ない人は愚直で良い。それで間に合わない人は少ない。
            - 少ない人に配る
            - 配るなら遷移が少なく、もらう側は確実に配られているのでO(1)。配る人は、集計に愚直で見て良い。
<br><br>

# DP
嬉しい事: 計算結果の再利用、または纏めて計算する
- これによって、探索区間が広くても、その全てを探索することができる
- 必要なこと: 
    - 探索空間がDAGであること
        - 問題のサイズが小さくなっていけばdag
            - **特に、極端なもの/新たに考慮することにしたものについて場合分けすることによって、問題のサイズが小さくなる場合が多い！**
            - 探索の過程で、単調に変化するものがあればそれを軸にしてできる
            - 順々に決める...x座標や時間軸が単調に増加していく...
    - 探索したい全ての状態が、dpの遷移で含まれること
    -  (重複を許さないならば)1つの探索対象が、dp重複して探索されないこと
        - ⇔任意の探索対象について、探索の任意の段階において、2つ以上の状態へと分かれて遷移することがない
            - 気づき方: 重複しやすそうな探索対象を一つとって、手でdpしてみる
            - 例: {1, 2}を、要素数1の集合に分解した集合族の個数は？
            - dpで一つずつ集合に分解すると、 {{1}, {2}} において、 $\emptyset$ -> {1}/{2} となり、最初の遷移で2つに分かれるためダメ
    - また、高速化した（遷移をまとめた)dpにおいて重複が発生するという場合、元々のdpにおいても重複している可能性が高い
        - 高速化が原因と思って混乱しないこと
            
- 遷移をちゃんと数式にして考える
    - 様々な高速化の基礎

- いつ使う: まず最初に考える
    - ほぼ全探索

## 設計・状態をまとめて探索
- 素直に設計して、高速化する

## 設計・再帰的に解く時
- 必要なこと: 状態を、うまく繰り返されるものとして選ぶ必要がある
    - **特に、初手の結果で場合分けすると問題が小さくなる、は頻出**
    - 特に、「新たに考慮するようにした要素（順序がないなら一つ適当に選ぶ: 集合dp）」について、その要素で場合分けすると、自然とサイズが小さくなる場合が多い

- いつ考える:  全探索したい -> dpで高速にやりたい -> どういうdpを立てたら良い？がすぐにわからないとき

    - [辺をはる。入・出次数が定まっているとき、集合Sが一つの連結成分になるような変の貼り方](https://atcoder.jp/contests/abc321/tasks/abc321_g)
    - まず、S内で辺が収まるような貼り方の場合の和は簡単
    - Sの要素を1つ取って、そいつが含まれる連結成分のサイズで場合分けしよう
        - それを引いていけば答えが求まる

- また、問題の対象がなんらかの理由で独立になった場合、そこを区切りとして問題を分けることで問題のサイズを小さくするというのは良くある流れである。
    - [全体にaddしない <- 操作が来ない行がある <- 独立に解けば良い](https://atcoder.jp/contests/abc233/tasks/abc233_g)
        - [sy, ty)*[sx, tx)を状態としてもてば良い
            - 来ない行・列を両方固定すると $O(N^6)$ だが、テーブルが豊富なので、実は固定は別々にやって良い
        
- 問題文で与えられているものがあるなら、それを利用すると丸い
    - 辻褄合わせというのは　「自分の定義したやつなら求められるぞ -> 実際のゲームは初手にOOできるじゃん -> それ反映するために定義ずらす/状態量増やさないとダメじゃん -> あばばばば」

## 探索対象のかどうかの判定をDPにする・まとめて判定する
- 必要条件の考察 -> 探索範囲の削減　とは違う
    - これは状況が複雑な時にやる整理
- 必要な事: 探索対象かの判定が答えにつながること。特に、見つけたい対象を1つ選んだ時、それがアリエルかを判定できる方法なら何でも良い。
- いつ考える: 特に、探索的に・遷移の状態を持つdpで間に合わない時。
    - 成功パターン: 
        - 同じ結果になる遷移がたくさんある時、非常に有効。
            - dpが State: bool の時に特に使いやすい(Stateが同じものを重複して数えない・無視して良い。種類数や、あり得るものの数え上げ）。数え上げだと重複無視してはいけないかも。
            - 最適化も、あり得るかを解けば解けるので、比較的ハマりやすい
        - 探索的にやるのでは途中で持つ情報が多いが、結果の判定は楽な時

- [集合:　部分集合のgcd数え上げ](https://atcoder.jp/contests/abc191/tasks/abc191_f)
    - 探索的にやる...無理そう。あり得る終端は？
        - 選んでないやつのmin >= 選んだgcd
        - これは必要十分ではあるが、使いづらい -> もっと別は無いか？
        - 良く考えると、 min(A) >= 選んだgcdも必要十分       
    - あり得るgcdを列挙したい
        - $O(Nd(A_i))$には収まる   
    - dp[g] := gcd = gがアリエルかで配る...大抵の遷移が、gcd = 1に行く
        - ここでも探索的にやると間に合わない
        - 数え上げ、つまりgcd = gがあり得るかを判定したい。
        - gcdの判定: 全てのgの倍数のgcd = gならok, else ng
        - これをやろう
    - dp[g] := gの倍数全てのgcd   
    
## 計算に必要な情報の考察によるdpの立式・高速化
- そもそも、dpで持つ情報とは、後々の計算・判定のために必要な情報
- つまり、dpは、計算方法を元に設計され、そこからまとめて判定だとかいった高速化がなされるもの
- よって、よりまとめる事で持つ情報を減らす・あるいは持つべき情報を特定するには、判定の方法を先に考察する必要がある
    - その考察を元に、dpを設計する
    - 情報量が少なく済むような結果が得られないと意味がない。


- よくある手順
    - 1: とりあえず固定する・持つ情報を増やす
        - 求まるようにする
    - 2: 情報を減らす
        - さっき見繕った情報で、必要ないものを減らす・まとめる

    - [設計: グラフの数え上げ](https://atcoder.jp/contests/abc281/tasks/abc281_g)
        - 条件...頂点1からの距離
            - 頂点1からの距離を求めながらグラフを構築していく
            - 使った頂点集合 -> 使った頂点の数　に情報を落とせて、できる
 
    - [例題](https://atcoder.jp/contests/abc369/tasks/abc369_f)
        - 条件を満たす集合のうち、max
        - 集合を選んだ時、条件を満たすかを考える
        - 右上の関係のがあったらダメ...
            - アルゴリズムではない
            - 役に立たない
            - アルゴリズムにする！
        - dagの関係より、高さでsort
        - xについて単調増加が必要十分
        - あとはLIS

    - [例題](https://atcoder.jp/contests/arc169/tasks/arc169_c)
        - 順番に関係ない->どの?から決めても良い
            - 左からにしよう
        - 一つずつ決めていくか、纏めて決めるか...
        - 判定問題を解こう
            - 同じ数字の区間をまとめて拾って、その長さを見る
            - 纏めて追加の方が良さそう
        - O(N^3)がたつ
        - dpを数式にする
        - 前の結果を利用等色々あるが、今回はデータ構造の利用でおｋ
            - 補集合を取得...全体 - 特定のもの

## 探索の順・軸の変更
- 判定に用いる情報が少なくなるように軸を変更すれば、当然それによって解ける場合がある
    - 挿入dpなりなんなり、多くのdpにはindexの昇順・降順 / 値の昇順・光順がバリエーションとしてある
- なんか特殊な考察をする前に、これを検討したほうが良さそう
    - 必要な事: 後の為に必要な情報が少ない事
        - これさえ満たせば良い。かつ、バリエーションが結構ある上、思いつきにくいものでもない。
    
    - [辞書順の制約、たくさんの列 <- 列の前から埋めていく](https://atcoder.jp/contests/abc292/tasks/abc292_g)
        - 行ごと埋める...どの桁がどの数字？を覚えないときつい
            - 初めて超える行を固定したとしても、場合の数が綺麗にもとまらない
        - 行ごとに埋めずに、列ごとに埋めていくと、問題が独立になって解けるらしい
    - [整数に対し、末尾への数字のaddを1段階の遷移と見る](https://atcoder.jp/contests/abc222/tasks/abc222_g)
        - x -> 10x + 2
        - [無限桁の場合](https://atcoder.jp/contests/arc084/tasks/arc084_b)
            - dp[i][m]...i桁で mod K = m の時、けた和のmin
                - iは終了判定にも遷移にもいらない -> 消して良い
                    - dp[m] ... mod K = m の桁和のmin 軸の添字を消してもdpが回るタイプ

### サイズを大きくしていく探索
- サイズを小さくしていく探索の探索順を逆にすると、サイズを大きくしていく探索ができる事がある
    - 所謂後退解析
- 新たにaddした要素の場合分けで注目している問題のサイズを落とすのは変わらないが、後退解析では「今までに計算した結果を元に、今の場合分けの結果を求める」という側面が強い

- 必要な事: サイズを大きくしていくようになっている事
- いつ使う: ゲーム、今の場合分けのどれを採用すべきかわからないdp
    - 今何をすれば良いかがわからないため、状態が膨大な時、後ろから見ることによってすっきり解ける場合がる
    - [根から探索するとするべき行動がわからない -> 逆順（葉から探索）](https://atcoder.jp/contests/abc218/tasks/abc218_g)
<br><br>

## 配るdp -> 貰うdp
往々にして、非自明高速化がされる
- いつ考える: dpを高速化したいならいつも

- データ構造に相性が良かったり
    - 配り先が区間/貰い元が区間は両方あり得て、これは対等

- 無駄な遷移を省く高速化
    - topK探索。元から最適だけを選んでpopを繰り返す

- 遷移先が共通しているものが多いという時、その「先が共通した遷移」をまとめてできる
  
<br><br>

## 纏めて計算する事による高速化
dpの基礎理念の一つ
計算量が、元の母集団 -> まとめた後の種類数になる
- 高速化する上で普遍的に有効
- 何らかのパラメーターが一致・遷移の係数が同じなどに、纏められて一気に計算できる場合がある
    - 例: 毎回 dp[i][1] += 2 * dp[i - 1][1] 、 dp[i][2] += 2 * dp[i - 1][2]の場合、
    - dp[i] := dp[i][1] + dp[i][2] が高速に求められる
        - 最終的に求める値が得られるのなら、こっちで良い
      

- シュミレーションでももちろん有効
    - パラメーターが変化しない区間をまとめる場合
        - [例題](https://atcoder.jp/contests/arc091/tasks/arc091_d)
            - A -> A - A / K - 1 を繰り返す
            - A / Kが同じ区間の操作をまとめよう
                - パラメータが変化しないより、操作は単調で計算しやすい
            
            - 計算量が$O(\sqrt A)$になってhappy
                - 示す際は、$\sqrt A$を閾値に場合分けすると良い
                    - 天下り的
                 
<br><br>

## 今までの計算結果を再利用することによる高速化
dpの基礎理念の一つ
- 特に、貰うdpの考え方をする時に頻出
- 今まで計算した問題のサイズと比べて、サイズが大きくなっている要因に触れないようなケースは全て計算済みである
    - **よって、サイズが大きくなっている原因に触れる遷移・探索対象にだけ計算すれば良く、その要素に触れない遷移はわざわざ計算しなくて良い**
    - 例えば、要素の使用/notについて見ていくdpで、左からみていく: [0, r)について考えるのならば、r-1を用いないケースはすでに計算済みなので、r-1を用いるケースに絞って計算すれば良い。


    - [全ての(l,r)についての計算/dp[r]:=\[any,r\)の計算](https://atcoder.jp/contests/arc169/tasks/arc169_b)
        - dp[r] := \[any, r\)の計算をしよう
            - 部分列に分割される...r-1を含まない部分についてはもう計算済み
            - 上手く使う
    
    - [区間dp, \[l, r\)の中から3つ選ぶ](https://atcoder.jp/contests/agc050/tasks/agc050_b)
        - 愚直だと毎回N^3かかる
            - 端を選ばないケースは計算済み！
            - l, rを両方使う場合のみ計算
            - (1)l,rが同時に選ばれるケース (2) l,rが独立に選ばれるケース(区間が2つに分かれる)
                - O(N)で可能になる

- 他に一般に、「この情報を更新して気さえすれば解ける」という時(特に、「遷移ごとに情報を持つ」ことにこだわっていないことに注意)、dpとして「今までに"計算した情報"」を持つことがある
    - 寄与の分解等でよくある。
        -「今まで計算した情報から、今回の情報が計算できる」ことが必要であり、「遷移を纏める」のような発想よりも一般的である
    - 必要なこと: 定義通りの情報が、今までの情報から求まること　であり、特に上の例に注意。 
    - いつ考える: 寄与の分解の時は多い
        - 遷移を持つわけではないので、状態量少ないことがある（全体についてのテーブルを一つ持てば十分）という風に感じる
            - そこまできっちり区別があるわけではなさそう。
            - [すべての遷移に対する、連結成分の情報をテーブルとしてもつ](https://atcoder.jp/contests/arc187/tasks/arc187_b)

- 大部分を共有する、パラメータが異なるクエリについて答えるという場合に、dpの添字としてそのパラメータを追加するということもある
- 必要な事: 問題のサイズが小さくなる事、問題の種類数（dpの添字の数）を少なく抑えられる事
- いつ使う: 常に考えれば良い
    - 前計算より
    - [そういう考え方をする](https://atcoder.jp/contests/abc364/tasks/abc364_g)
        - 新たな頂点vを固定して、それごとに計算するのは間に合わない
            - 差分更新もよくわからない
        - クエリ（集合）が共通...それを添字にしてdpみたいな

## データ構造を使う高速化
- 必要な事: 遷移がデータ構造に載る
    - 多くの場合:区間
    - 他slope trick/1次関数max/fps:inv
- いつ考える: 高速化したい時に、その1手として。また、「とりあえず愚直を書いた」時に見るべき。

- dp[state]からの遷移が区間
    - imos, 遅延セグ木
- dp[state]への遷移が区間
    - 累積和、セグ木

- [愚直なdpを書く -> 遷移先が斜めの直線4つに分解できて、imos](https://atcoder.jp/contests/abc265/tasks/abc265_f)
## dpしながら答えを集約するタイプの問題
dpしながら、途中でテーブルの値を使って外で計算する場合。
- 集約値が、dpが進むに従って、明示的な変化がないにも関わらず変化することがある.
    - 例えば、寄与に分解する問題で、探索しながらすべての遷移についてなんかのsumをとっていたとする。この時、すべての遷移が2つに分裂したならば、今までの値も2倍になるはずである。よって、ans変数を持っていたら、ans変数の値も2倍しなければならない。 
- 必要なこと: dpの途中結果を外に反映させるなら、「その外の結果の、dpを進めことによる変化」もちゃんと更新しなければならない。

## 添字を減らすことに寄る高速化
- コツ : その添字が"いつ" "何のために" 必要なのか、詳しく考える
    - 最後に値の補正をする...最初に反映できないか?
        - 係数を、初期化でかけてしまっておく
        - dpの最初にだけ必要...計算結果に最初に反映する
        - dpの最後にだけ必要...探索順を逆にする・最後の段階で情報を取得
        - 以降全ての値に均一に補正...今補正できないか？
            - https://yukicoder.me/problems/no/269
            - 問題そのものを、その補正に合わせて言い換え
            - 分割統治に近い

- 他、情報をたくさん持つ時、「ある情報から他の情報が実は定まる・一意に対応するので、添字に持っていた情報が必要ない」という時がある
    - いつ考える: 「遷移の状態・結果の一部」を両方持つ時、状態から結果の一部が導けたりするので、そういう時
        - とりあえず何か固定して答えが出るならば固定を緩和できないか考える、という全探索・数え上げの高速化とにてる
        - また、持つ情報に関連性がありそうな時

### 特殊な時: 探索の軸の添字を消す・無限に続く探索
- 例えば、桁dpにおいて下の方に数字を追加していく時、普通は「今何桁埋めたか？」を持つ
- しかし、この添字を省略して良い時がある
    - 下にあるように、「それを消してもdagになっている時」は良い例
- 必要なこと: それでも答えが求まる
    - 探索に終了がない・他の情報で終了を判定でき、かつ答えも計算できる
        - 往々にして、添え字を消すとDAGではなくなるが、それでももとまる場合が多い
        - 遷移をグラフで考えると最短距離になっているケース
- いつ考える: 特に「探索の終了判定にどこまで遷移したのかが・今何個埋めたかが必要ない時」、具体例としては「任意桁の整数を全探索したい時」
    - いつも必要な理由 <- 桁によって遷移が変わることがある、および（多分ほとんどの場合で共通するのが）探索の終了の判定に用いる
    - よって、例えば、「任意の桁の整数を探索したい」という時、桁の情報をロストさせても終了条件に桁がないので困らない
        - 桁が大きくなる事を考えると都合が良い
    
    - [文字列・末尾追加の探索](https://atcoder.jp/contests/abc264/tasks/abc264_g)
        - 何文字追加したかどうでも良く、状態が末尾2文字になる
            - 文字数消すとDAGではなくなる
        - 遷移をグラフで考える
            - 再長距離...ベルマンフォードでもとまる（符号flip）

## 遷移の固定・ループを減らす事による高速化
- 特に再帰的に解く時、「遷移の和を減らす・固定の数を減らしても、十分dpテーブルから答えが求められるため、答えが求まる」という場合がある
- 必要な事: 固定を全て試さない・大雑把な場合分けであっても、dpテーブルに載っている程度にサイズが小さくなる事
- いつ考える: オーダーを落としたく、遷移の本数を減らす事によって高速したい時。dpとして持つ情報が多い時（多次元）
    - y, xを両方固定しなくても、y, xを別々に固定すれば十分サイズが小さくなり、dpテーブルに答えが書いてる

## 1番軸となる添字の変更・削除/DPのループ順
**DAGになってるものは全て軸になれる**
- 例: 数列の "i項目" まで決めて, ...


ここで、iが
- 各段階の値の計算には**必須でない・影響しない時** ... **別方針でうまく行ったりする**
    - 探索順を変える...
- **iの他にも、必ず増加する・減少する要素がある**... **iを持たなくてもdpが回ったりする**
    - iが無くともDAGパターン
    - 計算にiが必要ならば、依然iは添字に含む事になる。しかし、**iが必要なかった場合、iを持っていた分計算量が落ちる。**
        - 必要無い典型パターン...項数に制限がない数列・或いは集合の数え上げ
            - [例題](https://atcoder.jp/contests/arc107/tasks/arc107_d)



#### how
- iを落とした上で、新たな軸になるものがある・DAGになっていないか見る
    - とりあえず初期化をする
    - **遷移がDAGになっていたらdpできる！**
        - 最大値は必ず増えていくので...
        - 区間を右端でsortして順に見る事で、区間の右端は常に増えていくので...
            - [例題](https://atcoder.jp/contests/arc026/tasks/arc026_3)


- dpの探索順を変えてしまう
そもそも筋の悪い探索順を選んでいる可能性。
数列を定めると言っても、左から定める必然性は無い。
    - 右から...
    - 大きい値から...
    - 最下位bitから...
    - 終端状態から...


### dpのループ順を変える事で、dpが破綻する場合がある
- 0/1ナップザック
    - 重さの昇順にやると、同じアイテムを2回以上使う場合がある

- 集合への分割・集合のサイズごとに係数を掛けて修正する
    - 集合のサイズを最初の添字に持ってこないと、 + |1|のやつ -> + |2|のやつ -> + |1|のやつ　といった遷移をしてしまう
    - 絶対に逆転してほしくないものは、一番外の添字に持ってくると安全

## 遷移を分けて計算する
- 2種類の遷移があるという時、それらを同時に処理する必要がない・別々に遷移して良い場合がある
    - 例: 加算
    - 例： max
    - 例: $dp[i] = max(dp[j] + C[j], dp[j] - C[j]) のような場合、まず dp[j]+C[j]でchmaxしたのち、dp[j] - C[j]でchmaxして良い

- そのような時は、別々に処理する事で遷移が単純になり、高速化がなされる場合がある
    - あるいは、計算量が良くなる（データ構造の利用、列をreverseして2回...）

- 必要な事: 遷移を分けて計算して良い
- いつ使う: 積極的に使う。
    - 一般に、独立に処理して良いなら、個別に処理した方がやりやすい。

- [bitdp、2種類の遷移。片方はダイクストラdp](https://atcoder.jp/contests/abc364/tasks/abc364_g)
    - ダイクストラdpの方はループがあり、ややこしい
    - 部分集合列挙の方を先に処理してしまって、その後にダイクストラdpに集中する


## 何かしらのパラメータを共有する要素が多い時
そのパラメータごとにまとめて処理することで高速化がなされる場合がある
- [パラメータを共有する中で、必要ないものを捨てる最適化](https://atcoder.jp/contests/abc373/tasks/abc373_f)
    - アイテムを分離できる
        - N^2このアイテム、間に合わない
        - CHTでも解けるらしい...?
    - 重みを共有するアイテムが多いことに注目
    - 重みごとに処理しよう
    - 重みwについて、上位 W / w個しか残さなくて良い
<br><br>

ってしまった
<br><br>

## 遷移先の状態数が少ない
集計するものが
- State: bool (重複なし。種類数を・あり得るものを数えよ) -> 判定問題を解いた方が、遷移が減って計算量落ちるかも
- Steta: 数（重複あり） -> 貰う、inline 

<br><br>

## 状態数 * 遷移が計算量ではない。添字を減らさない・状態量を減らさない高速化/ inline dp
- 必要な事: 更新を、前のdpテーブルを土台に用いる事で高速に行える事
    - 変化点が少ない場合、では無い
        - 区間変更は大体対応できる。区間が3つぐらいに分かれてもできる。
        - データ構造でカバーできるものは全てできる
    - 特に、最適化において、「ここは更新しなくても良い」という枝刈りを用いて行われる
    - 或いは単に数え上げでも「変化するならば、変化後の状態はこれになる」といったものが絞れれば、そこだけ更新する/ 他は一様に更新する　等とできる。

- いつ考える: 全探索を高速化したい
    - 「選んだ・選ばない」dpで、選んだ物の特徴をkeyに持つならば、常にinline dpである。
    - nxtdp(i -> i+1)にしか遷移がない時はやりやすい
    - dpが1次元の時は特にやりやすいが、2次元でもできる
    - 「そのまま遷移する・一意に遷移する」ものはinline dpに乗りやすい
- 多項式のdpがたったならば、それを立式する事・変更が入る添字の量を見ることが必要
    - 多項式のdpは高速化ができれば答えられるし、できる場合が多い。    
    - 遷移の順番でバグりやすいので気を付ける
        - [選ばない場合iが増えるだけ、選ぶ場合遷移先が限られる場合](https://atcoder.jp/contests/abc176/tasks/abc176_f)
            - 採用しない場合、値を+0/1してiを増やすだけ
            - 採用する場合、採用先の添字が絞られる
                - そこだけ丁寧に更新しよう

        - [殆どの場合、dpテーブルがスライドするだけ](https://atcoder.jp/contests/abc372/tasks/abc372_f)

        - [多項式dp -> 遷移を考えると、1箇所にしか変更がなく、その量はprodでできる](https://atcoder.jp/contests/abc279/tasks/abc279_g)
            - できるだけ情報を落とすと、dp[i][last]の形
            - 初期化...dp[i][-n]に来たと思う。prod, addを関数にして包む。
        - [選んだ・選ばないでdp && 最後に選んだ物の色を持つ -> inline dp  状態 * 遷移数 よりも計算量が落ちる](https://atcoder.jp/contests/abc383/tasks/abc383_f)



## 遷移の　細分化　⇔ 共通化
- 所謂、細かく遷移・まとめて遷移
- 細かく遷移
    - 必要なこと: 細かく遷移しても、持つべき状態数が爆発しない
    - いつ考える: 上記を満たすなら、基本細かく遷移した方がオーダー的に速い。

- まとめて遷移
    - 必要なこと: 求まる
    - いつ考える: 基本的に細かく遷移より遅い。その間の遷移を全探索する必要があり、そこをまとめる事ができないため。しかし、細かく遷移しては持つべき状態数が多くなるという時、「一様な部分について、まとめて考える」と言った思考によって、状態数が少なくなる場合がある。ここで特に遷移も間に合うようにできると、こちらが有利になる
        - 細かく遷移と比べて危険なことは承知すべき
        - 特に、「まとめて遷移することにしたが、状態が減ったわけではない」という時に危険
        - [遷移の中で、イベントが起こるのが45回しかない -> その間をまとめようとすると、状態O(n)遷移O(n)になってしまう。細かくやると状態O(n)遷移O(1)](https://atcoder.jp/contests/arc084/tasks/arc084_b)
    - まとめて、の粒度にも自由度がある
        - 基本的に細かく遷移するが、ある種類のものについて処理し終わった時点で、1回dpテーブルを集約するようなまとめ方
            - [種類数によって価値up ナップザック](https://atcoder.jp/contests/abc383/tasks/abc383_f)
                - 基本的に、選ぶ・選ばないでやる
                - ある種類のものを全て見終わったら、全ての遷移を「まだ今回のを選んでない」に変える
                - これを繰り返す
<br><br>


## 全探索のdp化
**DAGになってるものは全て軸になれる**。
よって、探索の過程で単調に変化するものがあれば、それを軸にメモ化できる。
[url](https://atcoder.jp/contests/abc363/tasks/abc363_f)

- **典型: 考察対象の数を小さくする様式変形** [例題](https://atcoder.jp/contests/arc176/tasks/arc176_b) (ユークリッドの互助方)
    - how ? 
        - modを取る ... 割れるだけ割る
        - gcdは左右入れ替えても良い

#### DPの計算時、ループの外側に出せる計算・if文はループの外側に出すべき
不要な再計算・ループの排除・高速化に気づきやすくなる。
- [例題]( https://atcoder.jp/contests/npcapc_2024/tasks/npcapc_2024_i)

#### DPにおいて、dp[i] * x[j]のようなことを繰り返す時
- 係数を取り出して [1]係数の和を求める(今回で言えばx[j]の和) [2]本データと掛け合わせる　とすると、和を求めるパートの高速化に気づきやすい
- [例題](https://atcoder.jp/contests/arc059/tasks/arc059_c)
#### DPのループ順の変更による高速化
- [例題](https://atcoder.jp/contests/arc059/tasks/arc059_c)
    - 前状態固定→今状態固定→今状態の計算
        - ループ3乗
    - 今状態固定→今状態の計算→前状態固定
        - ループ2乗
        - 積の和の構造が背景にある（先にそれぞれの項で和を取っても構わない


#### DPの計算時、もしif文の中にループ変数が入っているならば、そのループが何回まわるかを見る
特に、 if(i == 0) 等のループは1回しか回らない。よって、その中身だけ大量の計算量をかける事が許される。

#### 有効な遷移が少ない時
- 遷移を管理しながらdp
- 最短経路に帰着。辺を遷移に対応、頂点を状態に対応する。

- 独立な遷移を分解して、それぞれについて調べる
    - 次元が落ちることにより、高速化が見やすくなる
        - グリッド上・正方形について調べる...角の点を一つ固定すれば、相手は斜めの対角線上←直線の問題
        
<br><br>

## 時間軸を加えるdp
- 挿入dpは操作の順番に結果が依存するような時の全探索として強い
    - 最初or最後に操作する要素を全探索するようなdpであった
    - 逆に、順番に依存しないなら区間dpで無くて良い

- 順番に依存するような状況であっても、区間dpをしなくても解ける場合はある
    - 所謂挿入DP
    - 最後の要素をi番目とできるか、が高速に判定できれば$O(N^2)$がとりあえず回る
        - 区間dpのとりあえず$O(N^3)$よりも高速
        - [隣り合う要素について、大小関係の制約](https://atcoder.jp/contests/abc209/tasks/abc209_f)
            - 区間dpでもO(N^3)で解けるが、そこからが見えない
            - 制約が隣り合う要素についてだけなので、左から追加していくと、隣の要素がどこにあったかを判定できればO(1)で遷移できる

## mapで状態をもつdp
- 必要なこと: keyの母集団に対して、実際にkeyが取りうる値がオーダーレベルで少ないこと
- いつ考える: 高速化したい時。特に、「dpでOOの情報が必要なので、取り敢えずそれをkeyに追加した」という時、よく考えたら取りうるkeyが少なかったということが良くある。

## 未来の決定を保留するdp
- 必要なこと:今保留しても、選択肢・遷移が変化しない（決定する必要がない）
- いつ考える: 未来に探索する範囲にまで影響がある時
    - その影響を持っては状態量が多くなるが、決定を遅延させれば多くならない
    - ただし、影響を一意に決定できるなら先に処理してしまった方が良い（原則）
        - この場合、遷移が1通りの時？

## ちょっと変なdp
- 探索で、「最後だけ」条件が変わる...最後の一手前までdp
    - [例題](https://atcoder.jp/contests/abc364/tasks/abc364_e)
        - 最後だけ、リミットを飛び越えて良い←最後に何を食べるかに寄る
        - 最後の前は、「リミットを飛び越えない様に食べる」←食べる順に寄らない

## nxtdp
- 変な初期化をやりやすい
    - 配列のdp[-1]を埋めたいなぁみたいな時、それができる
# 最適化のdp

## 違法遷移
dpは、dpテーブルが正しく求まっていく事さえ守られれば、どのようなdpを立てても良い。特に最適化では、重複した遷移・本来は許されない遷移も、計算量削減・考察の軽減のためにゆるす場合がある
- 必要な事: dpテーブルが正しく求まる事
    - これが保証されないと訳がわからない
        - 最適解が探索に含まれ、かつ、元の問題設定より有利になるような遷移がない事
- いつ使う: 厳密にやると情報の取得がめんどくさい・まとめて遷移したい等
- [最適が含まれるのでokな例](https://atcoder.jp/contests/abc176/tasks/abc176_f)
    - dp[i][BS] := 少なくともペアの片方にiが含まれる時、もう片方としてあり得る集合をBS
        - ペアについて、含まれうる添字全てに反映しようと間に合わない
        - 任意のペアがテーブルのどっかにあれば良い
        - 配るdpを考えて、そこから派生する任意のペアがi+1のドッカに入れば良い！
            - この制約の元、都合の良い(bit set orで更新できる)ようなところにだけ更新する

## ダイクストラdp
- dpの遷移にループがあろうと、最適化ならばもとまる場合がある
    - 添字の昇順では無く、値の昇順に埋めていく。

- 必要な事: コスト最小の始点がある・ダイクストラ風味にできる
- いつ使う: ループがあって、どう埋めていけば良いのかという時
<br><br>

## 指数の肩を1/2にするテク
いわゆる半分全列挙
- 嬉しい: 全探索が間に合うようになり、全探索を適応できるようになる
    - 厳しい問題も解ける
- 何が必要: 探索空間を2つに分けた時、その結果を適切な前処理を元に高速に融合できること。
- いつ使う: 数字が/2にさえなれば全探索が間に合う・全探索が少し間に合わない時
- [dpが厳しいが、半分全列挙で全探索的に解ける](https://atcoder.jp/contests/agc026/tasks/agc026_c)
    - 2 ^ 36は間に合わない
    - 組み合わせ全探索も微妙に間に合わない
        - しかし、dpは難しい
        - 必要条件的にアルファベットを順についかしていく等も考えられるが、うまくいかない
        - 半分全列挙ができる
        - 必要: {赤文字列、青文字列} := その通り数　のテーブル
        - できる

<br><br>

## 二分探索/尺取り法
列に対して、「lを定めた時、条件を初めて満たすrは？」を求めたいというのは良くある。
以下の二つとも、何が単調なのか考えること。
- ここを曖昧にすると混乱する
### 二分探索
- 使える必要条件
    - 区間クエリが高速に捌ける事

- 特記事項z
    - 区間クエリさえ捌ければまあ使える
    - 全てのLに対してではなくても、特定のlに対してだけ$O(log)$で求めることができる
### 尺取り法
- 使える必要条件
    - rがlに対して単調なだけでなく、一般に区間の"広さ"に対して単調性がある事
    
- 特記事項

    - 全てのLに対して求めるアルゴリズムであって、特定のlに対してだけ求める事はできない
    
    - 区間クエリが高速に捌けなくて良い
        - 差分を更新するような計算の時、二分探索では解けずに尺取り法によってのみ解ける
            - 転倒数 >= K を満たす部分列の数え上げ...
            - [特殊な形のsum >= Kとなるr](https://atcoder.jp/contests/abc337/tasks/abc337_f)
                - x = 1...nに対して、|xが登場する回数|/K を求めsumを取った時、それが初めてKを超えるrが知りたい
                    - この区間クエリは高速に捌けない
                        - 明らかに、区間長に対して単調
                    - 尺取り法で求められる

    - 区間長に対する単調性さえあれば、毎回区間クエリを飛ばしたとしても二分探索より早い
<br><br>

## テクニック

- **配るdpしか試してないなら、貰うdpを試す**
    - 定番 && 非自明オーダー落ちも多い

- dpのkeyと中身をswapする
    - 中身の値の範囲が小さい時、オーダーが落ちる
        - [例題](https://atcoder.jp/contests/abc364/tasks/abc364_e), ナップザック
        - [それをすると高速化が見える](https://atcoder.jp/contests/abc176/tasks/abc176_f)
            - dp[i][j][k] := 残り(j, k)の時の、今までの値のmax
                - 良く考えると、値は2種しか保存しなくて良い
                - dp[i][val] := 今までの値がvalの時の、あり得るペアの集合
                - **集合を持つdpはbitset高速化!**
                - dp[i][val][l] := 今までの値がval, ペアの片方がl, あり得るrの集合をbitsetで持つ
                - 間に合う
- **lcmを含む式はgcdの式にする**
     - **lcmと違い、gcdは数が少ない**
     
- **操作のどれを1段階とするかは自由に決めて良い(DPと同じ)。特に、操作をさらに細かくすることで1回を軽くすることもある。**

- **「明らかに調べなくて良い」「これだけは別途楽に計算できる」事を事前に省いた結果、実は計算量を劇的に減らすことがある。主に最適化の文脈。**
  -最悪ケースを考えると気づくかもしれない
  
- **答えの個数・値が小さいなら、探索範囲をせばせて良いかも**

- **「bit/素因数ごとに分ける」と「分けずにまとめて計算する」**

- **dp...「extraな計算が何回起こるか知りたい」→[不変量]どういう状況でその計算が走る？特に、その計算が走る時に必ず減るものはないか？**

- loopの枝刈り...下からも絞ると効果覿面
- loopの中のcontinue...事前にloopの範囲を狭められると高速化。特に、loopの中がO(1)とかならオーダーレベルで速くなる場合。


- **線形漸化式なら行列累乗**
    - いつでも使える
    - [例題 : グラフの問題](https://atcoder.jp/contests/abc199/tasks/abc199_f)

- **std::set**
    - 割と簡単にfastsetに変えられる

- **unordered_map**
    - reverveする
    - アクセスする時はキーが存在するか見てからやる

- 全ての2ペアについて見るのは $O(N^2)$ だが、 同値類をまとめる作業は $O(N)$
    - 感覚的な話で良い
    - [使っていそう](https://atcoder.jp/contests/abc348/tasks/abc348_f)

- 連続したら、長さだけボーナス
    - 一つ前と同じならボーナス
    - [例題](https://atcoder.jp/contests/arc010/editorial/6566)
    - +演算の、寄与の分解と見れる


- A[a+b] = f(A[a], A[b]) の漸化式から高速にn項目を求める
    - 再帰関数にすると簡単

- 逆元がない時の $\sum r^i$
    - 上に帰着
    - S[a + b] = S[a] + r^a S[b]


- 2次元のdp
    - 平面操作
    - 最適化なら、inplaceを疑う
        - しなくても答えが変わらない遷移を無視する
        - [例題](https://atcoder.jp/contests/abc369/tasks/abc369_f)
            - 横に移動するのは、コインを取る時だけとする


- 逆元がない時
    - 等比数列の和
        - 割れないかも
        - 漸化式なら逆元がいらない

    - なんか立式した際に分母があるならば、その分母とmodが互いに素でないならば、消さないといけない
        - 別の解法: 漸化式
        - あるいは、分子を割れるなら、割った後の分子を考察する

- 単調増加列の個数は結構小さい！
    
## 実装
添字に持つ情報と遷移に必要な情報の形が違う時は、最初に情報を変換してから遷移の計算を考える
- [添字は時間、遷移は個数](https://atcoder.jp/contests/abc374/tasks/abc374_f)
    - 添字...時間tまで見て、ｒ個残っている
        - k個運ぶとする
        - 次の時間は? <- 一回、個数の添字を経由しないと難しい
        - よって、今添字いくつまで運んで、次添字いくつまでを運ぶのかを最初に計算すると早い
