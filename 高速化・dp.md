- 多項式のdpが立ったら、基本高速化をねばっこく狙う！
- ここに書いた高速化は他の解法にも共通して使える

### 1回の処理ならば間に合うが、それを複数回やることから間に合わない時
- 二分探索・三分探索によって、処理の回数を減らす
- 差分を更新していくことによって、処理の時間を減らす
- 1回の処理の時間をより速くする
- データ構造に頼る
- 極端なケースのみ見ればよい 
    - 区間DP : 端を選んだ時だけ見る
        - 通るならok
    - 分割は分割でも一番短い分割だけ試す
        - 答えの中に、一番短い分割をした物が存在することをいう
    - 2分割だけ試す
        - 偶数分割しかできない為、必要に応じて統合すれば2分割で可能性の判定ができる等

<br><br>

### 処理の仕方に自由度がある時
- 計算量の軽い方の処理を常に選ぶことで、一度の計算量が大きいにも関わらず全体の計算量が抑えられる場合がある
    - マージテク
    - 方針が異なるのに計算量が同じな解法のペアがある時に、それぞれに有利な処理を任せることで $O(N\sqrt{N})$
        -  dpの貰う・配るの両立
        -  軸が違うdp
        
<br><br>


# 前計算による高速化
## 関係の前計算・独立性の前計算による高速化
dpの遷移のたびに条件を確認するのではなく、前計算によって最初から"取りうる状態"を追加していく。
- [dpの遷移時に条件を判定せずに、条件を満たすような組みを先に計算して、それをグループで一気に追加することによる高速化](https://atcoder.jp/contests/abc352/tasks/abc352_f)
    - dpのたびに違反していないかを確認すると計算量爆発
    - 制約を前処理しよう
    - 関係性が張られている頂点どうしを辺で結び、それを一気に追加することにする
    - もはや制約を見なくて良い！高速化
    
## 答えの固定による前計算によるシュミレーションの高速化
- このようなことができるので、普遍的なパラメータの固定は他の固定よりも前に持っていくべきである。

## テーブルを前計算して、適宜修正することで欲しい情報を得る
- 似たような状況で似たような情報をなん度も欲しい時、毎回1から計算するのではなく、テーブルをまず高速なアルゴリズムで求めて、そこを修正・参照する方法で情報を得る事で間に合わせる事ができる。
    - 必要: 修正点が一様(データ構造で高速に対処できる)
    - 嬉しい: 全体を計算する時に使える、高速なアルゴリズムが使える
<br><br>

# 差分更新して情報を維持・そのための探索順の変更
- 一から計算せず、差分を更新していく手法で解く事はよくある
    - 必要な事: 情報の変化を高速に反映できる
- このとき、情報の変化を少なくするために、探索順を変える・工夫する必要が出る場合がある

<br><br>

# 解法を使い分けて高速化する
- 必要なこと: 
    - 計算量が違う解法が2つ以上あって、それぞれについて得意なケースを割り当てたら全体が高速になること。
    - 「値がなんであれ高速だが、種類が多くて全部は無理」と「値が大きい時、特に高速」があって、小さいケースを「値がなんであれ高速」に投げられること。
    - 「特に時間がかかる」というクエリの種類が少ない時、クエリの処理をもらう・配るにしてどうにかする
        - 計算量が異なるについて: 特に、与えられた文字を使ってオーダーを表すと同じだが、実情は違うという事がある    
        - 例えば、グリッドの問題で「マス目の数」と「コマの数」は、どちらも 縦 * 横　で抑えられるが、これらが一致しない時オーダーレベルで（どちらかが）ずれている評価になる
            - この「オーダーレベルのズレ」が常に一方の解法で起こる時にこの解法の使いわけで高速化される。よって、見やすさを重視し、問題文で与えられた変数でまとめるのは危険
    - よって、普段から、計算量を考える時は「ギリギリまできつい」評価をしなければならない    
    - いつ考える: 高速化のために、試行錯誤した結果、上のように、「ギリギリまできつい評価をした結果」オーダーが異なる解法が2つ以上出た時。

    - [bの全探索 or b進表記の全探索](https://atcoder.jp/contests/abc044/tasks/arc060_b)
        - bを1つごとに $O(log n)$ ぐらいで常に。できる
            - 全部やったら間に合わない
            - sqrt(N)以下なら間に合う...他の、bが大きい時に有利な解法は？
            - b進表記で全探索
    - [要素ごとに集計の仕方をもらう・配るで切り替え](https://atcoder.jp/contests/abc219/tasks/abc219_g)
        - 次数が少ない人は愚直で良い。それで間に合わない人は少ない。
            - 少ない人に配る
            - 配るなら遷移が少なく、もらう側は確実に配られているのでO(1)。配る人は、集計に愚直で見て良い。
<br><br>

# 枝刈り

## 無駄なものを探索してしまう時
- もし「無駄な探索」の計算量が抑えられないならば、無駄なものを探索したことによって、何かしらの計算量削減をする必要がある
    - 枝刈りを考える


<br><br>

# DP
嬉しい事: 計算結果の再利用、または纏めて計算する
- これによって、探索区間が広くても、その全てを探索することができる
- 必要なこと: 
    - 探索空間がDAGであること
        - 問題のサイズが小さくなっていけばdag
            - **特に、極端なもの/新たに考慮することにしたものについて場合分けすることによって、問題のサイズが小さくなる場合が多い！**
            - 探索の過程で、単調に変化するものがあればそれを軸にしてできる
            - 順々に決める...x座標や時間軸が単調に増加していく...
    - 探索したい全ての状態が、dpの遷移で含まれること
    -  (重複を許さないならば)1つの探索対象が、dp重複して探索されないこと
        - ⇔任意の探索対象について、探索の任意の段階において、2つ以上の状態へと分かれて遷移することがない
            - 気づき方: 重複しやすそうな探索対象を一つとって、手でdpしてみる
            - 例: (1, 2)を、要素数1の集合に分解した集合族の個数は？
            - dpで一つずつ集合に分解すると、 ((1), (2)) において、 $\emptyset$ -> (1)/(2) となり、最初の遷移で2つに分かれるためダメ
    - また、高速化した（遷移をまとめた)dpにおいて重複が発生するという場合、元々のdpにおいても重複している可能性が高い
        - 高速化が原因と思って混乱しないこと
            
- 遷移をちゃんと数式にして考える
    - 様々な高速化の基礎

- いつ使う: まず最初に考える
    - ほぼ全探索

- 正しく定義するためのtips
    - dp[i]:=iまでだけ考慮した時、全体のスコア　だとしっくりこない時がある
    - dp[i]:=iまで決めた時、iまでの要素の寄与の合計　とするとこれはとりあえず意味を持つ値で、上手くいきやすい
## 設計・状態をまとめて探索
- 素直に設計して、高速化する

## 同じkeyに入っている遷移は問題の設定かで同質である・同一視できないといけない
- よって、同一視できてないと思ったら、同一視できていることを再確認したりdpの定義を変える必要がある  

- [かけてM以下](https://atcoder.jp/contests/abc239/tasks/abc239_h)
    - 商列挙の考えを同一視に用いたい
    - M / xの値の個数は小さい
    - ある値を見た時、「k以上の値をかけたら超える」が一位に定まる => 問題が小さくなる
    - $\lfloor \lfloor M/i \rfloor /j \rfloor = \lfloor M / (ij) \rfloor$ より小さくなった問題の個数は結局 $O(\sqrt M)$ 個
    - 演算2回が演算1回で表せる => 結局値の範囲が広がらないことが言える
        - 状態数の見積もりに使える

## 設計・再帰的に解く時
- 必要なこと: 状態を、うまく繰り返されるものとして選ぶ必要がある
    - **特に、初手の結果で場合分けすると問題が小さくなる、は頻出**
    - 特に、「新たに考慮するようにした要素（順序がないなら一つ適当に選ぶ: 集合dp）」について、その要素で場合分けすると、自然とサイズが小さくなる場合が多い

- いつ考える:  全探索したい -> dpで高速にやりたい -> どういうdpを立てたら良い？がすぐにわからないとき

    - [辺をはる。入・出次数が定まっているとき、集合Sが一つの連結成分になるような変の貼り方](https://atcoder.jp/contests/abc321/tasks/abc321_g)
    - まず、S内で辺が収まるような貼り方の場合の和は簡単
    - Sの要素を1つ取って、そいつが含まれる連結成分のサイズで場合分けしよう
        - それを引いていけば答えが求まる

- また、問題の対象がなんらかの理由で独立になった場合、そこを区切りとして問題を分けることで問題のサイズを小さくするというのは良くある流れである。
    - [全体にaddしない <- 操作が来ない行がある <- 独立に解けば良い](https://atcoder.jp/contests/abc233/tasks/abc233_g)
        - [sy, ty)*[sx, tx)を状態としてもてば良い
            - 来ない行・列を両方固定すると $O(N^6)$ だが、テーブルが豊富なので、実は固定は別々にやって良い
        
- 問題文で与えられているものがあるなら、それを利用すると丸い
    - 辻褄合わせというのは　「自分の定義したやつなら求められるぞ -> 実際のゲームは初手にOOできるじゃん -> それ反映するために定義ずらす/状態量増やさないとダメじゃん -> あばばばば」
## 探索対象が曖昧な時：固定した時の探索
- OOなものに対して探索せよという問題は多い
    - ex:操作によって、回文が作れるか？
- この時のよくあるパターンとして
    - OOの特徴づけから攻める
    - 上手い特徴づけがわからず探索が立てられない時: OOに含まれるものを1つ具体的に固定した上で探索を考える。その上で、その判定法を元に、全てのOOに対して探索を平衡に(まとめながら）進めるというアプローチが有効
## 無限に続く探索
- dpをしようにも、探索が無限に続くのでテーブルのサイズも無限といったことがある
- この時、探索の進度を軸に持たないようなdpテーブルを作れることがある
    - 探索に終了がない・他の情報で終了を判定でき、かつ答えも計算できる
        - 往々にして、添え字を消すとDAGではなくなるが、それでももとまる場合が多い
        - ダイクストラケース
- いつ考える: 特に「探索の終了判定にどこまで遷移したのかが・今何個埋めたかが必要ない時」、具体例としては「任意桁の整数を全探索したい時」
    - いつも必要な理由 <- 桁によって遷移が変わることがある、および（多分ほとんどの場合で共通するのが）探索の終了の判定に用いる
    - よって、例えば、「任意の桁の整数を探索したい」という時、桁の情報をロストさせても終了条件に桁がないので困らない
        - 桁が大きくなる事を考えると都合が良い
    - では何を持つのかというと、「探索の途中で、未来に向けてもつべき情報」のみを持つ。かつ、進度を持たない。
    
    - [文字列・末尾追加の探索](https://atcoder.jp/contests/abc264/tasks/abc264_g)
        - 何文字追加したかどうでも良く、状態が末尾2文字になる
            - 文字数消すとDAGではなくなる
        - 遷移をグラフで考える
            - 再長距離...ベルマンフォードでもとまる（符号flip）
    - [文字列連結](https://atcoder.jp/contests/abc175/tasks/abc175_f)
        - 使用個数に制限をかけられず、長さに制限をかけられない
            - 特に: -1の時
        - 回文を固定した時、それが作れるかの判定をdpにしよう
        - 必要なもの: いくつはみ出ているか
            - 有限サイズのテーブルができた
            - ダイクストラで埋まる
## 探索対象のかどうかの判定をDPにする・まとめて判定する
- 必要条件の考察 -> 探索範囲の削減　とは違う
    - これは状況が複雑な時にやる整理
- 必要な事: 探索対象かの判定が答えにつながること。特に、見つけたい対象を1つ選んだ時、それがアリエルかを判定できる方法なら何でも良い。
- いつ考える: 特に、探索的に・遷移の状態を持つdpで間に合わない時。
    - 成功パターン: 
        - 同じ結果になる遷移がたくさんある時、非常に有効。
            - dpが State: bool の時に特に使いやすい(Stateが同じものを重複して数えない・無視して良い。種類数や、あり得るものの数え上げ）。数え上げだと重複無視してはいけないかも。
            - 最適化も、あり得るかを解けば解けるので、比較的ハマりやすい
        - 探索的にやるのでは途中で持つ情報が多いが、結果の判定は楽な時

- [集合:　部分集合のgcd数え上げ](https://atcoder.jp/contests/abc191/tasks/abc191_f)
    - 探索的にやる...無理そう。あり得る終端は？
        - 選んでないやつのmin >= 選んだgcd
        - これは必要十分ではあるが、使いづらい -> もっと別は無いか？
        - 良く考えると、 min(A) >= 選んだgcdも必要十分       
    - あり得るgcdを列挙したい
        - $O(Nd(A_i))$には収まる   
    - dp[g] := gcd = gがアリエルかで配る...大抵の遷移が、gcd = 1に行く
        - ここでも探索的にやると間に合わない
        - 数え上げ、つまりgcd = gがあり得るかを判定したい。
        - gcdの判定: 全てのgの倍数のgcd = gならok, else ng
        - これをやろう
    - dp[g] := gの倍数全てのgcd   

## 纏めて計算する事による高速化
dpの基礎理念の一つ
- 高速化する上で普遍的に有効
- 何らかのパラメーターが一致・遷移の係数が同じなどに、纏められて一気に計算できる場合がある
    - 例: 毎回 dp[i][1] += 2 * dp[i - 1][1] 、 dp[i][2] += 2 * dp[i - 1][2]の場合、
    - dp[i] := dp[i][1] + dp[i][2] が高速に求められる
        - 最終的に求める値が得られるのなら、こっちで良い
      

- シュミレーションでももちろん有効
    - パラメーターが変化しない区間をまとめる場合
        - [例題](https://atcoder.jp/contests/arc091/tasks/arc091_d)
            - A -> A - A / K - 1 を繰り返す
            - A / Kが同じ区間の操作をまとめよう
                - パラメータが変化しないより、操作は単調で計算しやすい
            
            - 計算量が$O(\sqrt A)$になってhappy
                - 示す際は、$\sqrt A$を閾値に場合分けすると良い
                    - 天下り的


# 遷移に注目する高速化
## 遷移の　細分化　⇔ 統合
- 所謂、細かく遷移・まとめて遷移
- 細かく遷移
    - 必要なこと: 細かく遷移しても、持つべき状態数が爆発しない
    - 「まとめて計算」の典型例
        - 大きく遷移することにすると、「前半は同じ」或いは「後半は同じ」な遷移も別々に計算されてしまう
        - 細かく遷移することにすると、そう言うのを共通化できる
        - いつ考える: 高速化したい時で、「大きく・たくさんのものを一度に固定して遷移する」「候補を列挙して遷移する」をしている時
             - [1 ~ 10の分かれ目を全て固定するのではなく、分かれ目を1つずつ決めていく](https://atcoder.jp/contests/abc292/tasks/abc292_g)
            - 左から見ると、独立風味になっていて、結局「今注目している行を[1, 1, 2,2,3,3,3,3,5]のように単調に埋める遷移をする
            - この時、全ての分かれ目を一度に固定すると、単調増加列の個数だけ場合の和
            - 「今何まで決めた」「最後にここに切れ目入れた」を状態に持つと、せいぜい高さ * 種類数 の多項式にまで落ちる


- 複数段階をまとめて遷移
    - 必要なこと: 求まる
    - いつ考える: 基本的に細かく遷移より遅い。その間の遷移を全探索する必要があり、そこをまとめる事ができないため。しかし、細かく遷移しては持つべき状態数が多くなるという時、「一様な部分について、まとめて考える」と言った思考によって、状態数が少なくなる場合がある。ここで特に遷移も間に合うようにできると、こちらが有利になる
        - 細かく遷移と比べて危険なことは承知すべき
        - 特に、「まとめて遷移することにしたが、状態が減ったわけではない」という時に危険
        - [遷移の中で、イベントが起こるのが45回しかない -> その間をまとめようとすると、状態O(n)遷移O(n)になってしまう。細かくやると状態O(n)遷移O(1)](https://atcoder.jp/contests/arc084/tasks/arc084_b)
    - まとめて、の粒度にも自由度がある
        - 基本的に細かく遷移するが、ある種類のものについて処理し終わった時点で、1回dpテーブルを集約するようなまとめ方
            - [種類数によって価値up ナップザック](https://atcoder.jp/contests/abc383/tasks/abc383_f)
                - 基本的に、選ぶ・選ばないでやる
                - ある種類のものを全て見終わったら、全ての遷移を「まだ今回のを選んでない」に変える
                - これを繰り返す
                
    - 前計算によって、まとめて遷移する際の係数がもとまっているならば細かく遷移するよりも速くなる場合がある
        - 前計算をする動機とその内容

## 遷移を纏める
- 係数が同じ遷移は、いちいち分けて遷移せずにまとめてやりたい
    - 特に、係数1のケースは多い

- 固定したいものが多い場合がある。
    - 答え（値）を特に大きく特徴づける要素だけ固定して、他は「それを固定した時、それが取りうる値の範囲」を出すと「一部だけ固定した時、アリエルパラメーターは？」が解けて、結局そのパラメータは固定せずにまとめられがち

## 配るdp -> 貰うdp
往々にして、非自明高速化がされる
- いつ考える: dpを高速化したいならいつも

- データ構造に相性が良かったり
    - 配り先が区間/貰い元が区間は両方あり得て、これは対等

- 無駄な遷移を省く高速化
    - topK探索。元から最適だけを選んでpopを繰り返す

- 遷移先が共通しているものが多いという時、その「先が共通した遷移」をまとめてできる


## データ構造を使う高速化
- 必要な事: 遷移がデータ構造に載る
    - 多くの場合:区間
    - 他slope trick/1次関数max/fps:inv
- いつ考える: 高速化したい時に、その1手として。また、「とりあえず愚直を書いた」時に見るべき。

- dp[state]からの遷移が区間
    - imos, 遅延セグ木
- dp[state]への遷移が区間
    - 累積和、セグ木

- [愚直なdpを書く -> 遷移先が斜めの直線4つに分解できて、imos](https://atcoder.jp/contests/abc265/tasks/abc265_f)


## 遷移を分けて計算する
- 2種類の遷移があるという時、それらを同時に処理する必要がない・別々に遷移して良い場合がある
    - 例: 加算
    - 例： max
    - 例: $dp[i] = max(dp[j] + C[j], dp[j] - C[j]) のような場合、まず dp[j]+C[j]でchmaxしたのち、dp[j] - C[j]でchmaxして良い

- そのような時は、別々に処理する事で遷移が単純になり、高速化がなされる場合がある
    - あるいは、計算量が良くなる（データ構造の利用、列をreverseして2回...）

- 必要な事: 遷移を分けて計算して良い
- いつ使う: 積極的に使う。
    - 一般に、独立に処理して良いなら、個別に処理した方がやりやすい。

- [bitdp、2種類の遷移。片方はダイクストラdp](https://atcoder.jp/contests/abc364/tasks/abc364_g)
    - ダイクストラdpの方はループがあり、ややこしい
    - 部分集合列挙の方を先に処理してしまって、その後にダイクストラdpに集中する

## 探索の順・軸の変更
- 判定に用いる情報が少なくなるように軸を変更すれば、当然それによって解ける場合がある
    - 挿入dpなりなんなり、多くのdpにはindexの昇順・降順 / 値の昇順・光順がバリエーションとしてある
- なんか特殊な考察をする前に、これを検討したほうが良さそう
    - 必要な事: 後の為に必要な情報が少ない事
        - これさえ満たせば良い。かつ、バリエーションが結構ある上、思いつきにくいものでもない。
    
    - [辞書順の制約、たくさんの列 <- 列の前から埋めていく](https://atcoder.jp/contests/abc292/tasks/abc292_g)
        - 行ごと埋める...どの桁がどの数字？を覚えないときつい
            - 初めて超える行を固定したとしても、場合の数が綺麗にもとまらない
        - 行ごとに埋めずに、列ごとに埋めていくと、問題が独立になって解けるらしい
    - [整数に対し、末尾への数字のaddを1段階の遷移と見る](https://atcoder.jp/contests/abc222/tasks/abc222_g)
        - x -> 10x + 2
        - [無限桁の場合](https://atcoder.jp/contests/arc084/tasks/arc084_b)
            - dp[i][m]...i桁で mod K = m の時、けた和のmin
                - iは終了判定にも遷移にもいらない -> 消して良い
                    - dp[m] ... mod K = m の桁和のmin 軸の添字を消してもdpが回るタイプ


- 意味のない遷移が多かったり、有効な遷移以外にも「遷移の候補」について判定していて上手くいかない時は、有効な遷移の集合の構造について考察すると良さそう
    - 特に、有効な遷移だけ実行するようにする
    - この時、遷移全てが復元できる必要はない。答えを求めるのに必要な情報が欲しい。よって、その意味での構造であり、条件ではない
        - 係数が同じ遷移をまとめる考えを使うと、例えば遷移が存在する要素の個数だけ知りたくなる
    - [集合の数え上げ・要素を見る順を決めない](https://atcoder.jp/contests/arc146/tasks/arc146_c)
        - どんな順で要素を見ても、「それをaddしてよいか」の判定が「奇数サイズの集合のxorと一致しない」になって、そんなの集合を持つしかないのでは、となる
            - そもそもaddして良いかの判定をしていて、有効な遷移ではないものも調べている
        - あり得る遷移の集合とは？「いまaddして良い集合とは？」
            - 奇数個のxorとして表せるもの
            - それだけを遷移しよう
            - 全部係数1 -> まとめて遷移したい
            - こうして初めて、奇数サイズの集合のxorで作れる集合のサイズに目を向ける動機がでる
            - 全部distinctなので、簡単に計算できて、終わる
            - 特に、「具体的にどんな要素がいいか」の情報がいらない・計算できてないが答えが求まっている


## 遷移先の状態数が少ない
集計するものが
- State: bool (重複なし。種類数を・あり得るものを数えよ) -> 判定問題を解いた方が、遷移が減って計算量落ちるかも
- Steta: 数（重複あり） -> 貰う、inline 

## 遷移が行う固定に条件を盛る
- 問題の構造とdpの遷移によっては、自然な定義からさらに条件を追加して良い場合がある
    - [区間dp・数列から削除](https://codeforces.com/gym/105633/problem/L)
        - 素直...dp[l][r]に対し、残す要素kを全探索
        - ここで、削除する問題であることから、kについて「残る要素の中で最右 (= それより右は全て消す）という制限をつけられる
        - 今回は使わないけどいつか役にたつかも
            - 例えば全部消す時は簡単なら
            - dp[r] := [0, r)として、残る中で最右を全探索すれば $O(N^2)$ に落ちるかも
# 状態に注目した高速化



## 遷移の係数が一致するもの状態を纏める
- 遷移の係数が一致するならば、その状態をまとめて計算しても答えが求まる。よって、まとめた分高速化になる

## 添字を減らすことに寄る高速化
- コツ : その添字が"いつ" "何のために" 必要なのか、詳しく考える
    - 最終的な答えに影響する値...途中でdpのvalueを補正することで正しく求まるなら、keyに持たなくて良くなる
    - 寄与が発生した段階で反映できないか?
        - 係数を、初期化でかけてしまっておく
        - dpの最初にだけ必要...計算結果に最初に反映する
        - dpの最後にだけ必要...探索順を逆にする・最後の段階で情報を取得
        - 以降全ての値に均一に補正...今補正できないか？
            - https://yukicoder.me/problems/no/269
            - 問題そのものを、その補正に合わせて言い換え
            - 分割統治に近い
        - [$\sum (コスト)^2$](https://atcoder.jp/contests/arc157/editorial/5841)
            - $\sum (コスト)$ , $\sum 1$ も持てば判定していける
            - 他、 積の和典型と呼ばれるやつで、場合の和に還元してもとける
                - 2個選ぶ...n * nでやろうとすると順序ついpairとなってきつい
                - nC2 と nC1は簡単(今回のを1個選ぶor not)なので、そこから n^2 sumを復元

            - [積の和典型は高次元への拡張が簡単](https://atcoder.jp/contests/arc182/tasks/arc182_c)
                - 式をたくさん用意して考えなくても、「選んだ」の情報を増やすだけで良い
- 他、情報をたくさん持つ時、「ある情報から他の情報が実は定まる・一意に対応するので、添字に持っていた情報が必要ない」という時がある
    - いつ考える: 「遷移の状態・結果の一部」を両方持つ時、状態から結果の一部が導けたりするので、そういう時
        - 高速化以外の目的でも、dpテーブルが小さくなるので嬉しいことが多い
            - 考察の軽減
        - とりあえず何か固定して答えが出るならば固定を緩和できないか考える、という全探索・数え上げの高速化とにてる
        - また、持つ情報に関連性がありそうな時


## 計算に必要な情報の考察によるdpの立式・高速化(持つ情報のロスト)
- そもそも、dpで持つ情報とは、後々の計算・判定のために必要な情報
    - 例: 条件を満たすものをcount -> 最後まで探索した時、これは条件を満たすか？が判定できれば良い
- つまり、dpは、計算方法を元に設計され、そこからまとめて判定だとかいった高速化がなされるもの
- よって、よりまとめる事で持つ情報を減らす・あるいは持つべき情報を特定するには、判定の方法を先に考察する必要がある
    - その考察を元に、dpを設計する
    - 情報量が少なく済むような結果が得られないと意味がない。


- よくある手順
    - 1: とりあえず固定する・持つ情報を増やす
        - 求まるようにする
    - 2: 情報を減らす
        - さっき見繕った情報で、必要ないものを減らす・まとめる

    - [設計: グラフの数え上げ](https://atcoder.jp/contests/abc281/tasks/abc281_g)
        - 条件...頂点1からの距離
            - 頂点1からの距離を求めながらグラフを構築していく
            - 使った頂点集合 -> 使った頂点の数　に情報を落とせて、できる
        
    - [例題](https://atcoder.jp/contests/abc369/tasks/abc369_f)
        - 条件を満たす集合のうち、max
        - 集合を選んだ時、条件を満たすかを考える
        - 右上の関係のがあったらダメ...
            - アルゴリズムではない
            - 役に立たない
            - アルゴリズムにする！
        - dagの関係より、高さでsort
        - xについて単調増加が必要十分
        - あとはLIS

    - [例題](https://atcoder.jp/contests/arc169/tasks/arc169_c)
        - 順番に関係ない->どの?から決めても良い
            - 左からにしよう
        - 一つずつ決めていくか、纏めて決めるか...
        - 判定問題を解こう
            - 同じ数字の区間をまとめて拾って、その長さを見る
            - 纏めて追加の方が良さそう
        - O(N^3)がたつ
        - dpを数式にする
        - 前の結果を利用等色々あるが、今回はデータ構造の利用でおｋ
            - 補集合を取得...全体 - 特定のもの

- また、dpをセグ木に載せるためにモノイドの演算で表したい/分割統治したいなどの都合がある時は、「dpテーブル全体を保持しないでも計算できる」ようなロストを考える必要がある
    - [prefix_sumのみが必用-> テーブル保持しなくても良い(ベクトルで表せる、セグ木に乗る)](https://yukicoder.me/problems/no/8046)
## 判定問題を解く -> dpで持つ情報や軸の考察
dpをする時、その考察として「結果の一部を固定した時、値は何になるか」を考える事が多い
- 操作をして、条件を満たすコストmin -> 操作の対象を決めた時のコストは？等。
    - dpで必要な情報の整理・問題の構造の整理など。
この時、「操作の対象を決めた時のコスト」の計算式に関わる値をdpのkeyにするべき。

- 特に、判定の解で一見「最終的な解の形」が必要になってしまったら、具体的に「最終的な解の何が必要なのか」の「何」をkeyにdpすると良い

- [数列sort <- 操作をする対象を固定すると、「操作をする中で値がmin/maxのもの」を境に操作のコストが変化。つまり、値の大小がコストに関係。かつ、左から決めるdpでは上手くいかないので、値の昇順に決めるdp。](https://atcoder.jp/contests/abc201/editorial/1829)
    - 左から決めるdp...最終的に動かさないやつのうち、あたいのmin/maxが必要になってしまって困る
        - 最終的な形が必要だから、dpできない？
        - 実はそんなことはない
    - 値が小さい方から決めていく。すると、
        - minより小さいやつ...最初のやつを決める時に処理
        - 間のやつ...遷移の時に処理
        - maxよりでかいやつ...dp[v]の時、[v+1~がそれに該当
    - となって、求められる。不思議。
    


### サイズを大きくしていく探索
## 独立なもの同士では一切の情報の共有がいらない -> 分けて計算して、最後にかける(dpにおける独立性)
- こう意識して設計すると計算量が落ちる
    - 顕著な理由: 独立なパートでそれぞれ状態が S, T通りある時、まとめて持ってしまうと S * T通りの状態になるが、分けて計算することにすれば S + T通りとなる。
- よって、判定の時も「こう考えたらあとは独立」と言う構造が見えたら、そのような判定方は上記の手法を守ると上手くいきやすい
    - [大小の判定 -> 左の桁から見る](https://atcoder.jp/contests/abc292/tasks/abc292_g)
        - すると、一度大小が確定したら、もうその行の間では独立
        - 分けて計算しよう
        - f(u, d, j) := [u, d)行目について、[j, m)を決める
            - とすると、多項式。


- サイズを小さくしていく探索の探索順を逆にすると、サイズを大きくしていく探索ができる事がある
    - 所謂後退解析
- 新たにaddした要素の場合分けで注目している問題のサイズを落とすのは変わらないが、後退解析では「今までに計算した結果を元に、今の場合分けの結果を求める」という側面が強い

- 必要な事: サイズを大きくしていくようになっている事
- いつ使う: ゲーム、今の場合分けのどれを採用すべきかわからないdp
    - 今何をすれば良いかがわからないため、状態が膨大な時、後ろから見ることによってすっきり解ける場合がる
    - [根から探索するとするべき行動がわからない -> 逆順（葉から探索）](https://atcoder.jp/contests/abc218/tasks/abc218_g)

## (上手くいかない原因) : （状態、遷移）が細かすぎる かつ 遷移先が多様だという時
**状態の定義 -> それらの間の遷移を考えた時、探索の順序に関わらず、その時の遷移の計算にどうしても大量の情報が必要で結局まとめられないことは多々ある。**
- 数え上げ: addして良いかの判定・係数の計算にとても多くの情報を持たないといけない・遷移の種類が多様である
    - 往々にしてこれは、探索順を工夫することで遷移の形に制限がつき、判定に必要な情報が落ちてdpが計算できたりする。しかし、どんな探索順でも無理だと思うこともある
    - この原因の一つに、「状態の定義 -> それらの間の遷移」という形式において、状態が細かすぎるせいで遷移先も多様化しているという場合がある
    - 状態の細かさと遷移の細かさはある程度対応している

- ここで、答えが求まる範囲で上手く状態の情報をロストさせつつ遷移が計算できるような状態を定義できれば、（情報がロストしたことにより）却って遷移が計算しやすくなり結果的に高速に求まる場合がある
    - シミュレーションなら重要なところだけ抜き出す
    - 数え上げや最適化なら、答えの計算・遷移に必要な情報以外をロストさせる

- いつ考える: 「状態の定義 -> それらの間の遷移」において、遷移が多様すぎたりしてこのままの遷移では情報のロスト・遷移の共通化ができない時

<br><br>

# 探索対象・遷移の構造についての考察
- 状態を持って探索、ではどうにも上手くいかない場合がある

- 探索対象の構造に注目することによって、方向性の違う解法ですっきり解ける場合がある
- 特に、**「条件を満たすものだけ探索する」場合、「条件を満たす集合が必ず満たす構造」を元に探索する・その構造を持つもののみを探索してもよく、その構造によっては問題がガラッと変わる場合がある**
    - 最適化における、最適な可能性のあるやつだけ遷移みたいな
    - 問題を独立なパートに分解 -> それぞれ掛け合わせて終了
        - 1対1対応...独立
    - 意味のない遷移・失敗するかもしれない遷移を省いた直接的な計算
- いつ考える: 状態を持って遷移、では上手くいかない時
    - 特に: 無駄な可能性のある遷移をしている場合
    - 最適化、最適なやつ以外も遷移
    - 数え上げ、将来的に条件を満たさないかもしれない / 遷移の度に、条件を満たすか判定
- 何を考える: 探索対象が満たす、探索に便利な構造/遷移の構造
- [順々に辺を作っていく方針では木を持たないと難しい](https://codeforces.com/gym/105633/problem/D)
    - 探索はわからない
    - 条件を満たす木だけ探索 -> その木の構造とは
        - 辺を固定すると、両方の文字列で作られる必要
        - マージを表す木...全てのi, i + 1について、ちょうど1回そこが繋がる時がある
        - 木が同じ -> マージのgapが同じなら、同じ辺を張るが構造として言える
            - 逆は簡単
            - gapを固定すると辺の1:1対応
        - よって、それぞれのgapについて、同じ辺の本数をかければ終わり
            - 状態を持って探索などしてない

- [条件を満たす集合](https://atcoder.jp/contests/arc115/tasks/arc115_d)
    - 探索はわからない
    - 集合の構造と言われても
    - 遷移の構造...validな遷移の本数が簡単にわかる

<br><br>

## 今までの計算結果を再利用することによる高速化
dpの基礎理念の一つ
- 特に、貰うdpの考え方をする時に頻出
- 今まで計算した問題のサイズと比べて、サイズが大きくなっている要因に触れないようなケースは全て計算済みである
    - **よって、サイズが大きくなっている原因に触れる遷移・探索対象にだけ計算すれば良く、その要素に触れない遷移はわざわざ計算しなくて良い**
    - 例えば、要素の使用/notについて見ていくdpで、左からみていく: [0, r)について考えるのならば、r-1を用いないケースはすでに計算済みなので、r-1を用いるケースに絞って計算すれば良い。


    - [全ての(l,r)についての計算/dp[r]:=\[any,r\)の計算](https://atcoder.jp/contests/arc169/tasks/arc169_b)
        - dp[r] := \[any, r\)の計算をしよう
            - 部分列に分割される...r-1を含まない部分についてはもう計算済み
            - 上手く使う
    
    - [区間dp, \[l, r\)の中から3つ選ぶ](https://atcoder.jp/contests/agc050/tasks/agc050_b)
        - 愚直だと毎回N^3かかる
            - 端を選ばないケースは計算済み！
            - l, rを両方使う場合のみ計算
            - (1)l,rが同時に選ばれるケース (2) l,rが独立に選ばれるケース(区間が2つに分かれる)
                - O(N)で可能になる

- 他に一般に、「この情報を更新して気さえすれば解ける」という時(特に、「遷移ごとに情報を持つ」ことにこだわっていないことに注意)、dpとして「今までに"計算した情報"」を持つことがある
    - 寄与の分解等でよくある。
        -「今まで計算した情報から、今回の情報が計算できる」ことが必要であり、「遷移を纏める」のような発想よりも一般的である
    - 必要なこと: 定義通りの情報が、今までの情報から求まること　であり、特に上の例に注意。 
    - いつ考える: 寄与の分解の時は多い
        - 遷移を持つわけではないので、状態量少ないことがある（全体についてのテーブルを一つ持てば十分）という風に感じる
            - そこまできっちり区別があるわけではなさそう。
            - [すべての遷移に対する、連結成分の情報をテーブルとしてもつ](https://atcoder.jp/contests/arc187/tasks/arc187_b)

- 大部分を共有する、パラメータが異なるクエリについて答えるという場合に、dpの添字としてそのパラメータを追加するということもある
- 必要な事: 問題のサイズが小さくなる事、問題の種類数（dpの添字の数）を少なく抑えられる事
- いつ使う: 常に考えれば良い
    - 前計算より
    - [そういう考え方をする](https://atcoder.jp/contests/abc364/tasks/abc364_g)
        - 新たな頂点vを固定して、それごとに計算するのは間に合わない
            - 差分更新もよくわからない
        - クエリ（集合）が共通...それを添字にしてdpみたいな


## dpしながら答えを集約するタイプの問題
dpしながら、途中でテーブルの値を使って外で計算する場合。
- 集約値が、dpが進むに従って、明示的な変化がないにも関わらず変化することがある.
    - 例えば、寄与に分解する問題で、探索しながらすべての遷移についてなんかのsumをとっていたとする。この時、すべての遷移が2つに分裂したならば、今までの値も2倍になるはずである。よって、ans変数を持っていたら、ans変数の値も2倍しなければならない。 
- 必要なこと: dpの途中結果を外に反映させるなら、「その外の結果の、dpを進めことによる変化」もちゃんと更新しなければならない。


## 遷移の固定・ループを減らす事による高速化
- 特に再帰的に解く時、「遷移の和を減らす・固定の数を減らしても、十分dpテーブルから答えが求められるため、答えが求まる」という場合がある
- 必要な事: 固定を全て試さない・大雑把な場合分けであっても、dpテーブルに載っている程度にサイズが小さくなる事
- いつ考える: オーダーを落としたく、遷移の本数を減らす事によって高速したい時。dpとして持つ情報が多い時（多次元）
    - y, xを両方固定しなくても、y, xを別々に固定すれば十分サイズが小さくなり、dpテーブルに答えが書いてる

## 1番軸となる添字の変更・削除/DPのループ順
**DAGになってるものは全て軸になれる**
- 例: 数列の "i項目" まで決めて, ...


ここで、iが
- 各段階の値の計算には**必須でない・影響しない時** ... **別方針でうまく行ったりする**
    - 探索順を変える...
- **iの他にも、必ず増加する・減少する要素がある**... **iを持たなくてもdpが回ったりする**
    - iが無くともDAGパターン
    - 計算にiが必要ならば、依然iは添字に含む事になる。しかし、**iが必要なかった場合、iを持っていた分計算量が落ちる。**
        - 必要無い典型パターン...項数に制限がない数列・或いは集合の数え上げ
            - [例題](https://atcoder.jp/contests/arc107/tasks/arc107_d)



#### how
- iを落とした上で、新たな軸になるものがある・DAGになっていないか見る
    - とりあえず初期化をする
    - **遷移がDAGになっていたらdpできる！**
        - 最大値は必ず増えていくので...
        - 区間を右端でsortして順に見る事で、区間の右端は常に増えていくので...
            - [例題](https://atcoder.jp/contests/arc026/tasks/arc026_3)


- dpの探索順を変えてしまう
そもそも筋の悪い探索順を選んでいる可能性。
数列を定めると言っても、左から定める必然性は無い。
    - 右から...
    - 大きい値から...
    - 最下位bitから...
    - 終端状態から...
## 考える要素が複数ある時 -> 条件に一番近い要素を軸にすると良いことが多い
- 特に: 結局条件の判定に値の大小が関わるなら、左からではなく小さい・大きい方からの方が良いことが多い

### dpのループ順を変える事で、dpが破綻する場合がある
- 0/1ナップザック
    - 重さの昇順にやると、同じアイテムを2回以上使う場合がある

- 集合への分割・集合のサイズごとに係数を掛けて修正する
    - 集合のサイズを最初の添字に持ってこないと、 + |1|のやつ -> + |2|のやつ -> + |1|のやつ　といった遷移をしてしまう
    - 絶対に逆転してほしくないものは、一番外の添字に持ってくると安全


## 何かしらのパラメータを共有する要素が多い時
そのパラメータごとにまとめて処理することで高速化がなされる場合がある
- [パラメータを共有する中で、必要ないものを捨てる最適化](https://atcoder.jp/contests/abc373/tasks/abc373_f)
    - アイテムを分離できる
        - N^2このアイテム、間に合わない
        - CHTでも解けるらしい...?
    - 重みを共有するアイテムが多いことに注目
    - 重みごとに処理しよう
    - 重みwについて、上位 W / w個しか残さなくて良い
<br><br>




## 状態数 * 遷移が計算量ではない。添字を減らさない・状態量を減らさない高速化/ inline dp
- 必要な事: 更新を、前のdpテーブルを土台に用いる事で高速に行える事。かつ、dpテーブルのサイズが持てるぐらいに小さい事
    - 変化点が少ない場合、では無い
        - 区間変更は大体対応できる。区間が3つぐらいに分かれてもできる。
        - データ構造でカバーできるものは全てできる
    - 特に、最適化において、「ここは更新しなくても良い」という枝刈りを用いて行われる
    - 或いは単に数え上げでも「変化するならば、変化後の状態はこれになる」といったものが絞れれば、そこだけ更新する/ 他は一様に更新する　等とできる。
    - ただし、持つべきdpテーブルのサイズが10^10になってしまい、かつ省略できない時などはそもそも考えられない。

- いつ考える: 全探索を高速化したい
    - 「選んだ・選ばない」dpで、選んだ物の特徴をkeyに持つならば、常にinline dpである。
    - nxtdp(i -> i+1)にしか遷移がない時はやりやすい
    - dpが1次元の時は特にやりやすいが、2次元でもできる
    - 「そのまま遷移する・一意に遷移する」ものはinline dpに乗りやすい
- 多項式のdpがたったならば、それを立式する事・変更が入る添字の量を見ることが必要
    - 多項式のdpは高速化ができれば答えられるし、できる場合が多い。    
    - 遷移の順番でバグりやすいので気を付ける
        - [選ばない場合iが増えるだけ、選ぶ場合遷移先が限られる場合](https://atcoder.jp/contests/abc176/tasks/abc176_f)
            - 採用しない場合、値を+0/1してiを増やすだけ
            - 採用する場合、採用先の添字が絞られる
                - そこだけ丁寧に更新しよう

        - [殆どの場合、dpテーブルがスライドするだけ](https://atcoder.jp/contests/abc372/tasks/abc372_f)

        - [多項式dp -> 遷移を考えると、1箇所にしか変更がなく、その量はprodでできる](https://atcoder.jp/contests/abc279/tasks/abc279_g)
            - できるだけ情報を落とすと、dp[i][last]の形
            - 初期化...dp[i][-n]に来たと思う。prod, addを関数にして包む。
        - [選んだ・選ばないでdp && 最後に選んだ物の色を持つ -> inline dp  状態 * 遷移数 よりも計算量が落ちる](https://atcoder.jp/contests/abc383/tasks/abc383_f)




<br><br>


## 全探索のdp化
**DAGになってるものは全て軸になれる**。
よって、探索の過程で単調に変化するものがあれば、それを軸にメモ化できる。
[url](https://atcoder.jp/contests/abc363/tasks/abc363_f)

- **典型: 考察対象の数を小さくする様式変形** [例題](https://atcoder.jp/contests/arc176/tasks/arc176_b) (ユークリッドの互助方)
    - how ? 
        - modを取る ... 割れるだけ割る
        - gcdは左右入れ替えても良い

#### DPの計算時、ループの外側に出せる計算・if文はループの外側に出すべき
不要な再計算・ループの排除・高速化に気づきやすくなる。
- [例題]( https://atcoder.jp/contests/npcapc_2024/tasks/npcapc_2024_i)

#### DPにおいて、dp[i] * x[j]のようなことを繰り返す時
- 係数を取り出して [1]係数の和を求める(今回で言えばx[j]の和) [2]本データと掛け合わせる　とすると、和を求めるパートの高速化に気づきやすい
- [例題](https://atcoder.jp/contests/arc059/tasks/arc059_c)
#### DPのループ順の変更による高速化
- [例題](https://atcoder.jp/contests/arc059/tasks/arc059_c)
    - 前状態固定→今状態固定→今状態の計算
        - ループ3乗
    - 今状態固定→今状態の計算→前状態固定
        - ループ2乗
        - 積の和の構造が背景にある（先にそれぞれの項で和を取っても構わない


#### DPの計算時、もしif文の中にループ変数が入っているならば、そのループが何回まわるかを見る
特に、 if(i == 0) 等のループは1回しか回らない。よって、その中身だけ大量の計算量をかける事が許される。

#### 有効な遷移が少ない時
- 遷移を管理しながらdp
- 最短経路に帰着。辺を遷移に対応、頂点を状態に対応する。

- 独立な遷移を分解して、それぞれについて調べる
    - 次元が落ちることにより、高速化が見やすくなる
        - グリッド上・正方形について調べる...角の点を一つ固定すれば、相手は斜めの対角線上←直線の問題
        
<br><br>

## 時間軸を加えるdp
- 挿入dpは操作の順番に結果が依存するような時の全探索として強い
    - 最初or最後に操作する要素を全探索するようなdpであった
    - 逆に、順番に依存しないなら区間dpで無くて良い

- 順番に依存するような状況であっても、区間dpをしなくても解ける場合はある
    - 所謂挿入DP
    - 最後の要素をi番目とできるか、が高速に判定できれば$O(N^2)$がとりあえず回る
        - 区間dpのとりあえず$O(N^3)$よりも高速
        - [隣り合う要素について、大小関係の制約](https://atcoder.jp/contests/abc209/tasks/abc209_f)
            - 区間dpでもO(N^3)で解けるが、そこからが見えない
            - 制約が隣り合う要素についてだけなので、左から追加していくと、隣の要素がどこにあったかを判定できればO(1)で遷移できる

## mapで状態をもつdp
- 必要なこと: keyの母集団に対して、実際にkeyが取りうる値がオーダーレベルで少ないこと
- いつ考える: 高速化したい時。特に、「dpでOOの情報が必要なので、取り敢えずそれをkeyに追加した」という時、よく考えたら取りうるkeyが少なかったということが良くある。

## 未来の決定を保留するdp
- 必要なこと:今保留しても、選択肢・遷移が変化しない（決定する必要がない）
- いつ考える: 未来に探索する範囲にまで影響がある時
    - その影響を持っては状態量が多くなるが、決定を遅延させれば多くならない
    - ただし、影響を一意に決定できるなら先に処理してしまった方が良い（原則）
        - この場合、遷移が1通りの時？

## ちょっと変なdp
- 探索で、「最後だけ」条件が変わる...最後の一手前までdp
    - [例題](https://atcoder.jp/contests/abc364/tasks/abc364_e)
        - 最後だけ、リミットを飛び越えて良い←最後に何を食べるかに寄る
        - 最後の前は、「リミットを飛び越えない様に食べる」←食べる順に寄らない

## nxtdp
- 変な初期化をやりやすい
    - 配列のdp[-1]を埋めたいなぁみたいな時、それができる
# 最適化のdp

## 違法遷移
dpは、dpテーブルが正しく求まっていく事さえ守られれば、どのようなdpを立てても良い。特に最適化では、重複した遷移・本来は許されない遷移も、計算量削減・考察の軽減のためにゆるす場合がある
- 必要な事: dpテーブルが正しく求まる事
    - これが保証されないと訳がわからない
        - 最適解が探索に含まれ、かつ、元の問題設定より有利になるような遷移がない事
- いつ使う: 厳密にやると情報の取得がめんどくさい・まとめて遷移したい等
- [最適が含まれるのでokな例](https://atcoder.jp/contests/abc176/tasks/abc176_f)
    - dp[i][BS] := 少なくともペアの片方にiが含まれる時、もう片方としてあり得る集合をBS
        - ペアについて、含まれうる添字全てに反映しようと間に合わない
        - 任意のペアがテーブルのどっかにあれば良い
        - 配るdpを考えて、そこから派生する任意のペアがi+1のドッカに入れば良い！
            - この制約の元、都合の良い(bit set orで更新できる)ようなところにだけ更新する

## ダイクストラdp
- dpの遷移にループがあろうと、最適化ならばもとまる場合がある
    - 添字の昇順では無く、値の昇順に埋めていく。

- 必要な事: コスト最小の始点がある・ダイクストラ風味にできる
- いつ使う: ループがあって、どう埋めていけば良いのかという時
<br><br>

## 指数の肩を1/2にするテク
いわゆる半分全列挙
- 嬉しい: 全探索が間に合うようになり、全探索を適応できるようになる
    - 厳しい問題も解ける
- 何が必要: 探索空間を2つに分けた時、その結果を適切な前処理を元に高速に融合できること。
- いつ使う: 数字が/2にさえなれば全探索が間に合う・全探索が少し間に合わない時
- [dpが厳しいが、半分全列挙で全探索的に解ける](https://atcoder.jp/contests/agc026/tasks/agc026_c)
    - 2 ^ 36は間に合わない
    - 組み合わせ全探索も微妙に間に合わない
        - しかし、dpは難しい
        - 必要条件的にアルファベットを順についかしていく等も考えられるが、うまくいかない
        - 半分全列挙ができる
        - 必要: {赤文字列、青文字列} := その通り数　のテーブル
        - できる

<br><br>

## 二分探索/尺取り法
列に対して、「lを定めた時、条件を初めて満たすrは？」を求めたいというのは良くある。
以下の二つとも、何が単調なのか考えること。
- ここを曖昧にすると混乱する
### 二分探索
- 使える必要条件
    - 区間クエリが高速に捌ける事

- 特記事項z
    - 区間クエリさえ捌ければまあ使える
    - 全てのLに対してではなくても、特定のlに対してだけ$O(log)$で求めることができる
### 尺取り法
- 使える必要条件
    - rがlに対して単調なだけでなく、一般に区間の"広さ"に対して単調性がある事
    
- 特記事項

    - 全てのLに対して求めるアルゴリズムであって、特定のlに対してだけ求める事はできない
    
    - 区間クエリが高速に捌けなくて良い
        - 差分を更新するような計算の時、二分探索では解けずに尺取り法によってのみ解ける
            - 転倒数 >= K を満たす部分列の数え上げ...
            - [特殊な形のsum >= Kとなるr](https://atcoder.jp/contests/abc337/tasks/abc337_f)
                - x = 1...nに対して、|xが登場する回数|/K を求めsumを取った時、それが初めてKを超えるrが知りたい
                    - この区間クエリは高速に捌けない
                        - 明らかに、区間長に対して単調
                    - 尺取り法で求められる

    - 区間長に対する単調性さえあれば、毎回区間クエリを飛ばしたとしても二分探索より早い
<br><br>

## テクニック

### dpの情報について、index vs 個数
- indexが重要な情報の時はindexを持つのが良い
- しかし、index自体に情報はなく、ただ個数だけが必要だという時は、個数で定義しないと上手く回らない事がある   
    - 特に挿入dpのように、配列に挟んだりする問題では、元のindexが役に立たない（厳密には遷移に必要な情報と一致しなくて計算できない）事がある
    - [indexではなく個数をkeyに持たないと遷移が計算できない・個数にするとスッといく問題](https://atcoder.jp/contests/agc065/tasks/agc065_b)

- **配るdpしか試してないなら、貰うdpを試す**
    - 定番 && 非自明オーダー落ちも多い

- dpのkeyと中身をswapする
    - 中身の値の範囲が小さい時、オーダーが落ちる
        - [例題](https://atcoder.jp/contests/abc364/tasks/abc364_e), ナップザック
        - [それをすると高速化が見える](https://atcoder.jp/contests/abc176/tasks/abc176_f)
            - dp[i][j][k] := 残り(j, k)の時の、今までの値のmax
                - 良く考えると、値は2種しか保存しなくて良い
                - dp[i][val] := 今までの値がvalの時の、あり得るペアの集合
                - **集合を持つdpはbitset高速化!**
                - dp[i][val][l] := 今までの値がval, ペアの片方がl, あり得るrの集合をbitsetで持つ
                - 間に合う
- **lcmを含む式はgcdの式にする**
     - **lcmと違い、gcdは数が少ない**
     
- **操作のどれを1段階とするかは自由に決めて良い(DPと同じ)。特に、操作をさらに細かくすることで1回を軽くすることもある。**

- **「明らかに調べなくて良い」「これだけは別途楽に計算できる」事を事前に省いた結果、実は計算量を劇的に減らすことがある。主に最適化の文脈。**
  -最悪ケースを考えると気づくかもしれない
  
- **答えの個数・値が小さいなら、探索範囲をせばせて良いかも**

- **「bit/素因数ごとに分ける」と「分けずにまとめて計算する」**

- **dp...「extraな計算が何回起こるか知りたい」→[不変量]どういう状況でその計算が走る？特に、その計算が走る時に必ず減るものはないか？**

- loopの枝刈り...下からも絞ると効果覿面
- loopの中のcontinue...事前にloopの範囲を狭められると高速化。特に、loopの中がO(1)とかならオーダーレベルで速くなる場合。



- **線形漸化式なら行列累乗**
    - いつでも使える
    - [例題 : グラフの問題](https://atcoder.jp/contests/abc199/tasks/abc199_f)

- **std::set**
    - 割と簡単にfastsetに変えられる

- **unordered_map**
    - reverveする
    - アクセスする時はキーが存在するか見てからやる

- **vector/arrayを載せたmap/unordered_mapは定数倍がやばい**
    - logのレベルじゃない
    - $N = 5000$ で $O(N^2)$ <- メモ化再帰にmap必要ならだいぶ怪しい 
        - テーブルがvectorに乗るなら多分間に合う
- 全ての2ペアについて見るのは $O(N^2)$ だが、 同値類をまとめる作業は $O(N)$
    - 感覚的な話で良い
    - [使っていそう](https://atcoder.jp/contests/abc348/tasks/abc348_f)

- 連続したら、長さだけボーナス
    - 一つ前と同じならボーナス
    - [例題](https://atcoder.jp/contests/arc010/editorial/6566)
    - +演算の、寄与の分解と見れる


- A[a+b] = f(A[a], A[b]) の漸化式から高速にn項目を求める
    - 再帰関数にすると簡単

- 逆元がない時の $\sum r^i$
    - 上に帰着
    - S[a + b] = S[a] + r^a S[b]


- 2次元のdp
    - 平面操作
    - 最適化なら、inplaceを疑う
        - しなくても答えが変わらない遷移を無視する
        - [例題](https://atcoder.jp/contests/abc369/tasks/abc369_f)
            - 横に移動するのは、コインを取る時だけとする


- 逆元がない時
    - 等比数列の和
        - 割れないかも
        - 漸化式なら逆元がいらない

    - なんか立式した際に分母があるならば、その分母とmodが互いに素でないならば、消さないといけない
        - 別の解法: 漸化式
        - あるいは、分子を割れるなら、割った後の分子を考察する

- 単調増加列の個数は結構小さい！
    
## 実装
添字に持つ情報と遷移に必要な情報の形が違う時は、最初に情報を変換してから遷移の計算を考える
- [添字は時間、遷移は個数](https://atcoder.jp/contests/abc374/tasks/abc374_f)
    - 添字...時間tまで見て、ｒ個残っている
        - k個運ぶとする
        - 次の時間は? <- 一回、個数の添字を経由しないと難しい
        - よって、今添字いくつまで運んで、次添字いくつまでを運ぶのかを最初に計算すると早い


## 桁dp
- 桁数を固定して、上の桁から決めるパターン
    - 未満確定と、前半ピッタリ(=1 or 0)を持つ
    - 次の数字を全探索
        - 未満確定は必ず遷移する
        - ピッタリは、nxがoriginal未満or=で遷移
    - 配るならば、数字をチェックする桁が添え字とずれるかも


## 挿入dp

## 1要素目は初期化として置いといた方が良い
最初だけは他と質が違う場合がある
- [罠](https://atcoder.jp/contests/arc178/tasks/arc178_d)
    - 小さい要素から見て、
        - 1.fixされてるやつ...fix間での順序が守られればどこでもok
        - 2.fixされてないやつ...端ならどこでもok
    - で作られるやつを数える
    - fixされてるやつは順序固定 -> 最初から並べておく
    - これで最初のdpをシュミレーションすると?
    - v以下の値より左・右にあるfixedの情報が欲しい
    - 0は初期化!
    - if 0 is fixed ... 埋められる
    - if 0 is not fixed ... どこにおいても良い　埋められる
        - これを、最初以降と同じ枠組でやろうとする->一番ちいさいfixedの横しかありえないとしてずっとバグらせた
### 順番が固定されてるやつ -> 後から挿入せず、最初から並べておく
- 後から挿入よりも計算量が落ちやすい
    - 後から挿入だと、挿入の要素間の情報が欲しくなる -> 全ての区間についての情報の管理

### 挿入で左右の区別 -> 最初の要素に注意
- 最初の要素には左右とかない