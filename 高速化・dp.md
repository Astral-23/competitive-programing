多項式のdpはその時点で尊い


# 前計算による高速化
## 関係の前計算・独立性の前計算による高速化
dpの遷移のたびに条件を確認するのではなく、前計算によって最初から"取りうる状態"を追加していく。

## 答えの固定による前計算によるシュミレーションの高速化
- このようなことができるので、普遍的なパラメータの固定は他の固定よりも前に持っていくべきである。

## テーブルを前計算して、適宜修正することで欲しい情報を得る
- 似たような状況で似たような情報をなん度も欲しい時、毎回1から計算するのではなく、テーブルをまず高速なアルゴリズムで求めて、そこを修正・参照する方法で情報を得る事で間に合わせる事ができる。
    - 必要: 修正点が一様(データ構造で高速に対処できる)
    - 嬉しい: 全体を計算する時に使える、高速なアルゴリズムが使える

<br><br>

# 差分更新して情報を維持・そのための探索順の変更
- 一から計算せず、差分を更新していく手法で解く事はよくある
    - 必要な事: 情報の変化を高速に反映できる
- このとき、情報の変化を少なくするために、探索順を変える・工夫する必要が出る場合がある

<br><br>

# 解法を使い分けて高速化する
- 必要なこと: 
    - 計算量が違う解法が2つ以上あって、それぞれについて得意なケースを割り当てたら全体が高速になること。
    - 「値がなんであれ高速だが、種類が多くて全部は無理」と「値が大きい時、特に高速」があって、小さいケースを「値がなんであれ高速」に投げられること。
    - 「特に時間がかかる」というクエリの種類が少ない時、クエリの処理をもらう・配るにしてどうにかする
        - 計算量が異なるについて: 特に、与えられた文字を使ってオーダーを表すと同じだが、実情は違うという事がある    
        - 例えば、グリッドの問題で「マス目の数」と「コマの数」は、どちらも 縦 * 横　で抑えられるが、これらが一致しない時オーダーレベルで（どちらかが）ずれている評価になる
            - この「オーダーレベルのズレ」が常に一方の解法で起こる時にこの解法の使いわけで高速化される。よって、見やすさを重視し、問題文で与えられた変数でまとめるのは危険
    - よって、普段から、計算量を考える時は「ギリギリまできつい」評価をしなければならない    
    - いつ考える: 高速化のために、試行錯誤した結果、上のように、「ギリギリまできつい評価をした結果」オーダーが異なる解法が2つ以上出た時。

<br><br>

# 枝刈り

## 無駄なものを探索してしまう時
- もし「無駄な探索」の計算量が抑えられないならば、無駄なものを探索したことによって、何かしらの計算量削減をする必要がある
    - 枝刈りを考える


<br><br>

# DP
嬉しい事: 計算結果の再利用、または纏めて計算する
- これによって、探索区間が広くても、その全てを探索することができる
- 必要なこと: 
    - 探索空間がDAGであること
        - 問題のサイズが小さくなっていけばdag
            - **特に、極端なもの/新たに考慮することにしたものについて場合分けすることによって、問題のサイズが小さくなる場合が多い！**
            - 探索の過程で、単調に変化するものがあればそれを軸にしてできる
            - 順々に決める...x座標や時間軸が単調に増加していく...
    - 探索したい全ての状態が、dpの遷移で含まれること
    -  (重複を許さないならば)1つの探索対象が、dp重複して探索されないこと
        - ⇔任意の探索対象について、探索の任意の段階において、2つ以上の状態へと分かれて遷移することがない
            - 気づき方: 重複しやすそうな探索対象を一つとって、手でdpしてみる
            - 例: (1, 2)を、要素数1の集合に分解した集合族の個数は？
            - dpで一つずつ集合に分解すると、 ((1), (2)) において、 $\emptyset$ -> (1)/(2) となり、最初の遷移で2つに分かれるためダメ
    - また、高速化した（遷移をまとめた)dpにおいて重複が発生するという場合、元々のdpにおいても重複している可能性が高い
        - 高速化が原因と思って混乱しないこと
            
- 遷移をちゃんと数式にして考える
    - 様々な高速化の基礎

- いつ使う: まず最初に考える
    - ほぼ全探索

- 正しく定義するためのtips
    - dp[i]:=iまでだけ考慮した時、全体のスコア　だとしっくりこない時がある
    - dp[i]:=iまで決めた時、iまでの要素の寄与の合計　とするとこれはとりあえず意味を持つ値で、上手くいきやすい

## 同じkeyに入っている遷移は問題の設定かで同質である・同一視できないといけない
- よって、同一視できてないと思ったら、同一視できていることを再確認したりdpの定義を変える必要がある  

- [かけてM以下](https://atcoder.jp/contests/abc239/tasks/abc239_h)
    - 商列挙の考えを同一視に用いたい
    - M / xの値の個数は小さい
    - ある値を見た時、「k以上の値をかけたら超える」が一位に定まる => 問題が小さくなる
    - $\lfloor \lfloor M/i \rfloor /j \rfloor = \lfloor M / (ij) \rfloor$ より小さくなった問題の個数は結局 $O(\sqrt M)$ 個
    - 演算2回が演算1回で表せる => 結局値の範囲が広がらないことが言える
        - 状態数の見積もりに使える

## 設計・再帰的に解く時
- 必要なこと: 状態を、うまく繰り返されるものとして選ぶ必要がある
    - **特に、初手の結果で場合分けすると問題が小さくなる、は頻出**
    - 特に、「新たに考慮するようにした要素（順序がないなら一つ適当に選ぶ: 集合dp）」について、その要素で場合分けすると、自然とサイズが小さくなる場合が多い

- いつ考える:  全探索したい -> dpで高速にやりたい -> どういうdpを立てたら良い？がすぐにわからないとき

    - [辺をはる。入・出次数が定まっているとき、集合Sが一つの連結成分になるような変の貼り方](https://atcoder.jp/contests/abc321/tasks/abc321_g)
    - まず、S内で辺が収まるような貼り方の場合の和は簡単
    - Sの要素を1つ取って、そいつが含まれる連結成分のサイズで場合分けしよう
        - それを引いていけば答えが求まる

- また、問題の対象がなんらかの理由で独立になった場合、そこを区切りとして問題を分けることで問題のサイズを小さくするというのは良くある流れである。
    - [全体にaddしない <- 操作が来ない行がある <- 独立に解けば良い](https://atcoder.jp/contests/abc233/tasks/abc233_g)
        - [sy, ty)*[sx, tx)を状態としてもてば良い
            - 来ない行・列を両方固定すると $O(N^6)$ だが、テーブルが豊富なので、実は固定は別々にやって良い
        
- 問題文で与えられているものがあるなら、それを利用すると丸い
    - 辻褄合わせというのは　「自分の定義したやつなら求められるぞ -> 実際のゲームは初手にOOできるじゃん -> それ反映するために定義ずらす/状態量増やさないとダメじゃん -> あばばばば」

## 探索対象が曖昧な時：固定した時の探索
- OOなものに対して探索せよという問題は多い
    - ex:操作によって、回文が作れるか？
- この時のよくあるパターンとして
    - OOの特徴づけから攻める
    - 上手い特徴づけがわからず探索が立てられない時: OOに含まれるものを1つ具体的に固定した上で探索を考える。その上で、その判定法を元に、全てのOOに対して探索を平衡に(まとめながら）進めるというアプローチが有効

## 無限に続く探索
- dpをしようにも、探索が無限に続くのでテーブルのサイズも無限といったことがある
- この時、探索の進度を軸に持たないようなdpテーブルを作れることがある
    - 探索に終了がない・他の情報で終了を判定でき、かつ答えも計算できる
        - 往々にして、添え字を消すとDAGではなくなるが、それでももとまる場合が多い
        - ダイクストラケース
- いつ考える: 特に「探索の終了判定にどこまで遷移したのかが・今何個埋めたかが必要ない時」、具体例としては「任意桁の整数を全探索したい時」
    - いつも必要な理由 <- 桁によって遷移が変わることがある、および（多分ほとんどの場合で共通するのが）探索の終了の判定に用いる
    - よって、例えば、「任意の桁の整数を探索したい」という時、桁の情報をロストさせても終了条件に桁がないので困らない
        - 桁が大きくなる事を考えると都合が良い
    - では何を持つのかというと、「探索の途中で、未来に向けてもつべき情報」のみを持つ。かつ、進度を持たない。
    
    - [文字列・末尾追加の探索](https://atcoder.jp/contests/abc264/tasks/abc264_g)
        - 何文字追加したかどうでも良く、状態が末尾2文字になる
            - 文字数消すとDAGではなくなる
        - 遷移をグラフで考える
            - 再長距離...ベルマンフォードでもとまる（符号flip）
    - [文字列連結](https://atcoder.jp/contests/abc175/tasks/abc175_f)
        - 使用個数に制限をかけられず、長さに制限をかけられない
            - 特に: -1の時
        - 回文を固定した時、それが作れるかの判定をdpにしよう
        - 必要なもの: いくつはみ出ているか
            - 有限サイズのテーブルができた
            - ダイクストラで埋まる

## 纏めて計算する事による高速化
dpの基礎理念の一つ
- 高速化する上で普遍的に有効
- 何らかのパラメーターが一致・遷移の係数が同じなどに、纏められて一気に計算できる場合がある
    - 例: 毎回 dp[i][1] += 2 * dp[i - 1][1] 、 dp[i][2] += 2 * dp[i - 1][2]の場合、
    - dp[i] := dp[i][1] + dp[i][2] が高速に求められる
        - 最終的に求める値が得られるのなら、こっちで良い
      

# 遷移に注目する高速化
## 遷移の　細分化　⇔ 統合
- 所謂、細かく遷移・まとめて遷移
> 命題: 遷移を細かくすると、細かくした分計算がよりまとめられる
- 大きく遷移することにすると、「前半は同じ」或いは「後半は同じ」な遷移も別々に計算されてしまう
- 必要なこと: 細かく遷移しても、持つべき状態数が爆発しない

   

- 複数段階をまとめて遷移
    - 必要なこと: 求まる
    - いつ考える: 基本的に細かく遷移より遅い。その間の遷移を全探索する必要があり、そこをまとめる事ができないため。しかし、細かく遷移しては持つべき状態数が多くなるという時、「一様な部分について、まとめて考える」と言った思考によって、状態数が少なくなる場合がある。ここで特に遷移も間に合うようにできると、こちらが有利になる
        - 細かく遷移と比べて危険なことは承知すべき
        - 特に、「まとめて遷移することにしたが、状態が減ったわけではない」という時に危険
    - まとめて、の粒度にも自由度がある
        - 基本的に細かく遷移するが、ある種類のものについて処理し終わった時点で、1回dpテーブルを集約するようなまとめ方
                
    - 前計算によって、まとめて遷移する際の係数がもとまっているならば細かく遷移するよりも速くなる場合がある
        - 前計算をする動機とその内容

## 遷移を纏める
- 係数が同じ遷移は、いちいち分けて遷移せずにまとめてやりたい
    - 特に、係数1のケースは多い

- 固定したいものが多い場合がある。
    - 答え（値）を特に大きく特徴づける要素だけ固定して、他は「それを固定した時、それが取りうる値の範囲」を出すと「一部だけ固定した時、アリエルパラメーターは？」が解けて、結局そのパラメータは固定せずにまとめられがち

## 配るdp -> 貰うdp
往々にして、非自明高速化がされる
- いつ考える: dpを高速化したいならいつも

- データ構造に相性が良かったり
    - 配り先が区間/貰い元が区間は両方あり得て、これは対等

- 無駄な遷移を省く高速化
    - topK探索。元から最適だけを選んでpopを繰り返す

- 遷移先が共通しているものが多いという時、その「先が共通した遷移」をまとめてできる


## データ構造を使う高速化
- 必要な事: 遷移がデータ構造に載る
    - 多くの場合:区間
    - 他slope trick/1次関数max/fps:inv
- いつ考える: 高速化したい時に、その1手として。また、「とりあえず愚直を書いた」時に見るべき。

- dp[state]からの遷移が区間
    - imos, 遅延セグ木
- dp[state]への遷移が区間
    - 累積和、セグ木



## 遷移を分けて計算する
- 2種類の遷移があるという時、それらを同時に処理する必要がない・別々に遷移して良い場合がある
    - 例: 加算
    - 例： max
    - 例: $dp[i] = max(dp[j] + C[j], dp[j] - C[j]) のような場合、まず dp[j]+C[j]でchmaxしたのち、dp[j] - C[j]でchmaxして良い

- そのような時は、別々に処理する事で遷移が単純になり、高速化がなされる場合がある
    - あるいは、計算量が良くなる（データ構造の利用、列をreverseして2回...）

- 必要な事: 遷移を分けて計算して良い
- いつ使う: 積極的に使う。
    - 一般に、独立に処理して良いなら、個別に処理した方がやりやすい。

- [bitdp、2種類の遷移。片方はダイクストラdp](https://atcoder.jp/contests/abc364/tasks/abc364_g)
    - ダイクストラdpの方はループがあり、ややこしい
    - 部分集合列挙の方を先に処理してしまって、その後にダイクストラdpに集中する

## 探索の順・軸の変更
- 判定に用いる情報が少なくなるように軸を変更すれば、当然それによって解ける場合がある
    - 挿入dpなりなんなり、多くのdpにはindexの昇順・降順 / 値の昇順・光順がバリエーションとしてある
- なんか特殊な考察をする前に、これを検討したほうが良さそう
    - 必要な事: 後の為に必要な情報が少ない事
        - これさえ満たせば良い。かつ、バリエーションが結構ある上、思いつきにくいものでもない。
    
    - [辞書順の制約、たくさんの列 <- 列の前から埋めていく](https://atcoder.jp/contests/abc292/tasks/abc292_g)
        - 行ごと埋める...どの桁がどの数字？を覚えないときつい
            - 初めて超える行を固定したとしても、場合の数が綺麗にもとまらない
        - 行ごとに埋めずに、列ごとに埋めていくと、問題が独立になって解けるらしい
    - [整数に対し、末尾への数字のaddを1段階の遷移と見る](https://atcoder.jp/contests/abc222/tasks/abc222_g)
        - x -> 10x + 2
        - [無限桁の場合](https://atcoder.jp/contests/arc084/tasks/arc084_b)
            - dp[i][m]...i桁で mod K = m の時、けた和のmin
                - iは終了判定にも遷移にもいらない -> 消して良い
                    - dp[m] ... mod K = m の桁和のmin 軸の添字を消してもdpが回るタイプ


- 意味のない遷移が多かったり、有効な遷移以外にも「遷移の候補」について判定していて上手くいかない時は、有効な遷移の集合の構造について考察すると良さそう
    - 特に、有効な遷移だけ実行するようにする
    - この時、遷移全てが復元できる必要はない。答えを求めるのに必要な情報が欲しい。よって、その意味での構造であり、条件ではない
        - 係数が同じ遷移をまとめる考えを使うと、例えば遷移が存在する要素の個数だけ知りたくなる

## 遷移先の状態数が少ない
集計するものが
- State: bool (重複なし。種類数を・あり得るものを数えよ) -> 判定問題を解いた方が、遷移が減って計算量落ちるかも
- Steta: 数（重複あり） -> 貰う、inline 

## 遷移が行う固定に条件を盛る
- 問題の構造とdpの遷移によっては、自然な定義からさらに条件を追加して良い場合がある
    - [区間dp・数列から削除](https://codeforces.com/gym/105633/problem/L)
        - 素直...dp[l][r]に対し、残す要素kを全探索
        - ここで、削除する問題であることから、kについて「残る要素の中で最右 (= それより右は全て消す）という制限をつけられる
        - 今回は使わないけどいつか役にたつかも
            - 例えば全部消す時は簡単なら
            - dp[r] := [0, r)として、残る中で最右を全探索すれば $O(N^2)$ に落ちるかも


# 状態に注目した高速化

## 遷移の係数が一致するもの状態を纏める
- 遷移の係数が一致するならば、その状態をまとめて計算しても答えが求まる。よって、まとめた分高速化になる


## 独立ではない添字の評価
- 添字として持つ情報で独立ではない物がある時、その関係性によって状態数が減る場合がある。
- 命題: 添字のサイズをそれぞれ**独立に**考えた時のサイズを掛け合わせたものは、情報間に実際には関わりがある時オーダーレベルで大きい可能性がある
    - 必要な事: 添字の情報が独立でない時
    - 何を考える: 情報の数が絞れないか
        - 特に, あるkeyのサイズを固定した時、他のkeyのサイズがその固定によって抑えられないか
- dp[a][b][c]について, A, B, Cをそれぞれ母集団を独立に見た時のサイズの最大値とすると、愚直に考えるとABC状態だが
- 命題: aが定まれば b, cも定まる時、高々A状態
- 命題: 具体的に (aの状態数) * (bの状態数) < AB がわかれば、オーダーが落ちる
    - [dp[mod][sum]](https://atcoder.jp/contests/joi2020ho/tasks/joi2020ho_d)
        - mod, costはそれぞれ N, N^2が独立に見た時のmax
        - modが大きい時、コストが全然かからない
        - modをmとして、コストが N^2/mで抑えられる
            - N^2で状態数が抑えられる

## 計算に必要な情報
コツ : その添字が"いつ" "何のために" 必要なのか、詳しく考える
- > 命題 : 今他に持つ情報に反映できる情報は、keyとして持たなくても良い
- > 命題 : コストがかかるとわかっている要素はわざわざkeyに持たなくて良い
    - 系: 最初に選んだ要素にコストという時
        - 1つでも選んだ or notをkeyに持つ/初期化の時にコストを加算する 事で、最初に選んだ要素をkeyに持たずとも処理できる
    - 系: 最後に選んだ要素にコストという時
        - 毎回、前に選んだ要素分を引いて、今選んだ要素分をaddできると、最後に選んだ要素を持たずとも処理できる
        - 最後に選んだ要素をkeyにして、一旦そのコストは忘れる 事で処理できる
    - 系: 以降全ての選択に追加コストという時
        - 今の影響で今後にかかるコストが今わかれば、それを加算しておく事で追加コストの情報を持たずとも処理できる


> 命題: dpで持つ情報は、その遷移の最終的な答えを計算する為に必要な情報     
- > 系: 最終的な結果を固定した時に、そこから答えを計算するのに必要な情報さえ持てば良い
    - 答えを計算するのに必要な情報に対し、経過は複雑なことがある。しかし、その経過を識別するための情報は必要ない。最終的な答えを決定する情報さえ持てばよい。


## 判定問題を解く -> dpで持つ情報や軸の考察
> 命題: 最終的な状態を固定した時の答えの計算ができるならば、次のdpができる。
> 1. 最終的な状態を部分的に固定する
> 2. dpで持つ情報を元に、その部分の計算をして次の状態に引き継ぐ

- 最終的な結果を固定すればよく、途中段階の操作を見ないで良い
    - 操作は往々にして複雑
    - 無駄な操作を調べない

- 特に、判定の解で一見「最終的な解の形」が必要になってしまったら、具体的に「最終的な解の何が必要なのか」の「何」をkeyにdpすると良い
    


### サイズを大きくしていく探索
## 独立なもの同士では一切の情報の共有がいらない -> 分けて計算して、最後にかける(dpにおける独立性)
- こう意識して設計すると計算量が落ちる
    - 顕著な理由: 独立なパートでそれぞれ状態が S, T通りある時、まとめて持ってしまうと S * T通りの状態になるが、分けて計算することにすれば S + T通りとなる。
- よって、判定の時も「こう考えたらあとは独立」と言う構造が見えたら、そのような判定方は上記の手法を守ると上手くいきやすい
 

- サイズを小さくしていく探索の探索順を逆にすると、サイズを大きくしていく探索ができる事がある
    - 所謂後退解析
- 新たにaddした要素の場合分けで注目している問題のサイズを落とすのは変わらないが、後退解析では「今までに計算した結果を元に、今の場合分けの結果を求める」という側面が強い

- 必要な事: サイズを大きくしていくようになっている事
- いつ使う: ゲーム、今の場合分けのどれを採用すべきかわからないdp
    - 今何をすれば良いかがわからないため、状態が膨大な時、後ろから見ることによってすっきり解ける場合がる

## (上手くいかない原因) : （状態、遷移）が細かすぎる かつ 遷移先が多様だという時
**状態の定義 -> それらの間の遷移を考えた時、探索の順序に関わらず、その時の遷移の計算にどうしても大量の情報が必要で結局まとめられないことは多々ある。**
- 数え上げ: addして良いかの判定・係数の計算にとても多くの情報を持たないといけない・遷移の種類が多様である
    - 往々にしてこれは、探索順を工夫することで遷移の形に制限がつき、判定に必要な情報が落ちてdpが計算できたりする。しかし、どんな探索順でも無理だと思うこともある
    - この原因の一つに、「状態の定義 -> それらの間の遷移」という形式において、状態が細かすぎるせいで遷移先も多様化しているという場合がある
    - 状態の細かさと遷移の細かさはある程度対応している

- ここで、答えが求まる範囲で上手く状態の情報をロストさせつつ遷移が計算できるような状態を定義できれば、（情報がロストしたことにより）却って遷移が計算しやすくなり結果的に高速に求まる場合がある
    - シミュレーションなら重要なところだけ抜き出す
    - 数え上げや最適化なら、答えの計算・遷移に必要な情報以外をロストさせる

- いつ考える: 「状態の定義 -> それらの間の遷移」において、遷移が多様すぎたりしてこのままの遷移では情報のロスト・遷移の共通化ができない時

<br><br>

## 今までの計算結果を再利用することによる高速化
dpの基礎理念の一つ
- 特に、貰うdpの考え方をする時に頻出
- 今まで計算した問題のサイズと比べて、サイズが大きくなっている要因に触れないようなケースは全て計算済みである
    - **よって、サイズが大きくなっている原因に触れる遷移・探索対象にだけ計算すれば良く、その要素に触れない遷移はわざわざ計算しなくて良い**
    - 例えば、要素の使用/notについて見ていくdpで、左からみていく: [0, r)について考えるのならば、r-1を用いないケースはすでに計算済みなので、r-1を用いるケースに絞って計算すれば良い。


- 他に一般に、「この情報を更新して気さえすれば解ける」という時(特に、「遷移ごとに情報を持つ」ことにこだわっていないことに注意)、dpとして「今までに"計算した情報"」を持つことがある
    - 寄与の分解等でよくある。
        -「今まで計算した情報から、今回の情報が計算できる」ことが必要であり、「遷移を纏める」のような発想よりも一般的である
    - 必要なこと: 定義通りの情報が、今までの情報から求まること　であり、特に上の例に注意。 
    - いつ考える: 寄与の分解の時は多い
        - 遷移を持つわけではないので、状態量少ないことがある（全体についてのテーブルを一つ持てば十分）という風に感じる
            - そこまできっちり区別があるわけではなさそう。

- 大部分を共有する、パラメータが異なるクエリについて答えるという場合に、dpの添字としてそのパラメータを追加するということもある
- 必要な事: 問題のサイズが小さくなる事、問題の種類数（dpの添字の数）を少なく抑えられる事
- いつ使う: 常に考えれば良い
    - 前計算より


## dpしながら答えを集約するタイプの問題
dpしながら、途中でテーブルの値を使って外で計算する場合。
- 集約値が、dpが進むに従って、明示的な変化がないにも関わらず変化することがある.
    - 例えば、寄与に分解する問題で、探索しながらすべての遷移についてなんかのsumをとっていたとする。この時、すべての遷移が2つに分裂したならば、今までの値も2倍になるはずである。よって、ans変数を持っていたら、ans変数の値も2倍しなければならない。 
- 必要なこと: dpの途中結果を外に反映させるなら、「その外の結果の、dpを進めことによる変化」もちゃんと更新しなければならない。


## 遷移の固定・ループを減らす事による高速化
- 特に再帰的に解く時、「遷移の和を減らす・固定の数を減らしても、十分dpテーブルから答えが求められるため、答えが求まる」という場合がある
- 必要な事: 固定を全て試さない・大雑把な場合分けであっても、dpテーブルに載っている程度にサイズが小さくなる事
- いつ考える: オーダーを落としたく、遷移の本数を減らす事によって高速したい時。dpとして持つ情報が多い時（多次元）
    - y, xを両方固定しなくても、y, xを別々に固定すれば十分サイズが小さくなり、dpテーブルに答えが書いてる

## 1番軸となる添字の変更・削除/DPのループ順
**DAGになってるものは全て軸になれる**
- 例: 数列の "i項目" まで決めて, ...


ここで、iが
- 各段階の値の計算には**必須でない・影響しない時** ... **別方針でうまく行ったりする**
    - 探索順を変える...
- **iの他にも、必ず増加する・減少する要素がある**... **iを持たなくてもdpが回ったりする**
    - iが無くともDAGパターン
    - 計算にiが必要ならば、依然iは添字に含む事になる。しかし、**iが必要なかった場合、iを持っていた分計算量が落ちる。**
        - 必要無い典型パターン...項数に制限がない数列・或いは集合の数え上げ
            - [例題](https://atcoder.jp/contests/arc107/tasks/arc107_d)



#### how
- iを落とした上で、新たな軸になるものがある・DAGになっていないか見る
    - とりあえず初期化をする
    - **遷移がDAGになっていたらdpできる！**
        - 最大値は必ず増えていくので...
        - 区間を右端でsortして順に見る事で、区間の右端は常に増えていくので...
            - [例題](https://atcoder.jp/contests/arc026/tasks/arc026_3)


- dpの探索順を変えてしまう
そもそも筋の悪い探索順を選んでいる可能性。
数列を定めると言っても、左から定める必然性は無い。
    - 右から...
    - 大きい値から...
    - 最下位bitから...
    - 終端状態から...
## 考える要素が複数ある時 -> 条件に一番近い要素を軸にすると良いことが多い
- 特に: 結局条件の判定に値の大小が関わるなら、左からではなく小さい・大きい方からの方が良いことが多い

### dpのループ順を変える事で、dpが破綻する場合がある
- 0/1ナップザック
    - 重さの昇順にやると、同じアイテムを2回以上使う場合がある

- 集合への分割・集合のサイズごとに係数を掛けて修正する
    - 集合のサイズを最初の添字に持ってこないと、 + |1|のやつ -> + |2|のやつ -> + |1|のやつ　といった遷移をしてしまう
    - 絶対に逆転してほしくないものは、一番外の添字に持ってくると安全


## 何かしらのパラメータを共有する要素が多い時
そのパラメータごとにまとめて処理することで高速化がなされる場合がある
- [パラメータを共有する中で、必要ないものを捨てる最適化](https://atcoder.jp/contests/abc373/tasks/abc373_f)
    - アイテムを分離できる
        - N^2このアイテム、間に合わない
        - CHTでも解けるらしい...?
    - 重みを共有するアイテムが多いことに注目
    - 重みごとに処理しよう
    - 重みwについて、上位 W / w個しか残さなくて良い
<br><br>




## 状態数 * 遷移が計算量ではない。添字を減らさない・状態量を減らさない高速化/ inline dp
- 必要な事: 更新を、前のdpテーブルを土台に用いる事で高速に行える事。かつ、dpテーブルのサイズが持てるぐらいに小さい事
    - 変化点が少ない場合、では無い
        - 区間変更は大体対応できる。区間が3つぐらいに分かれてもできる。
        - データ構造でカバーできるものは全てできる
    - 特に、最適化において、「ここは更新しなくても良い」という枝刈りを用いて行われる
    - 或いは単に数え上げでも「変化するならば、変化後の状態はこれになる」といったものが絞れれば、そこだけ更新する/ 他は一様に更新する　等とできる。
    - ただし、持つべきdpテーブルのサイズが10^10になってしまい、かつ省略できない時などはそもそも考えられない。

- いつ考える: 全探索を高速化したい
    - 「選んだ・選ばない」dpで、選んだ物の特徴をkeyに持つならば、常にinline dpである。
    - nxtdp(i -> i+1)にしか遷移がない時はやりやすい
    - dpが1次元の時は特にやりやすいが、2次元でもできる
    - 「そのまま遷移する・一意に遷移する」ものはinline dpに乗りやすい
- 多項式のdpがたったならば、それを立式する事・変更が入る添字の量を見ることが必要
    - 多項式のdpは高速化ができれば答えられるし、できる場合が多い。    
    - 遷移の順番でバグりやすいので気を付ける
        - [選ばない場合iが増えるだけ、選ぶ場合遷移先が限られる場合](https://atcoder.jp/contests/abc176/tasks/abc176_f)
            - 採用しない場合、値を+0/1してiを増やすだけ
            - 採用する場合、採用先の添字が絞られる
                - そこだけ丁寧に更新しよう

        - [殆どの場合、dpテーブルがスライドするだけ](https://atcoder.jp/contests/abc372/tasks/abc372_f)

        - [多項式dp -> 遷移を考えると、1箇所にしか変更がなく、その量はprodでできる](https://atcoder.jp/contests/abc279/tasks/abc279_g)
            - できるだけ情報を落とすと、dp[i][last]の形
            - 初期化...dp[i][-n]に来たと思う。prod, addを関数にして包む。
        - [選んだ・選ばないでdp && 最後に選んだ物の色を持つ -> inline dp  状態 * 遷移数 よりも計算量が落ちる](https://atcoder.jp/contests/abc383/tasks/abc383_f)




<br><br>


## 全探索のdp化
**DAGになってるものは全て軸になれる**。
よって、探索の過程で単調に変化するものがあれば、それを軸にメモ化できる。
[url](https://atcoder.jp/contests/abc363/tasks/abc363_f)

- **典型: 考察対象の数を小さくする様式変形** [例題](https://atcoder.jp/contests/arc176/tasks/arc176_b) (ユークリッドの互助方)
    - how ? 
        - modを取る ... 割れるだけ割る
        - gcdは左右入れ替えても良い

#### DPの計算時、ループの外側に出せる計算・if文はループの外側に出すべき
不要な再計算・ループの排除・高速化に気づきやすくなる。
- [例題]( https://atcoder.jp/contests/npcapc_2024/tasks/npcapc_2024_i)

#### DPにおいて、dp[i] * x[j]のようなことを繰り返す時
- 係数を取り出して [1]係数の和を求める(今回で言えばx[j]の和) [2]本データと掛け合わせる　とすると、和を求めるパートの高速化に気づきやすい
- [例題](https://atcoder.jp/contests/arc059/tasks/arc059_c)
#### DPのループ順の変更による高速化
- [例題](https://atcoder.jp/contests/arc059/tasks/arc059_c)
    - 前状態固定→今状態固定→今状態の計算
        - ループ3乗
    - 今状態固定→今状態の計算→前状態固定
        - ループ2乗
        - 積の和の構造が背景にある（先にそれぞれの項で和を取っても構わない


#### DPの計算時、もしif文の中にループ変数が入っているならば、そのループが何回まわるかを見る
特に、 if(i == 0) 等のループは1回しか回らない。よって、その中身だけ大量の計算量をかける事が許される。

#### 有効な遷移が少ない時
- 遷移を管理しながらdp
- 最短経路に帰着。辺を遷移に対応、頂点を状態に対応する。

- 独立な遷移を分解して、それぞれについて調べる
    - 次元が落ちることにより、高速化が見やすくなる
        - グリッド上・正方形について調べる...角の点を一つ固定すれば、相手は斜めの対角線上←直線の問題
        
<br><br>

## 時間軸を加えるdp
- 挿入dpは操作の順番に結果が依存するような時の全探索として強い
    - 最初or最後に操作する要素を全探索するようなdpであった
    - 逆に、順番に依存しないなら区間dpで無くて良い

- 順番に依存するような状況であっても、区間dpをしなくても解ける場合はある
    - 所謂挿入DP
    - 最後の要素をi番目とできるか、が高速に判定できれば$O(N^2)$がとりあえず回る
        - 区間dpのとりあえず$O(N^3)$よりも高速
        - [隣り合う要素について、大小関係の制約](https://atcoder.jp/contests/abc209/tasks/abc209_f)
            - 区間dpでもO(N^3)で解けるが、そこからが見えない
            - 制約が隣り合う要素についてだけなので、左から追加していくと、隣の要素がどこにあったかを判定できればO(1)で遷移できる

## mapで状態をもつdp
- 必要なこと: keyの母集団に対して、実際にkeyが取りうる値がオーダーレベルで少ないこと
- いつ考える: 高速化したい時。特に、「dpでOOの情報が必要なので、取り敢えずそれをkeyに追加した」という時、よく考えたら取りうるkeyが少なかったということが良くある。

## 未来の決定を保留するdp
- 必要なこと:今保留しても、選択肢・遷移が変化しない（決定する必要がない）
- いつ考える: 未来に探索する範囲にまで影響がある時
    - その影響を持っては状態量が多くなるが、決定を遅延させれば多くならない
    - ただし、影響を一意に決定できるなら先に処理してしまった方が良い（原則）
        - この場合、遷移が1通りの時？

## ちょっと変なdp
- 探索で、「最後だけ」条件が変わる...最後の一手前までdp
    - [例題](https://atcoder.jp/contests/abc364/tasks/abc364_e)
        - 最後だけ、リミットを飛び越えて良い←最後に何を食べるかに寄る
        - 最後の前は、「リミットを飛び越えない様に食べる」←食べる順に寄らない

## nxtdp
- 変な初期化をやりやすい
    - 配列のdp[-1]を埋めたいなぁみたいな時、それができる
# 最適化のdp

## 違法遷移
dpは、dpテーブルが正しく求まっていく事さえ守られれば、どのようなdpを立てても良い。特に最適化では、重複した遷移・本来は許されない遷移も、計算量削減・考察の軽減のためにゆるす場合がある
- 必要な事: dpテーブルが正しく求まる事
    - これが保証されないと訳がわからない
        - 最適解が探索に含まれ、かつ、元の問題設定より有利になるような遷移がない事
- いつ使う: 厳密にやると情報の取得がめんどくさい・まとめて遷移したい等
- [最適が含まれるのでokな例](https://atcoder.jp/contests/abc176/tasks/abc176_f)
    - dp[i][BS] := 少なくともペアの片方にiが含まれる時、もう片方としてあり得る集合をBS
        - ペアについて、含まれうる添字全てに反映しようと間に合わない
        - 任意のペアがテーブルのどっかにあれば良い
        - 配るdpを考えて、そこから派生する任意のペアがi+1のドッカに入れば良い！
            - この制約の元、都合の良い(bit set orで更新できる)ようなところにだけ更新する

## ダイクストラdp
- dpの遷移にループがあろうと、最適化ならばもとまる場合がある
    - 添字の昇順では無く、値の昇順に埋めていく。

- 必要な事: コスト最小の始点がある・ダイクストラ風味にできる
- いつ使う: ループがあって、どう埋めていけば良いのかという時
<br><br>

## 指数の肩を1/2にするテク
いわゆる半分全列挙
- 嬉しい: 全探索が間に合うようになり、全探索を適応できるようになる
    - 厳しい問題も解ける
- 何が必要: 探索空間を2つに分けた時、その結果を適切な前処理を元に高速に融合できること。
- いつ使う: 数字が/2にさえなれば全探索が間に合う・全探索が少し間に合わない時
- [dpが厳しいが、半分全列挙で全探索的に解ける](https://atcoder.jp/contests/agc026/tasks/agc026_c)
    - 2 ^ 36は間に合わない
    - 組み合わせ全探索も微妙に間に合わない
        - しかし、dpは難しい
        - 必要条件的にアルファベットを順についかしていく等も考えられるが、うまくいかない
        - 半分全列挙ができる
        - 必要: {赤文字列、青文字列} := その通り数　のテーブル
        - できる

<br><br>

## 二分探索/尺取り法
列に対して、「lを定めた時、条件を初めて満たすrは？」を求めたいというのは良くある。
以下の二つとも、何が単調なのか考えること。
- ここを曖昧にすると混乱する
### 二分探索
- 使える必要条件
    - 区間クエリが高速に捌ける事

- 特記事項z
    - 区間クエリさえ捌ければまあ使える
    - 全てのLに対してではなくても、特定のlに対してだけ$O(log)$で求めることができる
### 尺取り法
- 使える必要条件
    - rがlに対して単調なだけでなく、一般に区間の"広さ"に対して単調性がある事
    
- 特記事項

    - 全てのLに対して求めるアルゴリズムであって、特定のlに対してだけ求める事はできない
    
    - 区間クエリが高速に捌けなくて良い
        - 差分を更新するような計算の時、二分探索では解けずに尺取り法によってのみ解ける
            - 転倒数 >= K を満たす部分列の数え上げ...
            - [特殊な形のsum >= Kとなるr](https://atcoder.jp/contests/abc337/tasks/abc337_f)
                - x = 1...nに対して、|xが登場する回数|/K を求めsumを取った時、それが初めてKを超えるrが知りたい
                    - この区間クエリは高速に捌けない
                        - 明らかに、区間長に対して単調
                    - 尺取り法で求められる

    - 区間長に対する単調性さえあれば、毎回区間クエリを飛ばしたとしても二分探索より早い
<br><br>

## テクニック

### dpの情報について、index vs 個数
- indexが重要な情報の時はindexを持つのが良い
- しかし、index自体に情報はなく、ただ個数だけが必要だという時は、個数で定義しないと上手く回らない事がある   
    - 特に挿入dpのように、配列に挟んだりする問題では、元のindexが役に立たない（厳密には遷移に必要な情報と一致しなくて計算できない）事がある
    - [indexではなく個数をkeyに持たないと遷移が計算できない・個数にするとスッといく問題](https://atcoder.jp/contests/agc065/tasks/agc065_b)

- **配るdpしか試してないなら、貰うdpを試す**
    - 定番 && 非自明オーダー落ちも多い

- dpのkeyと中身をswapする
    - 中身の値の範囲が小さい時、オーダーが落ちる
        - [例題](https://atcoder.jp/contests/abc364/tasks/abc364_e), ナップザック
        - [それをすると高速化が見える](https://atcoder.jp/contests/abc176/tasks/abc176_f)
            - dp[i][j][k] := 残り(j, k)の時の、今までの値のmax
                - 良く考えると、値は2種しか保存しなくて良い
                - dp[i][val] := 今までの値がvalの時の、あり得るペアの集合
                - **集合を持つdpはbitset高速化!**
                - dp[i][val][l] := 今までの値がval, ペアの片方がl, あり得るrの集合をbitsetで持つ
                - 間に合う
- **lcmを含む式はgcdの式にする**
     - **lcmと違い、gcdは数が少ない**
     
- **操作のどれを1段階とするかは自由に決めて良い(DPと同じ)。特に、操作をさらに細かくすることで1回を軽くすることもある。**

- **「明らかに調べなくて良い」「これだけは別途楽に計算できる」事を事前に省いた結果、実は計算量を劇的に減らすことがある。主に最適化の文脈。**
  -最悪ケースを考えると気づくかもしれない
  
- **答えの個数・値が小さいなら、探索範囲をせばせて良いかも**

- **「bit/素因数ごとに分ける」と「分けずにまとめて計算する」**

- **dp...「extraな計算が何回起こるか知りたい」→[不変量]どういう状況でその計算が走る？特に、その計算が走る時に必ず減るものはないか？**

- loopの枝刈り...下からも絞ると効果覿面
- loopの中のcontinue...事前にloopの範囲を狭められると高速化。特に、loopの中がO(1)とかならオーダーレベルで速くなる場合。



- **線形漸化式なら行列累乗**
    - いつでも使える
    - [例題 : グラフの問題](https://atcoder.jp/contests/abc199/tasks/abc199_f)

- **std::set**
    - 割と簡単にfastsetに変えられる

- **unordered_map**
    - reverveする
    - アクセスする時はキーが存在するか見てからやる

- **vector/arrayを載せたmap/unordered_mapは定数倍がやばい**
    - logのレベルじゃない
    - $N = 5000$ で $O(N^2)$ <- メモ化再帰にmap必要ならだいぶ怪しい 
        - テーブルがvectorに乗るなら多分間に合う
- 全ての2ペアについて見るのは $O(N^2)$ だが、 同値類をまとめる作業は $O(N)$
    - 感覚的な話で良い
    - [使っていそう](https://atcoder.jp/contests/abc348/tasks/abc348_f)

- 連続したら、長さだけボーナス
    - 一つ前と同じならボーナス
    - [例題](https://atcoder.jp/contests/arc010/editorial/6566)
    - +演算の、寄与の分解と見れる


- A[a+b] = f(A[a], A[b]) の漸化式から高速にn項目を求める
    - 再帰関数にすると簡単

- 逆元がない時の $\sum r^i$
    - 上に帰着
    - S[a + b] = S[a] + r^a S[b]


- 2次元のdp
    - 平面操作
    - 最適化なら、inplaceを疑う
        - しなくても答えが変わらない遷移を無視する
        - [例題](https://atcoder.jp/contests/abc369/tasks/abc369_f)
            - 横に移動するのは、コインを取る時だけとする


- 逆元がない時
    - 等比数列の和
        - 割れないかも
        - 漸化式なら逆元がいらない

    - なんか立式した際に分母があるならば、その分母とmodが互いに素でないならば、消さないといけない
        - 別の解法: 漸化式
        - あるいは、分子を割れるなら、割った後の分子を考察する

- 単調増加列の個数は結構小さい！
    
## 実装
添字に持つ情報と遷移に必要な情報の形が違う時は、最初に情報を変換してから遷移の計算を考える
- [添字は時間、遷移は個数](https://atcoder.jp/contests/abc374/tasks/abc374_f)
    - 添字...時間tまで見て、ｒ個残っている
        - k個運ぶとする
        - 次の時間は? <- 一回、個数の添字を経由しないと難しい
        - よって、今添字いくつまで運んで、次添字いくつまでを運ぶのかを最初に計算すると早い


## 桁dp
- 桁数を固定して、上の桁から決めるパターン
    - 未満確定と、前半ピッタリ(=1 or 0)を持つ
    - 次の数字を全探索
        - 未満確定は必ず遷移する
        - ピッタリは、nxがoriginal未満or=で遷移
    - 配るならば、数字をチェックする桁が添え字とずれるかも


## 挿入dp

## 1要素目は初期化として置いといた方が良い
最初だけは他と質が違う場合がある
- [罠](https://atcoder.jp/contests/arc178/tasks/arc178_d)
    - 小さい要素から見て、
        - 1.fixされてるやつ...fix間での順序が守られればどこでもok
        - 2.fixされてないやつ...端ならどこでもok
    - で作られるやつを数える
    - fixされてるやつは順序固定 -> 最初から並べておく
    - これで最初のdpをシュミレーションすると?
    - v以下の値より左・右にあるfixedの情報が欲しい
    - 0は初期化!
    - if 0 is fixed ... 埋められる
    - if 0 is not fixed ... どこにおいても良い　埋められる
        - これを、最初以降と同じ枠組でやろうとする->一番ちいさいfixedの横しかありえないとしてずっとバグらせた
### 順番が固定されてるやつ -> 後から挿入せず、最初から並べておく
- 後から挿入よりも計算量が落ちやすい
    - 後から挿入だと、挿入の要素間の情報が欲しくなる -> 全ての区間についての情報の管理

### 挿入で左右の区別 -> 最初の要素に注意
- 最初の要素には左右とかない


## 円環DP
一般に次の枠組みでできる。
0, ... , n-1として
1. n-1の時のdpで持つ情報を固定する
2. dpに、固定した状態を書き込む
3. 0, ... , n - 1の順にnextdpをする
4. 最後のdpの、固定した状態のところを見る