# String

## Saffix_array
- (少なめの)文字列の**連続**部分列に対するクエリ
    - 終端まで続く部分文字列のうち、辞書順最小/max/k番目は...
        - reverseした文字の部分文字列のうち...
        - 2分割してreverse : 2つ繋げる事で、1つの文字列に対してreverse
    - 文字列 S の連続部分列の種類数を答えよ...
    - 文字列 S に文字列 T が連続部分列として幾つ含まれるか...
### LCP_array
- 共通部分文字列長に関するクエリ
    - 文字列S, Tに共通している連続部分列の最大長は...


## Trie
- いつ使える: 文字列のprefix/suffixについてのクエリを飛ばす時
- 嬉しい: ロリハで頑張る解法に比べて定数が良い？
    - ロリハはどこでも良いが、Trieはpref/sufに限る
    - 代わりにunordered_mapとかを必要としない

> 命題: aがbのprefixに含まれる ⇔ trie木において、aがbの先祖
    
- 文字列を1ずつ伸ばしていく時、一致する文字列を高速に取得
    - これもロリハでも定数悪くて良いなら解けるだろう
    - dpの高速化

- 文字列の集合がある時、全てのペア(i, j)について何かしら計算...

### 部分文字列dp
やっている事 : 集合から使う・使わないを選び、使うと選んだものをその順で結合。
- 前から使う・使わないを決めていく / できる文字列について、最初の文字を探索する... 様なdpと相性が良い。
    - [例題](https://atcoder.jp/contests/arc081/tasks/arc081_c)

### 2つの文字列の比較
A + B
B + A
のような図をブロックにして書くとわかりやすい

### 2つの文字列の一致
例えばAの末尾がBと一致すると分かったら、
A = A' + B
と分割してしまうと議論が進みやすい。
- そのままだと、「前後が一致する2つの文字列」に対しての議論で、難しい
- 一般の2つの文字列に対しての議論に持ち込めるため
### S + Tについての制約
- 1文字ずつ制約を分解する方法と、互助法的に制約を分離する方法がある
    - 1文字ずつ細かく見るのがかえって悪手になる場合がある

- S + T == T + S
    - S, T　が　周期 gcd(|S|, |T|)を持つ
        - |T| >= |S| として、
            - T = S + A
            - S + A == A + S の形に
            - 互助法的に小さくなっていく
            - 片方の長さが片方の倍数となったら終了

- 回文S, T に対し、 S + T も回文
    - S, Tが周期 gcd(|S|, |T|)を持ち、さらにその周期が回文
    - |T| >= |S|　として、
        - T = A + S
        - Aは回文
        - Sは回文
        - A + Sは回文
        - 互助法的に小さく
        - ちなみにT + S( = Trev + Srev = (S + T)rev)も回文
            - S + Tが回文と同値なので、好きな方を前に持ってきて考えて良い
                - 長い方とか
                - [例題](https://atcoder.jp/contests/arc048/tasks/arc048_c)
                - そのまま
    

## 文字種が少ない事の利用

### 分布の一致
アナグラムが一致⇔分布の一致
また、分布を表すローリングハッシュは $O(文字種)$ 、或いはそれに $\log$ をつけたぐらいの計算量で作れる
<br><br>