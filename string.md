
# Suffix_array・Lcp_array

> 定義(suffix_array): 文字列 $S$ の全てのsuffixをsortした配列。配列は文字列自体は持たず、それぞれの先頭の添字を格納する。

> 命題: 多重集合として、$\{s \mid S の \text{suffix} の \text{prefix}\}$ = $\{Sの部分文字列\}$  
- $S$ の部分文字列全てについてのクエリを、suffixのprefixへのクエリに変換可能
> 定義(lcp_array):
>$$ \text{lcp array}[i] := S[sa[i], n) と S[sa[i+1], n) の \text{suffix} のlcp

> 命題: 任意の文字列 $T$ について、 $T$ をprefixにもつ $S$ の suffix は、 suffix_arrayにおいて区間を成す  

証明: 辞書順比較の定義から、そうでないと矛盾

> 命題: $S[i, n)$ と $S[j, n)$ の lcp は、 それぞれに対応する suffix_array 上の添字を $a, b$ とした時、 $\min_{a \le j < b}$ $\text{lcp array}[i]$ と一致する 

証明: lcp長を $k$ とすると、上命題よりこの値は $k$ 以上。 かつ、 $k+1$ 以上を取らない。

> 命題: $S[sa[i], n)$ について、 $S[sa[i], sa[i] + lcp[i-1]+1), S[sa[i], sa[i] + lcp[i-1] + 2)...$ はそれより上位のsuffixのprefixではない    

証明: 2こ上の命題より、prefixならば、suffix arrayにおいて 1 つ上位のものも同じprefixをしていているが、lcp array の値に矛盾

> 定理(部分文字列の辞書順列挙): 次のアルゴリズムによって、部分列を重複を省いて辞書順に並べた時の $k$ 番目の文字列を $O(S)$ で得ることができる
> 1. c = 0で初期化
> 2. i = 0, ... , n - 1の順に、 $k$ 番目が見つかるまで 2 ~ 4をくり返す
> 3. p = len(S[sa[i], n)) - (i ? 0 : lcp[i-1] とする。この時、この行で初めて登場するprefixが、辞書順 [c, c + p) 番目の部分文字列に対応する
> 4. c += pとする


> 命題: S に T が部分文字列として何回含まれるかは saffix_array の対応する区間を2分探索で検索することで得られる
- T を prefix として含む suffixの個数をカウントすれば良い。
## LCP_array
- 共通部分文字列長に関するクエリ
    - 文字列S, Tに共通している連続部分列の最大長は...


<br><br>

# Trie
- いつ使える: 文字列のprefix/suffixについてのクエリを飛ばす時
- 嬉しい: ロリハで頑張る解法に比べて定数が良い？
    - ロリハはどこでも良いが、Trieはpref/sufに限る
    - 代わりにunordered_mapとかを必要としない

> 命題: aがbのprefixに含まれる ⇔ trie木において、aがbの先祖
    
- 文字列を1ずつ伸ばしていく時、一致する文字列を高速に取得
    - これもロリハでも定数悪くて良いなら解けるだろう
    - dpの高速化

- 文字列の集合がある時、全てのペア(i, j)について何かしら計算...

### 部分文字列dp
やっている事 : 集合から使う・使わないを選び、使うと選んだものをその順で結合。
- 前から使う・使わないを決めていく / できる文字列について、最初の文字を探索する... 様なdpと相性が良い。
    - [例題](https://atcoder.jp/contests/arc081/tasks/arc081_c)

### 2つの文字列の比較
A + B
B + A
のような図をブロックにして書くとわかりやすい

### 2つの文字列の一致
例えばAの末尾がBと一致すると分かったら、
A = A' + B
と分割してしまうと議論が進みやすい。
- そのままだと、「前後が一致する2つの文字列」に対しての議論で、難しい
- 一般の2つの文字列に対しての議論に持ち込めるため
### S + Tについての制約
- 1文字ずつ制約を分解する方法と、互助法的に制約を分離する方法がある
    - 1文字ずつ細かく見るのがかえって悪手になる場合がある

- S + T == T + S
    - S, T　が　周期 gcd(|S|, |T|)を持つ
        - |T| >= |S| として、
            - T = S + A
            - S + A == A + S の形に
            - 互助法的に小さくなっていく
            - 片方の長さが片方の倍数となったら終了

- 回文S, T に対し、 S + T も回文
    - S, Tが周期 gcd(|S|, |T|)を持ち、さらにその周期が回文
    - |T| >= |S|　として、
        - T = A + S
        - Aは回文
        - Sは回文
        - A + Sは回文
        - 互助法的に小さく
        - ちなみにT + S( = Trev + Srev = (S + T)rev)も回文
            - S + Tが回文と同値なので、好きな方を前に持ってきて考えて良い
                - 長い方とか
                - [例題](https://atcoder.jp/contests/arc048/tasks/arc048_c)
                - そのまま
    

## 文字種が少ない事の利用

### 分布の一致
アナグラムが一致⇔分布の一致
また、分布を表すローリングハッシュは $O(文字種)$ 、或いはそれに $\log$ をつけたぐらいの計算量で作れる
<br><br>